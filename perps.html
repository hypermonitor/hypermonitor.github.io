<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hypermonitor ‚Äî Hyperliquid Perps Prices (by Market Cap)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Live mid prices for all Hyperliquid perps, enriched with market cap and filters." />

  <meta property="og:title" content="Hypermonitor ‚Äî Hyperliquid Perps Prices" />
  <meta property="og:description" content="Live prices for all Hyperliquid perps, sorted by market cap with filters." />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Hypermonitor" />
  <!-- TODO: replace with your own social preview image -->
  <meta property="og:image" content="https://cdnstatic.tencentcs.com/edgeone/pages/assets/1765821358918-2Psz.png" />
  <meta property="og:url" content="https://www.hypermonitor.org/" />
  <link rel="canonical" href="https://www.hypermonitor.org/" />

  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,
  <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'>
    <defs>
      <linearGradient id='g' x1='0' y1='0' x2='1' y2='1'>
        <stop offset='0%25' stop-color='%2326d97f'/>
        <stop offset='100%25' stop-color='%2338bdf8'/>
      </linearGradient>
    </defs>
    <circle cx='32' cy='32' r='22' fill='url(%23g)'/>
  </svg>"/>

  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color-scheme: dark;
      --bg: #101014;
      --card-bg: #17181f;
      --accent: #26d97f;
      --accent-2: #38bdf8;
      --accent-soft: rgba(38, 217, 127, 0.18);
      --danger: #f25f5c;
      --muted: #a1a1b5;
      --border: #262637;
      --text-main: #f5f5ff;
      --shadow: 0 10px 24px rgba(0, 0, 0, 0.7);
      --radius: 0.9rem;
    }
    * { box-sizing: border-box; }
    body { margin: 0; padding: 0; background: var(--bg); color: var(--text-main); }
    a { color: inherit; text-decoration: none; }
    a:hover { text-decoration: underline; text-underline-offset: 3px; }

    #app { max-width: 1200px; margin: 0 auto; padding: 1.5rem; }

    header {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1.25rem;
    }

    .brand { display: inline-flex; align-items: center; gap: .55rem; }
    .logo-dot {
      width: .7rem; height: .7rem; border-radius: 999px;
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      box-shadow: 0 0 6px rgba(56, 189, 248, 0.7);
      flex-shrink: 0;
    }
    .brand-name {
      font-family: Arial, "Helvetica Neue", sans-serif;
      font-weight: 400;
      letter-spacing: 0.01em;
      font-size: 1.35rem;
      margin: 0;
    }
    .brand-name em { font-style: italic; }

    nav { display: flex; align-items: center; gap: .35rem; flex-wrap: wrap; }
    .nav-link {
      font-size: .8rem;
      color: var(--muted);
      padding: .35rem .65rem;
      border-radius: 999px;
      border: 1px solid transparent;
    }
    .nav-link:hover { color: var(--text-main); border-color: var(--border); text-decoration: none; }

    .nav-cta {
      padding: .35rem .85rem;
      border-radius: 999px;
      border: 1px solid #1fa766;
      background: var(--accent);
      color: #050810;
      font-size: .8rem;
      font-weight: 700;
      cursor: pointer;
      white-space: nowrap;
      text-decoration: none;
    }
    .nav-cta:hover { filter: brightness(1.05); text-decoration: none; }

    .theme-toggle-btn {
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #17181f;
      color: var(--text-main);
      font-size: 0.75rem;
      padding: 0.25rem 0.7rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }
    .theme-toggle-btn:hover { filter: brightness(1.07); }

    .card {
      background: var(--card-bg);
      border-radius: var(--radius);
      border: 1px solid var(--border);
      padding: 1rem;
      box-shadow: var(--shadow);
      position: relative;
      overflow: hidden;
    }

    .title-row {
      display: flex;
      flex-wrap: wrap;
      align-items: baseline;
      justify-content: space-between;
      gap: .75rem;
      margin-bottom: .75rem;
    }

    h1.page-title {
      font-size: 1.35rem;
      margin: 0;
      font-weight: 650;
      letter-spacing: -0.01em;
      display: flex;
      gap: .5rem;
      align-items: center;
    }

    .badge {
      font-size: .65rem;
      padding: .05rem .35rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
      white-space: nowrap;
    }

    .muted { color: var(--muted); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .money { font-variant-numeric: tabular-nums; }

    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.25rem 0.6rem;
      border-radius: 9999px;
      font-size: 0.75rem;
      border: 1px solid var(--border);
      background: #17181f;
      color: var(--text-main);
      white-space: nowrap;
    }
    .status-dot {
      width: 0.55rem;
      height: 0.55rem;
      border-radius: 999px;
      background: #fbbf24;
      box-shadow: 0 0 4px rgba(251, 191, 36, 0.6);
    }
    .status-dot.connected { background: var(--accent); box-shadow: 0 0 6px rgba(34, 197, 94, 0.7); }
    .status-dot.error { background: var(--danger); box-shadow: 0 0 6px rgba(248, 113, 113, 0.7); }

    .filters {
      display: grid;
      grid-template-columns: 1.4fr 1fr 1fr 1fr;
      gap: .6rem;
      margin: .75rem 0 1rem;
    }
    @media (max-width: 900px) { .filters { grid-template-columns: 1fr 1fr; } }
    @media (max-width: 560px) { .filters { grid-template-columns: 1fr; } }

    .filter {
      border-radius: 0.9rem;
      border: 1px solid var(--border);
      background: rgba(16, 16, 24, 0.35);
      padding: .65rem .75rem;
    }
    .filter label {
      display: block;
      font-size: .72rem;
      color: var(--muted);
      margin-bottom: .35rem;
    }
    .filter input[type="text"],
    .filter input[type="number"],
    .filter select {
      width: 100%;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #17181f;
      color: var(--text-main);
      font-size: .78rem;
      padding: .35rem .65rem;
      outline: none;
    }
    .filter input:focus,
    .filter select:focus {
      border-color: #97fde5;
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.4);
    }

    .check-row {
      display: flex;
      gap: .5rem;
      flex-wrap: wrap;
      align-items: center;
      margin-top: .35rem;
      color: var(--muted);
      font-size: .78rem;
    }
    .check-row input { transform: translateY(1px); }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
    }
    thead {
      background: #17181f;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    th, td {
      padding: 0.45rem 0.5rem;
      text-align: left;
      border-bottom: 1px solid var(--border);
      white-space: nowrap;
    }
    tbody tr:nth-child(even) { background: #14141c; }

    .pill {
      display: inline-flex;
      padding: 0.15rem 0.45rem;
      border-radius: 9999px;
      font-size: 0.7rem;
      border: 1px solid rgba(148, 163, 184, 0.4);
      color: var(--muted);
    }
    .pill-stable { color: #facc15; border-color: rgba(250, 204, 21, 0.55); background: rgba(250, 204, 21, 0.10); }
    .pill-cat { color: #38bdf8; border-color: rgba(56, 189, 248, 0.45); background: rgba(56, 189, 248, 0.08); }

    .chg-pos { color: #4ade80; }
    .chg-neg { color: #fb7185; }

    .btn-row {
      display: flex;
      gap: .5rem;
      flex-wrap: wrap;
      align-items: center;
    }
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: .45rem;
      padding: .45rem .85rem;
      border-radius: 999px;
      font-size: .8rem;
      border: 1px solid var(--border);
      background: #17181f;
      color: var(--text-main);
      cursor: pointer;
      text-decoration: none;
      user-select: none;
    }
    .btn:hover { filter: brightness(1.06); text-decoration: none; }
    .btn-primary {
      border: 1px solid #1fa766;
      background: var(--accent);
      color: #050810;
      font-weight: 800;
    }
    .btn-primary:hover { filter: brightness(1.05); }

    .error { margin-top: .5rem; font-size: .78rem; color: #fecaca; }
    .timestamp { font-size: .78rem; color: var(--muted); }

    /* Light theme */
    body.light { background: #ffffff; color: #0f172a; color-scheme: light; }
    body.light .theme-toggle-btn { background: #ffffff; color: #0f172a; border-color: #d1d5db; }
    body.light .card { background: #ffffff; border: 1px solid #e5e7eb; box-shadow: 0 16px 30px rgba(15, 23, 42, 0.06); }
    body.light .status-pill { background: #ffffff; border-color: #e5e7eb; color: #0f172a; }
    body.light thead { background: #f9fafb; }
    body.light th, body.light td { border-bottom: 1px solid #e5e7eb; }
    body.light tbody tr:nth-child(even) { background: #f9fafb; }
    body.light .filter { background: #f8fafc; border-color: #e5e7eb; }
    body.light .filter input, body.light .filter select { background: #ffffff; color: #0f172a; border-color: #d1d5db; }
    body.light .muted, body.light .timestamp { color: #64748b; }
    body.light .nav-link { color: #475569; }
  </style>
</head>

<body>
  <div id="app">

    <header>
      <a class="brand" href="/" aria-label="Hypermonitor home">
        <span class="logo-dot" aria-hidden="true"></span>
        <h1 class="brand-name">Hyper<em>monitor</em></h1>
      </a>

      <nav aria-label="Primary">
        <!-- TODO: adjust routes -->
        <a class="nav-link" href="/index.html">Home</a>
        <a class="nav-link" href="/tracker.html">Tracker</a>
        <a class="nav-link" href="/perps.html">Perps</a>
        <button id="themeToggle" class="theme-toggle-btn" type="button">‚òÄÔ∏è Light</button>
        <a class="nav-cta" href="/tracker.html">Open Tracker</a>
      </nav>
    </header>

    <section class="card">
      <div class="title-row">
        <div>
          <h1 class="page-title">
            Hyperliquid Perps ‚Äî Live Prices
            <span class="badge">sorted by market cap</span>
          </h1>
          <div class="muted" style="font-size:.84rem; line-height:1.45; max-width: 85ch;">
            Live mid prices come from Hyperliquid <span class="mono">/info</span>.
            Market cap + 24h stats are enriched via CoinGecko (symbol match).
            <!-- TODO: if you prefer CoinMarketCap, swap the "fetchCoinGeckoMarkets" function and add your API key server-side -->
          </div>
        </div>

        <div style="display:flex; gap:.5rem; align-items:center; flex-wrap:wrap;">
          <div class="status-pill" title="Data status">
            <span id="statusDot" class="status-dot"></span>
            <span id="statusText">Connecting‚Ä¶</span>
          </div>
          <div class="btn-row">
            <button id="refreshBtn" class="btn" type="button">‚Üª Refresh</button>
            <button id="autoBtn" class="btn btn-primary" type="button">‚è± Auto: ON</button>
          </div>
        </div>
      </div>

      <div class="filters" aria-label="Filters">
        <div class="filter">
          <label for="searchInput">Search (symbol)</label>
          <input id="searchInput" type="text" placeholder="e.g. ETH, SOL, DOGE‚Ä¶" autocomplete="off" />
          <div class="check-row">
            <label style="margin:0; display:flex; gap:.35rem; align-items:center;">
              <input id="onlyWithMcap" type="checkbox" />
              Only show rows with market cap
            </label>
          </div>
        </div>

        <div class="filter">
          <label for="categorySelect">Category</label>
          <select id="categorySelect">
            <option value="all">All</option>
            <!-- populated at runtime -->
          </select>
          <div class="check-row">
            <label style="margin:0; display:flex; gap:.35rem; align-items:center;">
              <input id="hideStable" type="checkbox" checked />
              Hide stablecoins
            </label>
          </div>
        </div>

        <div class="filter">
          <label for="minMcap">Min market cap (USD)</label>
          <input id="minMcap" type="number" min="0" step="1000000" placeholder="e.g. 1000000000" />
          <div class="check-row">
            <span class="muted">Tip: 1B = 1000000000</span>
          </div>
        </div>

        <div class="filter">
          <label for="sortSelect">Sort</label>
          <select id="sortSelect">
            <option value="mcap_desc" selected>Market cap ‚Üì</option>
            <option value="mcap_asc">Market cap ‚Üë</option>
            <option value="price_desc">Price ‚Üì</option>
            <option value="price_asc">Price ‚Üë</option>
            <option value="chg_desc">24h % ‚Üì</option>
            <option value="chg_asc">24h % ‚Üë</option>
            <option value="symbol_asc">Symbol A‚ÜíZ</option>
          </select>
          <div class="check-row">
            <span class="timestamp" id="lastUpdated">Last updated: ‚Äî</span>
          </div>
        </div>
      </div>

      <div style="max-height: 640px; overflow: auto; border-radius: .85rem; border: 1px solid var(--border);">
        <table>
          <thead>
            <tr>
              <th>#</th>
              <th>Symbol</th>
              <th>Category</th>
              <th class="money">Live price</th>
              <th class="money">Market cap</th>
              <th class="money">24h %</th>
              <th class="money">24h vol</th>
              <th></th>
            </tr>
          </thead>
          <tbody id="rowsBody">
            <tr><td colspan="8" class="muted">Loading‚Ä¶</td></tr>
          </tbody>
        </table>
      </div>

      <div class="error" id="errorBox"></div>

      <div class="muted" style="margin-top:.75rem; font-size:.78rem; line-height:1.45;">
        Notes:
        <ul style="margin:.35rem 0 0; padding-left: 1.15rem;">
          <li>
            CoinGecko matching is done by <strong>symbol</strong> and may be imperfect for ambiguous tickers.
            Use <span class="mono">SYMBOL_OVERRIDES</span> below to fix any mismatches.
          </li>
          <li>
            Categories are a lightweight heuristic + overrides. You can refine them later.
          </li>
        </ul>
      </div>
    </section>

  </div>

  <script>
    // =========================
    // THEME (matches your style)
    // =========================
    const themeToggleBtn = document.getElementById("themeToggle");
    function applyTheme(theme) {
      if (theme === "light") {
        document.body.classList.add("light");
        themeToggleBtn.textContent = "‚òÄÔ∏è Light";
      } else {
        document.body.classList.remove("light");
        themeToggleBtn.textContent = "üåô Dark";
      }
      try { localStorage.setItem("hypermonitor-theme", theme); } catch (e) {}
    }
    function initTheme() {
      let initial = "dark";
      try {
        const saved = localStorage.getItem("hypermonitor-theme");
        if (saved === "light" || saved === "dark") initial = saved;
      } catch (e) {}
      applyTheme(initial);
    }
    themeToggleBtn.addEventListener("click", () => {
      const isLight = document.body.classList.contains("light");
      applyTheme(isLight ? "dark" : "light");
    });
    initTheme();

    // =========================
    // CONFIG (EDIT THESE)
    // =========================

    // Hyperliquid info endpoint (official docs describe POST /info and types like "meta" and "allMids")
    // Docs: https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint
    const HL_INFO_URL = "https://api.hyperliquid.xyz/info";

    // CoinGecko "coins/markets" endpoint docs:
    // https://docs.coingecko.com/reference/coins-markets
    const CG_MARKETS_URL = "https://api.coingecko.com/api/v3/coins/markets";

    // How often to refresh live prices (ms)
    const AUTO_REFRESH_MS = 3000;

    // CoinGecko returns up to 250 per page; we fetch a couple pages to cover most perps.
    // TODO: increase pages if needed (watch rate limits).
    const CG_PAGES_TO_FETCH = 2;

    // If a Hyperliquid symbol doesn't match CoinGecko symbol reliably, override it here.
    // Format: { HL_SYMBOL: "coingecko_id" }
    // Example: { "WIF": "dogwifcoin" }
    const SYMBOL_OVERRIDES = {
      // TODO: add overrides when you notice mismatches
      // "TON": "the-open-network",
      // "ARB": "arbitrum",
    };

    // Stablecoin detection (heuristic). Add/remove as you want.
    const STABLECOIN_SYMBOLS = new Set([
      "USDT","USDC","DAI","TUSD","FDUSD","FRAX","USDE","USDP","LUSD","USDJ","USDD","SUSD","PYUSD",
      // some tickers sometimes appear as perps:
      "EURC","USDS"
    ]);

    // Lightweight category overrides (optional).
    // If not present, we infer category from CoinGecko data + heuristics.
    const CATEGORY_OVERRIDES = {
      // TODO: curate these over time
      // "BTC": "L1",
      // "ETH": "L1",
      // "SOL": "L1",
      // "ARB": "L2",
      // "OP": "L2",
      // "LINK": "Oracle",
      // "AAVE": "DeFi",
      // "UNI": "DeFi",
      // "PEPE": "Meme",
    };

    // =====================================
    // UI ELEMENTS
    // =====================================
    const statusDotEl = document.getElementById("statusDot");
    const statusTextEl = document.getElementById("statusText");
    const lastUpdatedEl = document.getElementById("lastUpdated");
    const errorBoxEl = document.getElementById("errorBox");
    const rowsBodyEl = document.getElementById("rowsBody");

    const searchInputEl = document.getElementById("searchInput");
    const categorySelectEl = document.getElementById("categorySelect");
    const minMcapEl = document.getElementById("minMcap");
    const sortSelectEl = document.getElementById("sortSelect");
    const hideStableEl = document.getElementById("hideStable");
    const onlyWithMcapEl = document.getElementById("onlyWithMcap");

    const refreshBtnEl = document.getElementById("refreshBtn");
    const autoBtnEl = document.getElementById("autoBtn");

    // =====================================
    // STATE
    // =====================================
    let autoOn = true;
    let timer = null;

    // Hyperliquid symbols for perps
    let hlPerpSymbols = [];

    // Live mid prices from Hyperliquid allMids
    const liveMids = new Map(); // symbol -> number

    // CoinGecko market map (by symbol + by id)
    // Each entry: { id, symbol, name, market_cap, current_price, total_volume, price_change_percentage_24h }
    const cgBySymbol = new Map(); // symbolUpper -> best match
    const cgById = new Map(); // id -> object

    // Computed table rows
    let rows = []; // array of { symbol, price, mcap, chg24, vol24, category, cgId, cgName, isStable }

    // =====================================
    // HELPERS
    // =====================================
    function setStatus(kind, text) {
      statusDotEl.classList.remove("connected", "error");
      if (kind === "connected") statusDotEl.classList.add("connected");
      if (kind === "error") statusDotEl.classList.add("error");
      statusTextEl.textContent = text || "";
    }

    function fmtMoney(n, decimals = 2) {
      const v = Number(n);
      if (!Number.isFinite(v)) return "‚Äî";
      return "$" + v.toLocaleString(undefined, { maximumFractionDigits: decimals, minimumFractionDigits: decimals });
    }

    function fmtCompactUSD(n) {
      const v = Number(n);
      if (!Number.isFinite(v)) return "‚Äî";
      // Compact for big numbers
      const abs = Math.abs(v);
      if (abs >= 1e12) return "$" + (v / 1e12).toFixed(2) + "T";
      if (abs >= 1e9)  return "$" + (v / 1e9).toFixed(2) + "B";
      if (abs >= 1e6)  return "$" + (v / 1e6).toFixed(2) + "M";
      if (abs >= 1e3)  return "$" + (v / 1e3).toFixed(2) + "K";
      return "$" + v.toFixed(0);
    }

    function fmtPrice(n) {
      const v = Number(n);
      if (!Number.isFinite(v)) return "‚Äî";
      // dynamic decimals
      const decimals = v >= 1000 ? 2 : v >= 1 ? 4 : 6;
      return v.toLocaleString(undefined, { maximumFractionDigits: decimals });
    }

    function fmtPct(n) {
      const v = Number(n);
      if (!Number.isFinite(v)) return "‚Äî";
      const sign = v > 0 ? "+" : "";
      return sign + v.toFixed(2) + "%";
    }

    function isStablecoin(symbol, cgObj) {
      const sym = (symbol || "").toUpperCase();
      if (STABLECOIN_SYMBOLS.has(sym)) return true;
      // heuristic: some stables contain USD in name/symbol
      const nm = (cgObj?.name || "").toLowerCase();
      if (sym.includes("USD")) return true;
      if (nm.includes("usd") && (nm.includes("stable") || nm.includes("dollar") || nm.includes("us dollar"))) return true;
      return false;
    }

    function inferCategory(symbol, cgObj) {
      const sym = (symbol || "").toUpperCase();
      if (CATEGORY_OVERRIDES[sym]) return CATEGORY_OVERRIDES[sym];

      if (isStablecoin(sym, cgObj)) return "Stablecoin";

      // very light heuristics (customize freely)
      const name = (cgObj?.name || "").toLowerCase();
      if (["btc","eth","sol","ada","avax","dot","near","atom","ton"].includes(sym.toLowerCase())) return "L1";
      if (["arb","op","strk","matic","poly"].includes(sym.toLowerCase())) return "L2";
      if (name.includes("inu") || ["pepe","wif","bonk","floki","doge","shib"].includes(sym.toLowerCase())) return "Meme";
      if (["uni","aave","crv","snx","comp","mkr","pendle","jto","jup","inj"].includes(sym.toLowerCase())) return "DeFi";
      if (["link","pyth","band"].includes(sym.toLowerCase())) return "Oracle";

      return "Other";
    }

    function rebuildCategoryDropdown(allRows) {
      const cats = new Set(["All"]);
      allRows.forEach(r => cats.add(r.category || "Other"));
      const sorted = Array.from(cats).filter(c => c !== "All").sort((a,b)=>a.localeCompare(b));
      categorySelectEl.innerHTML = `<option value="all">All</option>` + sorted.map(c => `<option value="${c}">${c}</option>`).join("");
    }

    // =====================================
    // DATA FETCHING
    // =====================================
    async function hlPost(body) {
      const res = await fetch(HL_INFO_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
      });
      if (!res.ok) throw new Error(`Hyperliquid /info error: ${res.status} ${res.statusText}`);
      return res.json();
    }

    async function loadHyperliquidPerpUniverse() {
      // "meta" includes the perp universe in docs and common SDKs
      // (Some wrappers nest in {data: ...} so we handle both)
      const raw = await hlPost({ type: "meta" });
      const meta = raw?.data ?? raw;

      // The "universe" array is commonly used; each entry has a "name" (symbol)
      const universe = meta?.universe ?? [];
      const symbols = Array.isArray(universe)
        ? universe.map(u => (u?.name || u?.coin || "")).filter(Boolean)
        : [];

      // Deduplicate, normalize
      hlPerpSymbols = Array.from(new Set(symbols.map(s => String(s).toUpperCase())));

      if (!hlPerpSymbols.length) {
        throw new Error("No perp symbols found from Hyperliquid meta. (Check API response format.)");
      }
    }

    async function refreshHyperliquidMids() {
      const raw = await hlPost({ type: "allMids" });
      const payload = raw?.data ?? raw;

      // allMids often returns an object map { "BTC": "104000", ... }
      const mids = payload?.mids ?? payload;
      if (!mids || typeof mids !== "object") {
        throw new Error("Unexpected allMids payload format.");
      }

      for (const [k, v] of Object.entries(mids)) {
        const px = Number(v);
        if (Number.isFinite(px)) liveMids.set(String(k).toUpperCase(), px);
      }
    }

    async function fetchCoinGeckoMarketsPage(page) {
      // docs: /coins/markets (vs_currency=usd)
      // https://docs.coingecko.com/reference/coins-markets
      const url = new URL(CG_MARKETS_URL);
      url.searchParams.set("vs_currency", "usd");
      url.searchParams.set("order", "market_cap_desc");
      url.searchParams.set("per_page", "250");
      url.searchParams.set("page", String(page));
      url.searchParams.set("sparkline", "false");
      url.searchParams.set("price_change_percentage", "24h");

      const res = await fetch(url.toString(), { method: "GET" });
      if (!res.ok) throw new Error(`CoinGecko markets error: ${res.status} ${res.statusText}`);
      return res.json();
    }

    async function loadCoinGeckoMarkets() {
      cgBySymbol.clear();
      cgById.clear();

      // Fetch a couple pages of top market-cap coins
      const pages = [];
      for (let p = 1; p <= CG_PAGES_TO_FETCH; p++) pages.push(p);

      const results = await Promise.all(pages.map(fetchCoinGeckoMarketsPage));
      const all = results.flat().filter(x => x && typeof x === "object");

      // Build maps. If duplicate symbols exist, keep the larger market cap.
      for (const item of all) {
        const sym = String(item.symbol || "").toUpperCase();
        const id = item.id;
        if (!sym || !id) continue;

        cgById.set(id, item);

        const existing = cgBySymbol.get(sym);
        const mcap = Number(item.market_cap ?? 0);
        const emcap = Number(existing?.market_cap ?? 0);
        if (!existing || (Number.isFinite(mcap) && mcap > emcap)) {
          cgBySymbol.set(sym, item);
        }
      }
    }

    function getCoinGeckoForSymbol(hlSymbol) {
      const sym = String(hlSymbol || "").toUpperCase();
      const overrideId = SYMBOL_OVERRIDES[sym];
      if (overrideId && cgById.has(overrideId)) return cgById.get(overrideId);
      return cgBySymbol.get(sym);
    }

    // =====================================
    // BUILD + RENDER
    // =====================================
    function buildRows() {
      rows = hlPerpSymbols.map(sym => {
        const price = liveMids.get(sym);
        const cg = getCoinGeckoForSymbol(sym);

        const mcap = cg ? Number(cg.market_cap) : undefined;
        const vol = cg ? Number(cg.total_volume) : undefined;
        const chg = cg ? Number(cg.price_change_percentage_24h) : undefined;

        const category = inferCategory(sym, cg);
        const stable = isStablecoin(sym, cg);

        return {
          symbol: sym,
          price,
          mcap,
          vol,
          chg24: chg,
          category,
          isStable: stable,
          cgId: cg?.id,
          cgName: cg?.name
        };
      });

      rebuildCategoryDropdown(rows);
    }

    function applyFiltersAndSort() {
      const q = (searchInputEl.value || "").trim().toUpperCase();
      const cat = categorySelectEl.value || "all";
      const minMcap = Number(minMcapEl.value || 0);
      const hideStable = !!hideStableEl.checked;
      const onlyWithMcap = !!onlyWithMcapEl.checked;

      let out = rows.slice();

      if (q) out = out.filter(r => r.symbol.includes(q));

      if (cat !== "all") out = out.filter(r => (r.category || "Other") === cat);

      if (hideStable) out = out.filter(r => !r.isStable);

      if (Number.isFinite(minMcap) && minMcap > 0) {
        out = out.filter(r => Number(r.mcap) >= minMcap);
      }

      if (onlyWithMcap) out = out.filter(r => Number.isFinite(r.mcap));

      const sortKey = sortSelectEl.value;
      const num = (v) => (Number.isFinite(v) ? v : -Infinity);
      const numAsc = (a,b) => a - b;

      out.sort((a, b) => {
        switch (sortKey) {
          case "mcap_asc":  return numAsc(num(a.mcap), num(b.mcap));
          case "mcap_desc": return numAsc(num(b.mcap), num(a.mcap));
          case "price_asc": return numAsc(num(a.price), num(b.price));
          case "price_desc":return numAsc(num(b.price), num(a.price));
          case "chg_asc":   return numAsc(num(a.chg24), num(b.chg24));
          case "chg_desc":  return numAsc(num(b.chg24), num(a.chg24));
          case "symbol_asc":return a.symbol.localeCompare(b.symbol);
          default:          return numAsc(num(b.mcap), num(a.mcap));
        }
      });

      return out;
    }

    function render() {
      const filtered = applyFiltersAndSort();

      if (!filtered.length) {
        rowsBodyEl.innerHTML = `<tr><td colspan="8" class="muted">No rows match your filters.</td></tr>`;
        return;
      }

      rowsBodyEl.innerHTML = filtered.map((r, i) => {
        const chgClass = Number.isFinite(r.chg24) ? (r.chg24 >= 0 ? "chg-pos" : "chg-neg") : "";
        const catPill = r.isStable
          ? `<span class="pill pill-stable">Stablecoin</span>`
          : `<span class="pill pill-cat">${(r.category || "Other")}</span>`;

        const trackerLink = `/tracker.html?wallet=`; // TODO: optional ‚Äî you might link to symbol page instead
        // Better: link to HL market page or your own symbol page:
        const marketLink = r.cgId
          ? `https://www.coingecko.com/en/coins/${encodeURIComponent(r.cgId)}`
          : null;

        const nameHint = r.cgName ? `title="${r.cgName}"` : "";

        return `
          <tr>
            <td>${i + 1}</td>
            <td class="mono" ${nameHint}>${r.symbol}</td>
            <td>${catPill}</td>
            <td class="money">${Number.isFinite(r.price) ? fmtPrice(r.price) : "‚Äî"}</td>
            <td class="money">${Number.isFinite(r.mcap) ? fmtCompactUSD(r.mcap) : "‚Äî"}</td>
            <td class="money ${chgClass}">${Number.isFinite(r.chg24) ? fmtPct(r.chg24) : "‚Äî"}</td>
            <td class="money">${Number.isFinite(r.vol) ? fmtCompactUSD(r.vol) : "‚Äî"}</td>
            <td>
              ${marketLink
                ? `<a class="btn" style="padding:.25rem .6rem; font-size:.75rem;" href="${marketLink}" target="_blank" rel="noopener noreferrer">Details</a>`
                : `<span class="muted" style="font-size:.75rem;">‚Äî</span>`
              }
            </td>
          </tr>
        `;
      }).join("");
    }

    function setLastUpdated() {
      lastUpdatedEl.textContent = "Last updated: " + new Date().toLocaleString();
    }

    // =====================================
    // REFRESH LOOP
    // =====================================
    async function fullLoad() {
      errorBoxEl.textContent = "";
      setStatus("", "Connecting‚Ä¶");

      try {
        // 1) load universe once
        await loadHyperliquidPerpUniverse();

        // 2) load markets (market cap) ‚Äî less frequent but for template we load at start
        await loadCoinGeckoMarkets();

        // 3) initial mids and build
        await refreshHyperliquidMids();

        buildRows();
        render();
        setLastUpdated();
        setStatus("connected", "Live");
      } catch (err) {
        console.error(err);
        setStatus("error", "Error");
        errorBoxEl.textContent = (err?.message || String(err));
      }
    }

    async function refreshOnlyMids() {
      errorBoxEl.textContent = "";
      try {
        await refreshHyperliquidMids();
        // update prices in rows
        rows.forEach(r => { r.price = liveMids.get(r.symbol); });
        render();
        setLastUpdated();
        setStatus("connected", "Live");
      } catch (err) {
        console.error(err);
        setStatus("error", "Error");
        errorBoxEl.textContent = (err?.message || String(err));
      }
    }

    function startAuto() {
      stopAuto();
      timer = setInterval(() => {
        if (!autoOn) return;
        refreshOnlyMids();
      }, AUTO_REFRESH_MS);
    }

    function stopAuto() {
      if (timer) clearInterval(timer);
      timer = null;
    }

    function setAutoUI() {
      autoBtnEl.textContent = autoOn ? "‚è± Auto: ON" : "‚è± Auto: OFF";
      autoBtnEl.classList.toggle("btn-primary", autoOn);
    }

    // =====================================
    // EVENTS
    // =====================================
    [searchInputEl, categorySelectEl, minMcapEl, sortSelectEl, hideStableEl, onlyWithMcapEl].forEach(el => {
      el.addEventListener("input", () => render());
      el.addEventListener("change", () => render());
    });

    refreshBtnEl.addEventListener("click", async () => {
      // full refresh includes Coingecko; use when you want latest market caps
      await fullLoad();
    });

    autoBtnEl.addEventListener("click", () => {
      autoOn = !autoOn;
      setAutoUI();
      if (autoOn) startAuto();
      else stopAuto();
    });

    // =====================================
    // BOOT
    // =====================================
    (async function boot() {
      setAutoUI();
      await fullLoad();
      startAuto();
    })();
  </script>
</body>
</html>
