<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hypermonitor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Hyperliquid wallet tracker" />

  <meta property="og:title" content="Hyperliquid wallet tracker" />
  <meta property="og:description" content="Track any Hyperliquid wallet: positions, orders, fills, and performance." />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Hypermonitor" />

  <meta property="og:image" content="https://www.hypermonitor.org/images/track.png" />
  <meta property="og:image:secure_url" content="https://www.hypermonitor.org/images/track.png" />
  <meta property="og:image:type" content="image/png" />
  <meta property="og:image:width" content="1512" />
  <meta property="og:image:height" content="824" />

  <meta property="og:url" content="https://www.hypermonitor.org/" />
  <link rel="canonical" href="https://www.hypermonitor.org/" />

  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Hyperliquid wallet tracker" />
  <meta name="twitter:description" content="Track any Hyperliquid wallet: positions, orders, fills, and performance." />
  <meta name="twitter:image" content="https://www.hypermonitor.org/images/track.png" />

  <link rel="icon" type="image/png" href="images/logo.png" />

  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color-scheme: dark;
      --bg: #101014;
      --card-bg: #101014cf;
      --accent: #26d97f;
      --accent-soft: rgba(38, 217, 127, 0.18);
      --danger: #f25f5c;
      --border: rgba(255,255,255,0.08);
      --muted: rgba(245,245,255,0.62);
      --text-main: #f5f5ff;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--text-main);
    }

    #app {
      max-width: 1200px;
      margin: 0 auto;
      padding: 1.5rem;
    }

    header {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      gap: 1rem;
      align-items: center;
      margin-bottom: 1.5rem;
    }

    header h1 {
      font-size: 1.8rem;
      margin: 0 0 .4rem;
      display: flex;
      align-items: center;
      gap: .55rem;
      font-family: Arial, "Helvetica Neue", sans-serif;
      font-weight: 400;
      letter-spacing: 0.01em;
    }

    header h1 span.logo-dot {
      width: .7rem;
      height: .7rem;
      border-radius: 999px;
      background: linear-gradient(135deg, #26d97f, #38bdf8);
      box-shadow: 0 0 6px rgba(56, 189, 248, 0.7);
      flex-shrink: 0;
    }

    header h1 .logo-word { display: inline-block; }
    header h1 .logo-word-regular { text-decoration: none ; }
    header h1 .logo-word-italic { font-style: italic; }

    .brand {
      display: inline-flex;
      align-items: center;
      gap: .55rem;
    }

    a.brand,
    a.brand:visited,
    a.brand:hover,
    a.brand:active {
      text-decoration: none !important;
      color: inherit;
    }

    .brand-name {
      font-family: Arial, "Helvetica Neue", sans-serif;
      font-weight: 400;
      letter-spacing: 0.01em;
      font-size: 1.35rem;
      margin: 0;
    }

    .wallet-controls {
      display: flex;
      flex-direction: column;
      gap: .35rem;
      max-width: 680px;
      width: 100%;
    }

    .wallet-line {
      font-size: .85rem;
      color: var(--muted);
      word-break: break-all;
      display: none;
    }

    /* Match main.html link styling (inline, underline on hover) */
    a {
      color: var(--muted);
      text-decoration: none;
      padding: 0;
      border: none;
      background: none;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }

    a:hover { color: inherit; text-decoration: underline; }
    body.light a { color: #475569; }
    body.light a:hover { color: inherit; text-decoration: underline; }

    .wallet-input-row {
      display: flex;
      align-items: center;
      gap: .4rem;
      width: 100%;
      flex-wrap: wrap;
    }

    .wallet-input-row label {
      font-size: .8rem;
      color: var(--muted);
      white-space: nowrap;
    }

    .wallet-input-row input {
      flex: 1 1 340px;
      padding: 0.35rem 0.6rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #17181f;
      color: var(--text-main);
      font-size: 0.8rem;
      outline: none;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .wallet-input-row input:focus {
      border-color: #f59e0b;
      box-shadow: 0 0 0 1px rgba(245, 158, 11, 0.35);
    }

    .wallet-input-row button {
      padding: 0.35rem 0.9rem;
      border-radius: 999px;
      border: 1px solid #f59e0b;
      background: #f59e0b;
      color: #0b1020;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      white-space: nowrap;
      flex: 0 0 auto;
    }

    .wallet-input-row button:hover:not(:disabled) { filter: brightness(1.05); }
    .wallet-input-row button:disabled { opacity: 0.5; cursor: default; }

    @media (max-width: 600px) {
      .wallet-input-row { flex-direction: column; align-items: stretch; }
      .wallet-input-row input { flex: 1 1 auto; width: 100%; }
      .wallet-input-row button { width: 100%; }
      .header-right { width: 100%; align-items: flex-end; }
      .header-right-top { width: 100%; justify-content: flex-end; }
    }

    @media (max-width: 600px) {
      #app { padding: 0.9rem; }
      header { margin-bottom: 1rem; }
      .card { padding: 0.85rem; border-radius: 12px; }
      .grid { gap: 0.75rem; margin-bottom: 1rem; }
    }

    @media (max-width: 600px) {
      .theme-toggle-btn,
      .orders-tab-btn,
      .chart-range-btn {
        padding: 0.45rem 0.9rem;
        font-size: 0.85rem;
      }
    }

    @media (max-width: 600px) {
      .chart-grid { grid-template-columns: 1fr; }
      .chart-card { min-height: 200px; }
    }

    @media (max-width: 600px) {
      table { font-size: 0.78rem; }
      th, td { padding: 0.3rem 0.35rem; }
      .timestamp { font-size: 0.72rem; }
    }

    div[style*="overflow: auto"] {
      -webkit-overflow-scrolling: touch;
    }

    @media (max-width: 600px) {
      .header-right { align-items: stretch; }
      .header-right-top { justify-content: space-between; }
      .status-pill { flex: 1; justify-content: center; }
    }

    @media (max-width: 600px) {
      .wallet-input-row label { display: none; }
    }

    /* ===== Mobile table compaction ===== */
    @media (max-width: 600px) {
      /* make all tables denser and more predictable */
      table {
        table-layout: fixed;      /* important: obey widths */
        width: 100%;
        font-size: 0.72rem;       /* smaller than your 0.78 */
      }

      th, td {
        padding: 0.22rem 0.28rem; /* tighter */
        overflow: hidden;         /* prevent stretching */
        text-overflow: ellipsis;  /* show … */
        white-space: nowrap;
      }

      /* slightly smaller pills in cells */
      .pill { font-size: 0.62rem; padding: 0.1rem 0.35rem; }

      /* if you want even denser timestamps */
      .timestamp { font-size: 0.68rem; }

      /* --- Positions table: hide less critical columns --- */
      /* columns: Asset(1) Size(2) Direction(3) Entry(4) Value(5) uPnL(6) */
      .grid section.card table th:nth-child(4),
      .grid section.card table td:nth-child(4),
      .grid section.card table th:nth-child(5),
      .grid section.card table td:nth-child(5) {
        display: none; /* hide Entry Price + Value on phones */
      }

      /* --- Orders / Fills tables: hide time + total (usually widest) --- */
      /* Open Orders: OrderID(1) Time(2) Side(3) Asset(4) Size(5) Limit(6) Total(7) */
      #openOrdersBody td:nth-child(1),
      #openOrdersBody td:nth-child(2),
      #openOrdersBody td:nth-child(7),
      #openOrdersBody th:nth-child(7) {
        display: none;
      }

      /* Trades Stream: OrderID(1) Time(2) Side(3) Asset(4) Size(5) Price(6) Total(7) */
      #fillsBody td:nth-child(1),
      #fillsBody td:nth-child(2),
      #fillsBody td:nth-child(7),
      #fillsBody th:nth-child(1),
      #fillsBody th:nth-child(2),
      #fillsBody th:nth-child(7) {
        display: none;
      }

      /* Historical Orders: OrderID(1) Date/Time(2) Side(3) Asset(4) Size(5) Limit(6) Status(7) */
      #historicalOrdersBody td:nth-child(2),
      #historicalOrdersBody th:nth-child(2) {
        display: none;
      }

      /* Canceled Orders: OrderID(1) Created(2) Canceled(3) Side(4) Asset(5) Size(6) */
      #canceledOrdersBody th:nth-child(1),
      #canceledOrdersBody td:nth-child(1),
      #canceledOrdersBody td:nth-child(2),
      #canceledOrdersBody th:nth-child(2),
      #canceledOrdersBody td:nth-child(3),
      #canceledOrdersBody th:nth-child(3) {
        display: none;
      }
    }


    .header-right {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 0.25rem;
    }

    .header-right-top {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .export-btn {
      border: 1px solid #334155;
      background: #0f172a;
      padding: 0.2rem 0.35rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: #cbd5f5;
      transition: opacity 120ms ease, transform 120ms ease, border-color 120ms ease;
    }

    .export-btn:hover {
      opacity: 0.95;
      transform: translateY(-1px);
      border-color: #475569;
    }

    .export-icon {
      width: 16px;
      height: 16px;
      display: inline-block;
    }

    body.light .export-btn {
      background: #ffffff;
      border-color: #e5e7eb;
      color: #475569;
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      border: 0;
    }

    .theme-toggle-btn {
      border-radius: 999px;
      border: 1px solid #334155;
      background: #0f172a;
      color: #cbd5f5;
      font-size: 0.75rem;
      padding: 0.25rem 0.7rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      transition: border-color 0.15s ease, transform 0.15s ease;
    }

    .theme-toggle-btn:hover { border-color: #475569; transform: translateY(-1px); }

    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.25rem 0.6rem;
      border-radius: 9999px;
      font-size: 0.75rem;
      border: 1px solid var(--border);
      background: #17181f;
      color: var(--text-main);
    }

    .status-dot {
      width: 0.55rem;
      height: 0.55rem;
      border-radius: 999px;
      background: #fbbf24;
      box-shadow: 0 0 4px rgba(251, 191, 36, 0.6);
    }

    .status-dot.connected {
      background: var(--accent);
      box-shadow: 0 0 6px rgba(34, 197, 94, 0.7);
    }

    .status-dot.error {
      background: var(--danger);
      box-shadow: 0 0 6px rgba(248, 113, 113, 0.7);
    }

    .status-spinner {
      width: 18px;
      height: 18px;
      border-radius: 999px;
      object-fit: contain;
      display: none;
      margin-left: 0.15rem;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .card {
      background: var(--card-bg);
      border: 0.1px solid var(--border);
      border-radius: 10px;
      padding: 1rem;
      position: relative;
      overflow: hidden;
    }

    .card::before {
      content: "";
      position: absolute;
      inset: 0;
      opacity: 0;
      pointer-events: none;
    }

    .card h2 {
      margin: 0 0 0.75rem;
      font-size: 1rem;
      display: flex;
      align-items: center;
      gap: .4rem;
    }

    .card h2 span.badge {
      font-size: .65rem;
      padding: 0.05rem 0.35rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
    }

    .positions-card {
      grid-column: span 2;
      min-width: 640px;
    }

    @media (max-width: 900px) {
      .positions-card {
        grid-column: span 1;
        min-width: 100%;
      }
    }

    /* Stack snapshot + positions for mobile and landscape tablets */
    @media (max-width: 900px), (max-width: 1100px) and (orientation: landscape) {
      .grid {
        grid-template-columns: 1fr;
      }
      .positions-card {
        grid-column: span 1;
        min-width: 100%;
      }
    }

    .kv-list {
      font-size: 0.85rem;
      display: grid;
      grid-template-columns: 1.1fr 1.3fr;
      gap: .25rem .5rem;
    }

    .kv-label { color: var(--muted); }
    .kv-value { text-align: right; }

    .asset-cell {
      display: flex;
      align-items: center;
      gap: 0.3rem;
      white-space: nowrap;
      line-height: 1.1;
      height: 100%;
    }

    .coinIcon {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      object-fit: cover;
      background: var(--border);
      flex-shrink: 0;
      display: block;
    }

    .coinFallback {
      width: 16px;
      height: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      background: var(--border);
      color: var(--muted);
      font-size: 0.65rem;
      font-weight: 700;
      flex-shrink: 0;
    }

    .price-stack {
      display: inline-flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0.15rem;
      line-height: 1.2;
    }

    .price-stack .current-price {
      color: var(--muted);
      font-size: 0.72rem;
    }

    .position-row { cursor: pointer; }
    .position-row:hover { background: rgba(56, 189, 248, 0.05); }
    .position-row.loading { opacity: 0.6; cursor: progress; }

    .chevron {
      display: inline-block;
      width: 0.6rem;
      height: 0.6rem;
      border-right: 1.6px solid var(--muted);
      border-bottom: 1.6px solid var(--muted);
      transform: rotate(45deg);
      transition: transform 120ms ease, border-color 120ms ease;
    }

    .position-row.expanded .chevron {
      transform: rotate(-135deg);
      border-color: #18bf98;
    }

    .upnl-pos { color: #4ade80; }
    .upnl-neg { color: #fb7185; }

    .position-breakdown {
      margin-top: 0.25rem;
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.4rem 0.5rem;
    }

    .position-subtable {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.75rem;
    }

    .position-subtable th,
    .position-subtable td {
      padding: 0.2rem 0.25rem;
      border-bottom: 1px solid var(--border);
      text-align: left;
    }

    .position-subtable th {
      color: var(--muted);
      font-weight: 600;
    }

    .position-subtable tr:last-child td {
      border-bottom: none;
    }

    .position-subtable .money {
      text-align: right;
      font-variant-numeric: tabular-nums;
    }

    .position-breakdown-note {
      margin-top: 0.25rem;
      font-size: 0.72rem;
      color: var(--muted);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
    }

    thead {
      background: #17181f;
      position: sticky;
      top: 0;
      z-index: 1;
    }

    th, td {
      padding: 0.35rem 0.45rem;
      text-align: left;
      border-bottom: 1px solid var(--border);
      white-space: nowrap;
    }

    tbody tr:nth-child(even) { background: #14141c; }

    .pill {
      display: inline-flex;
      padding: 0.15rem 0.45rem;
      border-radius: 9999px;
      font-size: 0.7rem;
      border: 1px solid rgba(148, 163, 184, 0.4);
      font-weight: 600;
    }

    .dex-tag {
      display: inline-flex;
      align-items: center;
      padding: 0.05rem 0.35rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
      font-size: 0.65rem;
      background: rgba(255, 255, 255, 0.03);
    }

    .spot-tag {
      color: #38bdf8;
      border-color: rgba(56, 189, 248, 0.6);
      background: rgba(56, 189, 248, 0.12);
    }

    .pill-buy {
      color: #4ade80;
      border-color: rgba(22, 163, 74, 0.8);
      background: rgba(22, 163, 74, 0.18);
      box-shadow: 0 0 0 1px rgba(22, 163, 74, 0.2);
    }

    .pill-sell {
      color: #f97373;
      border-color: rgba(248, 113, 113, 0.6);
      background: rgba(220, 38, 38, 0.18);
      box-shadow: 0 0 0 1px rgba(220, 38, 38, 0.2);
    }

    .pill-new {
      color: #facc15;
      border-color: rgba(250, 204, 21, 0.6);
      background: rgba(250, 204, 21, 0.12);
    }

    .pill-cancel {
      color: #f472b6;
      border-color: rgba(236, 72, 153, 0.6);
      background: rgba(190, 24, 93, 0.12);
    }

    .pill-fill {
      color: #22c55e;
      border-color: rgba(22, 163, 74, 0.6);
      background: rgba(21, 128, 61, 0.16);
    }

    .muted { color: var(--muted); }
    .money { font-variant-numeric: tabular-nums; }

    .layout-two {
      display: grid;
      grid-template-columns: minmax(0, 1.05fr) minmax(0, 0.95fr);
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    @media (max-width: 900px) {
      .layout-two { grid-template-columns: 1fr; }
    }

    .section-title {
      font-size: 0.95rem;
      margin: 0 0 0.5rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: .5rem;
    }

    .section-title small {
      font-size: 0.75rem;
      color: var(--muted);
    }

    .section-actions {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    .tagline { font-size: 0.8rem; color: var(--muted); margin-bottom: 0.5rem; }
    .error { margin-top: .5rem; font-size: .75rem; color: #fecaca; }
    .timestamp { font-size: 0.75rem; color: var(--muted); }

    tbody tr.flash { animation: flashRow 1s ease-out; }
    @keyframes flashRow {
      from { background: rgba(34, 197, 94, 0.22); }
      to { background: #14141c; }
    }

    tbody tr.flash-cancel { animation: flashCancel 1s ease-out; }
    @keyframes flashCancel {
      from { background: rgba(244, 114, 182, 0.22); }
      to { background: #14141c; }
    }

    p { margin: 1.5rem 0; }

    .chart-toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      margin-bottom: 0.5rem;
      font-size: 0.8rem;
    }

    .chart-range-btn {
      border-radius: 999px;
      border: 1px solid #334155;
      background: #0f172a;
      color: #cbd5f5;
      padding: 0.2rem 0.85rem;
      cursor: pointer;
      transition: background 0.15s ease, border-color 0.15s ease, color 0.15s ease, box-shadow 0.15s ease;
    }

    .chart-range-btn:hover { border-color: #475569; }

    .chart-range-btn.active {
      border-color: #f59e0b;
      color: #f59e0b;
      background: rgba(245, 158, 11, 0.1);
    }

    .chart-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 0.75rem;
      margin-top: 0.5rem;
    }

    .chart-card {
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      padding: 0.6rem 0.75rem 0.75rem;
      position: relative;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 220px;
    }

    .chart-card h3 {
      margin: 0 0 0.25rem;
      font-size: 0.85rem;
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .chart-card h3 span.spark-label {
      font-size: 0.7rem;
      color: var(--muted);
      font-weight: 400;
    }

    .chart-canvas-wrap {
      position: relative;
      flex: 1 1 auto;
      min-height: 170px;
    }

    .chart-canvas-wrap canvas {
      width: 100% !important;
      height: 100% !important;
    }

    .chart-loading { font-size: 0.8rem; color: var(--muted); margin-top: 0.3rem; }

    body.light {
      background: #ffffff;
      color: #0f172a;
      color-scheme: light;
    }

    body.light #app { color: #0f172a; }

    body.light .theme-toggle-btn {
      background: #ffffff;
      color: #0f172a;
      border-color: #d1d5db;
    }

    body.light .wallet-input-row input {
      background: #ffffff;
      color: #0f172a;
      border-color: #d1d5db;
    }

    body.light .wallet-input-row input:focus {
      border-color: #38bdf8;
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.4);
    }

    body.light .status-pill {
      background: #ffffff;
      border-color: #e5e7eb;
      color: #0f172a;
    }

    body.light .status-dot { box-shadow: 0 0 4px rgba(251, 191, 36, 0.6); }

    body.light .card {
      background: #ffffff;
      border: 1px solid #e5e7eb;
    }

    body.light .card h2 span.badge {
      border-color: #e5e7eb;
      color: #6b7280;
    }

    body.light .kv-label { color: #6b7280; }
    body.light .muted { color: #6b7280; }

    body.light table { color: #0f172a; }
    body.light thead { background: #f9fafb; }

    body.light th, body.light td { border-bottom: 1px solid #e5e7eb; }
    body.light tbody tr:nth-child(even) { background: #f9fafb; }
    body.light .timestamp { color: #6b7280; }

    body.light .chart-range-btn {
      background: #ffffff;
      color: #6b7280;
      border-color: #e5e7eb;
    }

    body.light .chart-range-btn:hover { border-color: #d1d5db; }

    body.light .chart-range-btn.active {
      border-color: #f59e0b;
      color: #b45309;
      background: #fff7ed;
    }

    body.light .chart-card {
      background: #ffffff;
      border: 1px solid #e5e7eb;
    }

    body.light .chart-loading { color: #6b7280; }

    .linkedin-badge {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      margin-left: 4px;
      border-radius: 4px;
      text-decoration: none;
      vertical-align: middle;
      transition: background 0.15s ease, border-color 0.15s ease, opacity 0.15s ease;
    }

    .linkedin-badge svg {
      width: 11px;
      height: 11px;
      transition: fill 0.15s ease;
    }

    body:not(.light) .linkedin-badge {
      background: rgba(10, 102, 194, 0.12);
      border: 1px solid rgba(10, 102, 194, 0.35);
    }

    body:not(.light) .linkedin-badge svg { fill: #3396ff; }

    body:not(.light) .linkedin-badge:hover {
      background: rgba(10, 102, 194, 0.20);
      border-color: #3396ff;
    }

    body.light .linkedin-badge {
      background: rgba(10, 102, 194, 0.10);
      border: 1px solid rgba(10, 102, 194, 0.30);
    }

    body.light .linkedin-badge svg { fill: #0a66c2; }

    body.light .linkedin-badge:hover {
      background: rgba(10, 102, 194, 0.18);
      border-color: #0a66c2;
    }

    .linkedin-badge::after {
      content: attr(data-tip);
      position: absolute;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      padding: 3px 6px;
      border-radius: 4px;
      font-size: 0.65rem;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s ease;
      background: #1e293b;
      color: #e2e8f0;
      border: 1px solid #334155;
    }

    body.light .linkedin-badge::after {
      background: #f1f5f9;
      color: #0f172a;
      border: 1px solid #cbd5e1;
    }

    .linkedin-badge:hover::after { opacity: 1; }

    footer {
      margin-top: 0.2rem;
      padding: 0.2rem 0 0;
      border-top: 1px #262637;
      color: #a1a1b5;
      font-size: .78rem;
      line-height: 1.45;
    }

    .status-logo {
      display: inline-flex;
      align-items: center;
      margin-left: 0.25rem;
    }

    .status-logo.hidden { display: none; }
    .status-logo svg { height: 12px; width: auto; }

    body:not(.light) .status-logo { color: #97fde5; }
    body.light .status-logo { color: #072722; }

    .status-logo-link {
      display: inline-flex;
      align-items: center;
      text-decoration: none;
      color: inherit;
      cursor: pointer;
    }

    .orders-tabs {
      display: flex;
      gap: 0.4rem;
      margin: 0.25rem 0 0.75rem;
      font-size: 0.8rem;
    }

    .orders-tab-btn {
      padding: 0.2rem 0.8rem;
      border-radius: 999px;
      border: 1px solid #334155;
      background: #0f172a;
      color: #cbd5f5;
      cursor: pointer;
      white-space: nowrap;
      font-size: 0.75rem;
      transition: background 0.15s ease, border-color 0.15s ease, color 0.15s ease, box-shadow 0.15s ease;
    }

    .orders-tab-btn:hover { border-color: #475569; }

    .orders-tab-btn.active {
      border-color: #f59e0b;
      color: #f59e0b;
      background: rgba(245, 158, 11, 0.1);
    }

    body.light .orders-tab-btn {
      background: #ffffff;
      border-color: #e5e7eb;
      color: #475569;
    }

    body.light .orders-tab-btn:hover { border-color: #d1d5db; }

    body.light .orders-tab-btn.active {
      border-color: #f59e0b;
      color: #b45309;
      background: #fff7ed;
    }

    .tab-panel.hidden { display: none; }

    .orders-filter-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      margin: 0.25rem 0 0.75rem;
      font-size: 0.8rem;
    }

    .orders-filter-group {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .orders-filter-label {
      color: var(--muted);
      font-size: 0.75rem;
      white-space: nowrap;
    }

    .orders-filter-input,
    .orders-filter-select {
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #17181f;
      color: var(--text-main);
      font-size: 0.75rem;
      padding: 0.2rem 0.6rem;
      min-width: 80px;
      max-width: 140px;
      outline: none;
    }

    .orders-filter-input::placeholder {
      color: var(--muted);
      opacity: 0.7;
    }

    body.light .orders-filter-input,
    body.light .orders-filter-select {
      background: #ffffff;
      border-color: #e5e7eb;
      color: #0f172a;
    }
    body.light .tagline { color: #0f172a; }
    body.light .wallet-input-row label { color: #0f172a; }

    body.light footer { border-top-color: #e5e7eb; }

    .placeholder-row td {
      border-bottom: 1px solid var(--border);
      color: transparent; /* hides &nbsp; */
    }

    .desktop-only { display: revert; }
    .mobile-only { display: none; }
    @media (max-width: 600px) {
      .desktop-only { display: none !important; }
      .mobile-only { display: revert !important; }
    }

    .pill-action-btn {
      border-radius: 999px;
      border: 1px solid #334155;
      background: #0f172a;
      color: #cbd5f5;
      padding: 0.25rem 0.9rem;
      font-size: 0.78rem;
      cursor: pointer;
      white-space: nowrap;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    .pill-action-btn:hover { border-color: #475569; }

    body.light .pill-action-btn {
      background: #ffffff;
      color: #475569;
      border-color: #e5e7eb;
    }

    body.light .pill-action-btn:hover { border-color: #d1d5db; }

    .portfolio-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.55);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      z-index: 999;
    }

    .portfolio-modal.open { display: flex; }

    .portfolio-modal .modal-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 14px;
      width: min(460px, 100%);
      padding: 1rem;
      box-shadow: 0 12px 36px rgba(0, 0, 0, 0.35);
      backdrop-filter: blur(8px);
    }

    body.light .portfolio-modal .modal-card {
      background: rgba(255, 255, 255, 0.9);
      border-color: #e5e7eb;
      color: #0f172a;
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .modal-header h3 {
      margin: 0;
      font-size: 1rem;
    }

    .modal-close-btn {
      border: none;
      background: transparent;
      color: var(--muted);
      cursor: pointer;
      font-size: 1.1rem;
      line-height: 1;
      padding: 0.2rem;
    }

    .modal-close-btn:hover { color: #fff; }
    body.light .modal-close-btn { color: #0f172a; }
    body.light .modal-close-btn:hover { color: #111827; }

    .modal-body {
      display: grid;
      gap: 0.75rem;
    }

    .portfolio-doughnut-wrap {
      width: 100%;
      height: 260px;
    }

    .breakdown-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 0.5rem;
      font-size: 0.85rem;
    }

    .breakdown-stat {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 0.6rem 0.75rem;
      background: #0f172a33;
    }

    body.light .breakdown-stat {
      background: #f8fafc;
      border-color: #e5e7eb;
    }

    .breakdown-label { color: var(--muted); }
    body.light .breakdown-label { color: #0f172a; }

    /* Trades table: slightly denser and allow the last column to wrap so it fits without scrolling */
    .trades-card table { font-size: 0.78rem; }
    .trades-card th, .trades-card td { padding: 0.3rem 0.35rem; }
    .trades-card td.desktop-only.money:last-child {
      white-space: normal;
      word-break: break-word;
    }
  </style>
</head>

<body>
<div id="app">
  <header>
    <div class="wallet-controls">
      <a class="brand" href="/" aria-label="Hypermonitor home">
      <h1>
        <img src="images/logo.png" alt="Hypermonitor logo" style="width: 1.6rem; height: 1.6rem; border-radius: 4px;" />
        <span class="logo-word logo-word-regular">Hyper<em>monitor</em></span>
      </h1>
      </a>
      <div class="tagline">
        Track any Hyperliquid wallet. No wallet connection required.
      </div>
      <div class="wallet-input-row">
        <label for="walletInput">Wallet address:</label>
        <input id="walletInput" type="text" placeholder="0x..." autocomplete="off" />
        <button id="trackBtn" aria-label="Track wallet">
          <span class="sr-only">Track</span>
          ⏎
        </button>
      </div>
    </div>

    <div class="header-right">
      <div class="header-right-top">
        <button id="themeToggle" class="theme-toggle-btn">☀️</button>
        <div class="status-pill">
          <span id="statusDot" class="status-dot"></span>
          <span id="statusText"></span>
          <img id="statusSpinner" class="status-spinner" alt="Connecting to Hyperliquid" />
          <span class="status-logo hidden" aria-hidden="true">
            <a href="https://app.hyperliquid.xyz/join/HYPERMONITOR" target="_blank" rel="noopener noreferrer" class="status-logo-link">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 179 28">
                <g clip-path="url(#clip0_975_1209)" fill="currentColor">
                    <path d="M31.8056 11.727C31.8346 14.3384 31.2881 16.8337 30.2146 19.2178C28.6816 22.6126 25.0063 25.3885 21.6501 22.4337C18.913 20.0254 18.4052 15.1363 14.3044 14.4206C8.87845 13.7629 8.74788 20.0544 5.20315 20.7653C1.2522 21.5681 -0.0583338 14.9235 -0.000302664 11.9059C0.0577284 8.88828 0.860492 4.64717 4.294 4.64717C8.24495 4.64717 8.51092 10.6292 13.5258 10.3052C18.4923 9.96669 18.5793 3.74285 21.8242 1.07826C24.6242 -1.22364 27.9175 0.464096 29.5665 3.23508C31.0947 5.79812 31.7669 8.80606 31.8007 11.727H31.8056Z"/>
                    <path d="M46.7054 21.8777V1.68286H48.6204V10.4165H60.4297V1.68286H62.3157V21.8777H60.4297V12.0414H48.6204V21.8777H46.7054Z"/>
                    <path d="M67.316 27.9999L69.9274 21.5004L64.2694 7.92114H66.2425L69.9565 17.1191C70.1692 17.68 70.4691 18.4248 70.8559 19.3533C70.914 19.2179 70.972 19.0679 71.03 18.9035C71.0881 18.7391 71.1461 18.5892 71.2041 18.4538C71.3202 18.2023 71.4217 17.9654 71.5088 17.7429C71.5958 17.5205 71.6781 17.3028 71.7554 17.0901L75.2373 7.92114H77.1233L69.2021 27.9999H67.316Z"/>
                    <path d="M79.0383 28.0001V7.92135H80.8372V10.4747C81.3015 9.60426 81.9737 8.89338 82.8538 8.34208C83.734 7.79078 84.7156 7.51514 85.7989 7.51514C87.0949 7.51514 88.2217 7.82947 89.1792 8.45814C90.1367 9.08681 90.8718 9.95728 91.3844 11.0695C91.897 12.1818 92.1533 13.444 92.1533 14.8561C92.1533 16.2682 91.8873 17.5642 91.3554 18.6861C90.8234 19.8081 90.0738 20.6882 89.1067 21.3265C88.1395 21.9649 87.0369 22.284 85.7989 22.284C84.7543 22.284 83.792 22.0326 82.9118 21.5296C82.0317 21.0267 81.3402 20.2916 80.8372 19.3245V28.0001H79.0383ZM85.5378 20.8333C86.4856 20.8333 87.3222 20.5818 88.0476 20.0789C88.773 19.5759 89.3291 18.8747 89.716 17.9752C90.1029 17.0758 90.2963 16.036 90.2963 14.8561C90.2963 13.6761 90.098 12.6992 89.7015 11.8094C89.3049 10.9196 88.7488 10.2281 88.0331 9.73483C87.3174 9.24156 86.4856 8.99493 85.5378 8.99493C84.5899 8.99493 83.7823 9.23673 83.0569 9.72032C82.3315 10.2039 81.7657 10.8906 81.3595 11.7804C80.9533 12.6702 80.7502 13.6954 80.7502 14.8561C80.7502 16.0167 80.9533 17.0758 81.3595 17.9752C81.7657 18.8747 82.3267 19.5759 83.0424 20.0789C83.7581 20.5818 84.5899 20.8333 85.5378 20.8333Z"/>
                    <path d="M100.742 22.284C99.4267 22.284 98.2709 21.9939 97.2747 21.4136C96.2785 20.8333 95.5048 19.9821 94.9535 18.8602C94.4022 17.7383 94.1265 16.3939 94.1265 14.8271C94.1265 13.4343 94.4118 12.1818 94.9825 11.0695C95.5531 9.95728 96.3317 9.08681 97.3182 8.45814C98.3048 7.82947 99.4074 7.51514 100.626 7.51514C101.941 7.51514 103.063 7.81496 103.992 8.41462C104.92 9.01427 105.626 9.86056 106.11 10.9535C106.594 12.0464 106.835 13.3182 106.835 14.769V15.1462H95.9255C95.9255 16.3455 96.1286 17.3708 96.5348 18.2219C96.941 19.073 97.5117 19.721 98.2467 20.1659C98.9818 20.6108 99.8232 20.8333 100.771 20.8333C101.893 20.8333 102.826 20.5673 103.571 20.0353C104.316 19.5034 104.775 18.7055 104.949 17.6416H106.748C106.613 18.5314 106.299 19.3245 105.805 20.0208C105.312 20.7172 104.635 21.2685 103.774 21.6747C102.913 22.0809 101.903 22.284 100.742 22.284ZM104.92 13.7825C104.901 12.3317 104.514 11.1711 103.76 10.3006C103.005 9.43016 101.961 8.99493 100.626 8.99493C99.2913 8.99493 98.2612 9.44467 97.4198 10.3442C96.5783 11.2436 96.0996 12.3897 95.9835 13.7825H104.92Z"/>
                    <path d="M109.616 21.8778V7.92135H111.415V10.7068C111.802 9.77835 112.406 9.01427 113.228 8.41462C114.05 7.81496 115.013 7.51514 116.115 7.51514C116.386 7.51514 116.647 7.53448 116.899 7.57317V9.3141C116.57 9.27541 116.28 9.25607 116.028 9.25607C115.1 9.25607 114.287 9.46401 113.591 9.8799C112.895 10.2958 112.358 10.8906 111.981 11.6644C111.603 12.4381 111.415 13.3376 111.415 14.3628V21.8778H109.616Z"/>
                    <path d="M121.367 21.491L121.285 21.8827H115.593L115.675 21.491C117.247 21.3217 117.89 20.872 118.142 19.6969L121.338 4.63295C121.677 3.09029 121.198 2.83883 119.573 3.17251L119.655 2.7808L123.132 1.60083H123.524L119.679 19.692C119.428 20.872 119.849 21.3169 121.362 21.4861L121.367 21.491Z"/>
                    <path d="M127.78 21.4909L127.697 21.8826H122.006L122.088 21.4909C123.659 21.3216 124.303 20.8719 124.554 19.6967L126.488 10.523C126.827 8.9513 126.377 8.72885 124.723 9.06253L124.806 8.67082L128.283 7.49085H128.674L126.092 19.6919C125.84 20.8719 126.261 21.3168 127.775 21.486L127.78 21.4909ZM128.732 2.41797C129.492 2.41797 129.995 3.00795 129.912 3.76236C129.801 4.5216 129.129 5.08256 128.399 5.08256C127.615 5.08256 127.078 4.5216 127.194 3.76236C127.277 3.00312 127.954 2.41797 128.737 2.41797H128.732Z"/>
                    <path d="M137.582 25.9255L139.144 18.7103C138.162 20.8429 136.117 22.2985 133.955 22.2985C130.478 22.2985 128.848 19.0149 129.888 14.1065C130.618 10.5424 133.815 7.48608 137.601 7.48608C139.342 7.48608 140.769 8.2695 141.359 9.42045L142.679 7.48608H143.071L139.125 25.9158C138.844 27.178 139.855 27.4294 140.866 27.5987L140.783 27.9904H134.25L134.332 27.5987C136.213 27.4294 137.306 27.178 137.587 25.9158L137.582 25.9255ZM134.884 21.2636C136.678 21.2636 138.472 19.721 139.313 17.8688L140.493 12.3414C140.803 10.349 139.85 8.27434 137.127 8.27434C134.405 8.27434 132.277 10.6294 131.576 14.0774C130.676 18.3137 131.938 21.2588 134.884 21.2588V21.2636Z"/>
                    <path d="M162.531 21.4909L162.448 21.8826H156.756L156.839 21.4909C158.41 21.3216 159.054 20.8719 159.305 19.6967L161.239 10.523C161.578 8.9513 161.128 8.72885 159.474 9.06253L159.556 8.67082L163.034 7.49085H163.425L160.843 19.6919C160.591 20.8719 161.012 21.3168 162.526 21.486L162.531 21.4909ZM163.483 2.41797C164.242 2.41797 164.745 3.00795 164.663 3.76236C164.552 4.5216 163.88 5.08256 163.15 5.08256C162.366 5.08256 161.829 4.5216 161.945 3.76236C162.028 3.00312 162.705 2.41797 163.488 2.41797H163.483Z"/>
                    <path d="M154.45 19.6628L155.741 13.5018L157.013 7.49561H156.621L153.144 8.67557L153.062 9.06728C154.687 8.72877 155.165 8.95605 154.827 10.5277L153.173 18.3523C151.35 20.0642 150.059 21.0749 148.487 21.0749C146.553 21.0749 145.542 19.7547 146.021 17.4866L148.153 7.50044H147.762L144.255 8.68041L144.173 9.07212C145.827 8.7336 146.277 8.96089 145.967 10.5326L144.454 17.7139C143.864 20.3785 145.213 22.3129 147.708 22.3129C149.362 22.3129 150.818 21.3892 153.057 18.9858L152.95 19.4935V19.5177H152.946L152.443 21.897H156.055L156.137 21.4714C154.624 21.3022 154.203 20.8524 154.454 19.6773L154.45 19.6628Z"/>
                    <path d="M177.696 6.96871L178.828 1.60083H178.436L174.959 2.7808L174.877 3.17251C176.502 2.83399 176.98 3.09029 176.642 4.63295L175.66 9.2029C175.041 8.16318 173.697 7.49099 172.125 7.49099C168.309 7.49099 165.142 10.5183 164.33 14.3628C163.348 19.0198 164.949 22.2986 168.455 22.2986C170.64 22.2986 172.72 20.814 173.673 18.6813L173.421 19.9048L173 21.8779L176.613 21.8488L176.695 21.4571C175.181 21.2879 174.761 20.8381 175.012 19.663L177.691 6.96871H177.696ZM173.837 17.8399C172.996 19.721 171.201 21.2637 169.378 21.2637C166.433 21.2637 165.171 18.3186 166.012 14.3338C166.796 10.6295 169.04 8.27441 171.651 8.27441C174.437 8.27441 175.365 10.4844 174.998 12.4962L174.867 13.1055L173.842 17.8399H173.837Z"/>
                </g>
                <defs>
                  <clipPath id="clip0_975_1209">
                    <rect width="178.832" height="28" fill="white"/>
                  </clipPath>
                </defs>
              </svg>
            </a>
          </span>
        </div>
      </div>
      <div class="timestamp" id="startedAt"></div>
    </div>
  </header>

  <div class="grid">
    <section class="card">
      <h2>Account Overview</h2>
      <div id="marginSummary" class="kv-list"></div>
      <div class="error" id="snapshotError"></div>
    </section>

    <section class="card positions-card" style="overflow: auto;">
      <div class="section-title">
        <h2>Positions</h2>
        <div class="section-actions">
          <button id="positionsChartBtn" class="pill-action-btn">Chart</button>
          <button id="exportExcelBtn" class="export-btn" aria-label="Export Excel">
            <svg class="export-icon" viewBox="0 0 24 24" fill="none" aria-hidden="true" focusable="false">
              <path d="M12 3v11" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M8 10l4 4 4-4" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M5 18h14" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"/>
            </svg>
            <span class="sr-only">Export Excel</span>
          </button>
        </div>
      </div>
      <table>
        <thead>
        <tr>
          <th>Asset</th>
          <th>Side</th>
          <th>Size</th>
          <th>Price</th>
          <th>Notional</th>
          <th class="mobile-only">PnL</th>
          <th class="desktop-only">Unrealized PnL</th>
        </tr>
        </thead>
        <tbody id="positionsBody">
        <tr><td colspan="4" class="mobile-only muted">Loading…</td></tr>
        <tr><td colspan="6" class="desktop-only muted">Loading…</td></tr>
        </tbody>
      </table>
    </section>
  </div>

  <div class="portfolio-modal" id="portfolioModal">
    <div class="modal-card">
      <div class="modal-header">
        <h3>Portfolio breakdown</h3>
        <button id="portfolioModalClose" class="modal-close-btn" aria-label="Close portfolio breakdown">&times;</button>
      </div>
      <div class="modal-body">
        <div class="portfolio-doughnut-wrap">
          <canvas id="portfolioDoughnut"></canvas>
        </div>
        <div class="breakdown-stats">
          <div class="breakdown-stat">
            <div class="breakdown-label">Open positions value</div>
            <div class="money" id="positionsValueStat">$0.00</div>
          </div>
          <div class="breakdown-stat">
            <div class="breakdown-label">Withdrawable</div>
            <div class="money" id="withdrawableValueStat">$0.00</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <section class="card">
    <h2>Performance</h2>

    <div class="chart-toolbar">
      <button class="chart-range-btn" data-range="day">Day</button>
      <button class="chart-range-btn" data-range="week">Week</button>
      <button class="chart-range-btn" data-range="month">Month</button>
      <button class="chart-range-btn active" data-range="allTime">All Time</button>
    </div>

    <div class="chart-grid">
      <div class="chart-card">
        <h3>Account Value</h3>
        <div class="chart-canvas-wrap">
          <canvas id="equityChart"></canvas>
        </div>
      </div>

      <div class="chart-card">
        <h3>Profit & Loss</h3>
        <div class="chart-canvas-wrap">
          <canvas id="pnlChart"></canvas>
        </div>
      </div>

      <div class="chart-card">
        <h3>Deposits & Withdrawals</h3>
        <div class="chart-canvas-wrap">
          <canvas id="depositsChart"></canvas>
        </div>
      </div>
    </div>

    <div class="chart-loading" id="portfolioLoading">Loading performance data…</div>
    <div class="error" id="portfolioError"></div>
  </section>

  <p></p>

  <div class="layout-two">
    <section class="card">
      <h2>Orders</h2>

      <div class="orders-tabs">
        <button class="orders-tab-btn orders-only-tab-btn active" data-tab="live">Live</button>
        <button class="orders-tab-btn orders-only-tab-btn" data-tab="history">History</button>
      </div>

      <div id="ordersLivePanel" class="tab-panel">
        <div class="section-title">
          <span>Open</span>
          <small id="openOrdersCount">–</small>
        </div>
        <div style="height: 160px; overflow: auto; margin-bottom: .75rem;">
          <table>
            <thead>
            <tr>
              <th class="desktop-only">Order ID</th>
              <th class="desktop-only">Time</th>  
              <th style="width: 20%;">Asset</th>
              <th>Side</th>
              <th>Size</th>
              <th class="desktop-only">Limit Price</th>
              <th class="mobile-only">Price</th>
            </tr>
            </thead>
            <tbody id="openOrdersBody">
            <tr><td colspan="6" class="muted">No open orders.</td></tr>
            </tbody>
          </table>
        </div>

        <div class="section-title">
          <span>Canceled</span>
          <small id="canceledCount">–</small>
        </div>
        <div style="max-height: 160px; overflow: auto;">
          <table>
            <thead>
            <tr>
              <th class="desktop-only">Order ID</th>
              <th class="desktop-only">Created</th>
              <th class="desktop-only">Canceled</th>
              <th>Asset</th>
              <th>Side</th>
              <th>Size</th>
              <th class="mobile-only">Price</th>
            </tr>
            </thead>
            <tbody id="canceledOrdersBody">
            <tr><td colspan="6" class="muted">No canceled orders yet.</td></tr>
            </tbody>
          </table>
        </div>

        <div class="error" id="ordersError"></div>
      </div>

      <div id="ordersHistoryPanel" class="tab-panel hidden">
        <div class="section-title">
          <span>Historical (last 2000)</span>
          <small id="historicalOrdersCount">–</small>
        </div>

        <div class="orders-filter-bar">
          <div class="orders-filter-group">
            <span class="orders-filter-label">Asset</span>
            <input
              id="historicalAssetFilter"
              class="orders-filter-input"
              type="text"
              placeholder="e.g. ETH"
              autocomplete="off"
            />
          </div>

          <div class="orders-filter-group">
            <span class="orders-filter-label">Side</span>
            <select id="historicalSideFilter" class="orders-filter-select">
              <option value="all">All</option>
              <option value="B">Buy</option>
              <option value="S">Sell</option>
            </select>
          </div>

          <div class="orders-filter-group">
            <span class="orders-filter-label">Status</span>
            <select id="historicalStatusFilter" class="orders-filter-select">
              <option value="all">All</option>
              <option value="open">Open</option>
              <option value="filled">Filled</option>
              <option value="canceled">Canceled</option>
              <option value="resting">Resting</option>
            </select>
          </div>
        </div>

        <div style="max-height: 380px; overflow: auto;">
          <table>
            <thead>
            <tr>
              <th>Order ID</th>
              <th>Date / Time</th>
              <th>Side</th>
              <th>Asset</th>
              <th>Size</th>
              <th>Price</th>
              <th>Status</th>
            </tr>
            </thead>
            <tbody id="historicalOrdersBody">
            <tr><td colspan="7" class="muted">Loading historical orders…</td></tr>
            </tbody>
          </table>
        </div>
      </div>
    </section>

    <section class="card trades-card">
      <h2>Trades</h2>

      <div class="orders-tabs">
        <button class="orders-tab-btn fills-tab-btn active" data-tab="fills-live">Live</button>
        <button class="orders-tab-btn fills-tab-btn" data-tab="fills-history">History</button>
      </div>

      <div id="fillsLivePanel" class="tab-panel">
        <div class="section-title">
          <span>Live</span>
          <small id="fillsCount">–</small>
        </div>
        <div style="max-height: 360px; overflow: auto;">
          <table>
            <thead>
            <tr>
              <th class="desktop-only">Order ID</th>
              <th class="desktop-only">Time</th>
              <th>Side</th>
              <th>Asset</th>
              <th>Size</th>
              <th>Price</th>
              <th class="desktop-only">Notional</th>
            </tr>
            </thead>
            <tbody id="fillsBody">
            <tr><td colspan="7" class="muted">Waiting for fills…</td></tr>
            </tbody>
          </table>
        </div>
        <div class="error" id="fillsError"></div>
      </div>

      <div id="fillsHistoryPanel" class="tab-panel hidden">
        <div class="section-title">
          <span>Historical (last 2000)</span>
          <small id="historicalFillsCount">–</small>
        </div>
        <div style="max-height: 360px; overflow: auto;">
          <table>
            <thead>
            <tr>
              <th class="desktop-only">Order ID</th>
              <th>Date / Time</th>
              <th>Side</th>
              <th>Asset</th>
              <th>Size</th>
              <th>Price</th>
            </tr>
            </thead>
            <tbody id="historicalFillsBody">
            <tr><td colspan="6" class="muted">Loading historical fills…</td></tr>
            </tbody>
          </table>
        </div>
      </div>
    </section>
  </div>

  <footer>
    <div style="margin-top:.1rem;">
        © <span id="year"></span> <a href="/">Hypermonitor</a>.
    </div>
  </footer>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script type="module">
  import * as hl from "https://esm.sh/jsr/@nktkas/hyperliquid";

  const DEFAULT_WALLET = "0x0b1ace05eb9ef1c3a1951b763700ecad24f27741";

  const MAX_FILL_ROWS = 100;
  const PORTFOLIO_API_URL = "https://api.hyperliquid.xyz/info";

  const walletInputEl = document.getElementById("walletInput");
  const trackBtnEl = document.getElementById("trackBtn");

  const statusDotEl = document.getElementById("statusDot");
  const statusTextEl = document.getElementById("statusText");
  const statusSpinnerEl = document.getElementById("statusSpinner");
  const statusLogoEl = document.querySelector(".status-logo");
  const startedAtEl = document.getElementById("startedAt");

  const marginSummaryEl = document.getElementById("marginSummary");
  const snapshotErrorEl = document.getElementById("snapshotError");

  const positionsBodyEl = document.getElementById("positionsBody");
  const positionsChartBtn = document.getElementById("positionsChartBtn");
  const portfolioModalEl = document.getElementById("portfolioModal");
  const portfolioModalCloseEl = document.getElementById("portfolioModalClose");
  const portfolioDoughnutCanvas = /** @type {HTMLCanvasElement} */ (document.getElementById("portfolioDoughnut"));
  const positionsValueStatEl = document.getElementById("positionsValueStat");
  const withdrawableValueStatEl = document.getElementById("withdrawableValueStat");

  const openOrdersBodyEl = document.getElementById("openOrdersBody");
  const openOrdersCountEl = document.getElementById("openOrdersCount");
  const canceledOrdersBodyEl = document.getElementById("canceledOrdersBody");
  const canceledCountEl = document.getElementById("canceledCount");
  const ordersErrorEl = document.getElementById("ordersError");

  const historicalOrdersBodyEl = document.getElementById("historicalOrdersBody");
  const historicalOrdersCountEl = document.getElementById("historicalOrdersCount");

  const ordersTabButtons = document.querySelectorAll(".orders-only-tab-btn");
  const ordersLivePanelEl = document.getElementById("ordersLivePanel");
  const ordersHistoryPanelEl = document.getElementById("ordersHistoryPanel");

  const historicalSideFilterEl = document.getElementById("historicalSideFilter");
  const historicalStatusFilterEl = document.getElementById("historicalStatusFilter");
  const historicalAssetFilterEl = document.getElementById("historicalAssetFilter");

  const fillsBodyEl = document.getElementById("fillsBody");
  const fillsErrorEl = document.getElementById("fillsError");
  const fillsCountEl = document.getElementById("fillsCount");
  const historicalFillsBodyEl = document.getElementById("historicalFillsBody");
  const historicalFillsCountEl = document.getElementById("historicalFillsCount");
  const fillsTabButtons = document.querySelectorAll(".fills-tab-btn");
  const fillsLivePanelEl = document.getElementById("fillsLivePanel");
  const fillsHistoryPanelEl = document.getElementById("fillsHistoryPanel");

  const portfolioErrorEl = document.getElementById("portfolioError");
  const portfolioLoadingEl = document.getElementById("portfolioLoading");
  const rangeButtons = document.querySelectorAll(".chart-range-btn");
  const exportExcelBtn = document.getElementById("exportExcelBtn");

  const equityCanvas = /** @type {HTMLCanvasElement} */ (document.getElementById("equityChart"));
  const pnlCanvas = /** @type {HTMLCanvasElement} */ (document.getElementById("pnlChart"));
  const depositsCanvas = /** @type {HTMLCanvasElement} */ (document.getElementById("depositsChart"));

  const themeToggleBtn = document.getElementById("themeToggle");

  const COIN_ICON_BASE = "https://app.hyperliquid.xyz/coins/";
  const logoCache = new Map();
  const expandedPositions = new Set();
  const coinIdMap = new Map();
  const spotIdMetaMap = new Map();
  let perpDexNames = null;
  let spotMetaPromise = null;
  let logoRetryTimer = null;
  let logoRefreshTimer = null;

  document.getElementById("year").textContent = new Date().getFullYear();

  window.__logoOk = (rawKey, imgEl) => {
    const entry = logoCache.get(rawKey);
    if (!entry) return;
    const nextUrl = imgEl?.currentSrc || imgEl?.src || entry.urls?.[entry.idx];
    const wasOk = entry.state === "ok" && entry.okUrl === nextUrl;
    entry.state = "ok";
    entry.okUrl = nextUrl;
    if (!wasOk) scheduleLogoRefresh();
  };

  window.__logoErr = (rawKey, imgEl, fallbackLetter) => {
    const entry = logoCache.get(rawKey);
    if (!entry) return;

    const nextIdx = (entry.idx ?? 0) + 1;
    if (entry.urls && nextIdx < entry.urls.length) {
      entry.idx = nextIdx;
      const nextUrl = entry.urls[nextIdx];
      try {
        if (imgEl && imgEl.src !== nextUrl) imgEl.src = nextUrl;
      } catch {}
      return;
    }

    entry.state = "bad";
    entry.retryCount = (entry.retryCount || 0) + 1;
    scheduleLogoRetry();
    try {
      if (imgEl && imgEl.outerHTML) {
        imgEl.outerHTML = `<span class="coinFallback">${fallbackLetter || "?"}</span>`;
      }
    } catch {}
  };

  // === URL + LAST WALLET (localStorage) helpers ===
  const LAST_WALLET_KEY = "hypermonitor-last-wallet";

  function saveLastWallet(wallet) {
    try { localStorage.setItem(LAST_WALLET_KEY, wallet); } catch (e) {}
  }

  function getLastWallet() {
    try { return (localStorage.getItem(LAST_WALLET_KEY) || "").trim(); } catch (e) { return ""; }
  }

  function setWalletInUrl(wallet, { replace = false } = {}) {
    try {
      const url = new URL(window.location.href);
      url.searchParams.set("wallet", wallet);
      if (replace) history.replaceState({ wallet }, "", url.toString());
      else history.pushState({ wallet }, "", url.toString());
    } catch (e) {}
  }

  function getWalletFromUrl() {
    try {
      const url = new URL(window.location.href);
      return (url.searchParams.get("wallet") || "").trim();
    } catch (e) {
      return "";
    }
  }

  async function getPerpDexNames() {
    if (perpDexNames) return perpDexNames;
    try {
      const res = await fetch(PORTFOLIO_API_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ type: "perpDexs" }),
      });
      if (!res.ok) throw new Error(`perpDexs error: ${res.status} ${res.statusText}`);
      const data = await res.json();
      const names = (Array.isArray(data) ? data : [])
        .map((x) => x?.name)
        .filter((x) => typeof x === "string" && x.length > 0);
      perpDexNames = ["", ...names.filter((n) => n !== "")];
    } catch (err) {
      console.warn("Failed to load perp dex names", err);
      perpDexNames = [""];
    }
    return perpDexNames;
  }

  async function fetchAdditionalDexPositions(wallet) {
    try {
      const dexNames = await getPerpDexNames();
      const extraDexes = (dexNames || []).filter((d) => d);
      if (extraDexes.length === 0) return [];

      const fetches = extraDexes.map(async (dex) => {
        try {
          const res = await fetch(PORTFOLIO_API_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ type: "clearinghouseState", user: wallet, dex }),
          });
          if (!res.ok) throw new Error(`dex ${dex} status ${res.status}`);
          const data = await res.json();
          return Array.isArray(data?.assetPositions) ? data.assetPositions : [];
        } catch (err) {
          console.warn("Additional dex positions error", err);
          return [];
        }
      });

      const results = await Promise.all(fetches);
      return results.flat();
    } catch (err) {
      console.warn("Failed to fetch additional dex positions", err);
      return [];
    }
  }

  // === STATE ===
  let currentWallet = DEFAULT_WALLET;
  const openOrders = new Map();
  const canceledOrders = [];
  const fills = [];

  const historicalOrders = [];
  let historicalOrdersLoaded = false;
  const historicalFills = [];
  let historicalFillsLoaded = false;

  let infoClient = null;
  let subsClient = null;
  let orderUpdatesSub = null;
  let userEventsSub = null;

  let currentAssetPositions = [];
  const liveMids = new Map();
  let allMidsSub = null;

  let snapshotMarginSummary = null;
  let snapshotWithdrawable = null;
  let snapshotUpnlTotal = 0;
  let lastComputedUpnlTotal = 0;
  let lastComputedTotalNotional = 0;

  let portfolioData = null;
  let currentRangeKey = "allTime";
  const portfolioCharts = { equity: null, pnl: null, deposits: null };
  const portfolioBreakdownChart = { chart: null };

  function updateSpinnerForTheme(theme) {
    if (!statusSpinnerEl) return;
    statusSpinnerEl.src =
      theme === "light"
        ? "https://hyperfoundation.org/landing/blob-dark.gif"
        : "https://hyperfoundation.org/landing/blob_green.gif";
  }

  function setStatus(status, message) {
    statusDotEl.classList.remove("connected", "error");

    if (status === "connected") {
      statusDotEl.classList.add("connected");
      statusTextEl.textContent = message ?? "Connected to";
      if (statusSpinnerEl) statusSpinnerEl.style.display = "none";
      if (statusLogoEl) statusLogoEl.classList.remove("hidden");
    } else if (status === "error") {
      statusDotEl.classList.add("error");
      statusTextEl.textContent = message ?? "Error";
      if (statusSpinnerEl) statusSpinnerEl.style.display = "none";
      if (statusLogoEl) statusLogoEl.classList.add("hidden");
    } else {
      statusTextEl.textContent = "";
      if (statusSpinnerEl) statusSpinnerEl.style.display = "inline-block";
      if (statusLogoEl) statusLogoEl.classList.add("hidden");
    }
  }

  function fmtTime(ms) {
    if (!ms && ms !== 0) return "";
    const d = new Date(Number(ms));
    if (Number.isNaN(d.getTime())) return "";
    return d.toLocaleString();
  }

  function fmtTimeOnly(ms) {
    if (!ms && ms !== 0) return "";
    const d = new Date(Number(ms));
    if (Number.isNaN(d.getTime())) return "";
    return d.toLocaleTimeString(undefined, { hour: "2-digit", minute: "2-digit", second: "2-digit" });
  }

  function fmtDateTime(ms) {
    if (!ms && ms !== 0) return "";
    const d = new Date(Number(ms));
    if (Number.isNaN(d.getTime())) return "";
    const date = d.toLocaleDateString(undefined, { year: "numeric", month: "short", day: "2-digit" });
    const time = d.toLocaleTimeString(undefined, { hour: "2-digit", minute: "2-digit", second: "2-digit" });
    return `${date} ${time}`;
  }

  function fmtMoney(v, decimals = 2) {
    const n = Number(v);
    if (Number.isNaN(n)) return "";
    const sign = n < 0 ? "-" : "";
    const abs = Math.abs(n).toLocaleString(undefined, {
      minimumFractionDigits: decimals,
      maximumFractionDigits: decimals,
    });
    return `${sign}$${abs}`;
  }

  function fmtPrice(v) {
    if (v === null || v === undefined) return "";
    const n = Number(v);
    if (Number.isNaN(n)) return String(v);
    const formatted = n.toLocaleString(undefined, {
      maximumFractionDigits: 8,
      useGrouping: true,
    });
    return `$${formatted}`;
  }

  function fmtLimitPrice(v) { return fmtPrice(v); }

  function formatSignedDollar(v, decimals = 2) {
    const n = Number(v);
    if (Number.isNaN(n)) return "";
    const abs = Math.abs(n).toLocaleString(undefined, {
      minimumFractionDigits: decimals,
      maximumFractionDigits: decimals,
    });
    return n < 0 ? "-$" + abs : "$" + abs;
  }

  function formatSignedDollarWithPlus(v, decimals = 2) {
    const n = Number(v);
    if (Number.isNaN(n)) return "";
    const abs = Math.abs(n).toLocaleString(undefined, {
      minimumFractionDigits: decimals,
      maximumFractionDigits: decimals,
    });
    if (n > 0) return "+$" + abs;
    if (n < 0) return "-$" + abs;
    return "$" + abs;
  }

  function rememberCoinAlias(raw, resolved) {
    if (!raw || !resolved) return;
    const key = String(raw).trim();
    const val = String(resolved).trim();
    if (!key || !val) return;
    coinIdMap.set(key, val);
    if (key.startsWith("@")) coinIdMap.set(key.slice(1), val);
  }

  function resolveCoinName(raw, alt) {
    const primary = (raw || "").trim();
    const secondary = (alt || "").trim();

    if (primary && secondary && primary !== secondary) {
      rememberCoinAlias(primary, secondary);
      rememberCoinAlias(secondary, primary);
    }

    if (primary.startsWith("@")) {
      const lookup = coinIdMap.get(primary) || coinIdMap.get(primary.slice(1));
      if (lookup) return lookup;
      if (secondary && !secondary.startsWith("@")) return secondary;
    }
    if (secondary.startsWith("@")) {
      const lookup = coinIdMap.get(secondary) || coinIdMap.get(secondary.slice(1));
      if (lookup) return lookup;
    }

    return primary || secondary;
  }

  function buildTokenIndexMap(tokens) {
    const map = new Map();
    for (const t of tokens) {
      if (t && typeof t.index !== "undefined" && typeof t.name !== "undefined") {
        map.set(Number(t.index), String(t.name));
      }
    }
    return map;
  }

  function deriveSpotPair(u, tokenByIndex) {
    const name = String(u?.name ?? "");
    if (name.includes("/")) {
      const [base, quote] = name.split("/", 2);
      return { pair: name, base, quote };
    }
    const toks = u?.tokens;
    if (Array.isArray(toks) && toks.length >= 2) {
      const base = tokenByIndex.get(Number(toks[0])) ?? `token${toks[0]}`;
      const quote = tokenByIndex.get(Number(toks[1])) ?? `token${toks[1]}`;
      return { pair: `${base}/${quote}`, base, quote };
    }
    return { pair: name || "UNKNOWN", base: "UNKNOWN", quote: "UNKNOWN" };
  }

  async function ensureSpotMeta() {
    if (spotIdMetaMap.size) return;
    if (spotMetaPromise) return spotMetaPromise;

    spotMetaPromise = (async () => {
      try {
        const res = await fetch(PORTFOLIO_API_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ type: "spotMeta" }),
        });
        if (!res.ok) throw new Error(`spotMeta error: ${res.status} ${res.statusText}`);
        const data = await res.json();
        const tokens = data?.tokens;
        const universe = data?.universe;
        if (!Array.isArray(tokens) || !Array.isArray(universe)) {
          throw new Error("spotMeta response missing tokens/universe");
        }
        const tokenByIndex = buildTokenIndexMap(tokens);
        universe
          .filter((u) => u && typeof u.index !== "undefined")
          .forEach((u) => {
            const idx = Number(u.index);
            const spotId = `@${idx}`;
            const { pair, base, quote } = deriveSpotPair(u, tokenByIndex);
            spotIdMetaMap.set(spotId, { base, quote, pair, isCanonical: Boolean(u.isCanonical) });
            rememberCoinAlias(spotId, base);
          });
      } catch (err) {
        console.warn("Failed to load spot meta", err);
      } finally {
        spotMetaPromise = null;
      }
    })();

    return spotMetaPromise;
  }

  function formatSpotIdHtml(rawId) {
    const key = String(rawId ?? "");
    if (!key.startsWith("@")) return key;
    const meta = spotIdMetaMap.get(key);
    if (!meta?.base) return key;
    return `<span class="spot-id">${meta.base}</span> <span class="dex-tag spot-tag">spot</span>`;
  }

  function resolveSpotDisplay(rawName) {
    const key = String(rawName ?? "");
    const meta = key.startsWith("@") ? spotIdMetaMap.get(key) : null;
    return {
      label: meta?.base || key,
      iconKey: meta?.base || key,
      isSpot: Boolean(meta?.base),
    };
  }

  function fmtSize(v) {
    if (v === null || v === undefined) return "";
    const n = Number(v);
    if (Number.isNaN(n)) return String(v);
    return n.toLocaleString();
  }

  function fmtSignedSize(v) {
    const n = Number(v);
    if (Number.isNaN(n)) return "";
    const sign = n > 0 ? "+" : n < 0 ? "-" : "";
    return `${sign}${fmtSize(Math.abs(n))}`;
  }

  function xmlEscape(v) {
    const s = v === null || v === undefined ? "" : String(v);
    return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\"/g, "&quot;").replace(/'/g, "&apos;");
  }

  function getIconCandidates(rawName, cleanName) {
    const candidates = [];
    if (rawName) candidates.push(`${COIN_ICON_BASE}${encodeURIComponent(rawName)}.svg`);
    if (cleanName && cleanName !== rawName) candidates.push(`${COIN_ICON_BASE}${encodeURIComponent(cleanName)}.svg`);
    const addUnprefixed = (name) => {
      if (!name || name.length <= 1) return;
      if (name[0] !== "U" && name[0] !== "u") return;
      const unprefixed = name.slice(1);
      if (!unprefixed) return;
      candidates.push(`${COIN_ICON_BASE}${encodeURIComponent(unprefixed)}.svg`);
      const upper = unprefixed.toUpperCase();
      if (upper !== unprefixed) {
        candidates.push(`${COIN_ICON_BASE}${encodeURIComponent(upper)}.svg`);
      }
    };
    addUnprefixed(cleanName);
    addUnprefixed(rawName);
    if (rawName && rawName.includes(":")) candidates.push(`${COIN_ICON_BASE}${encodeURIComponent(rawName)}.svg`);
    return Array.from(new Set(candidates));
  }

  function ensureLogoCache(rawName, cleanName) {
    if (logoCache.has(rawName)) return logoCache.get(rawName);
    const urls = getIconCandidates(rawName, cleanName);
    const entry = { state: "unknown", idx: 0, urls, okUrl: null };
    logoCache.set(rawName, entry);
    return entry;
  }

  function scheduleLogoRetry() {
    if (logoRetryTimer) return;
    logoRetryTimer = setTimeout(() => {
      logoRetryTimer = null;
      retryFailedLogos();
    }, 3000);
  }

  function scheduleLogoRefresh() {
    if (logoRefreshTimer) return;
    logoRefreshTimer = setTimeout(() => {
      logoRefreshTimer = null;
      if (currentAssetPositions.length) renderPositions(currentAssetPositions);
      renderOpenOrders();
      renderCanceledOrders();
      renderFills();
      if (historicalOrdersLoaded) renderHistoricalOrders();
      if (historicalFillsLoaded) renderHistoricalFills();
    }, 120);
  }

  function retryFailedLogos() {
    let changed = false;
    logoCache.forEach((entry) => {
      if (entry.state !== "bad") return;
      if ((entry.retryCount || 0) > 2) return;
      entry.state = "unknown";
      entry.idx = 0;
      entry.okUrl = null;
      changed = true;
    });
    if (!changed) return;
    if (currentAssetPositions.length) renderPositions(currentAssetPositions);
    renderOpenOrders();
    renderCanceledOrders();
    renderFills();
    if (historicalOrdersLoaded) renderHistoricalOrders();
    if (historicalFillsLoaded) renderHistoricalFills();
  }

  function coinIconHtml(rawName, cleanName) {
    const entry = ensureLogoCache(rawName, cleanName);
    const letter = (cleanName?.[0] || rawName?.[0] || "?").toUpperCase();

    if (entry.state === "bad" || !entry.urls.length) {
      return `<span class="coinFallback">${letter}</span>`;
    }

    const src = (entry.state === "ok" && entry.okUrl) ? entry.okUrl : entry.urls[entry.idx || 0];
    const safeKey = rawName.replace(/'/g, "\\'");

    return `
      <img
        class="coinIcon"
        src="${src}"
        alt="${cleanName || rawName}"
        loading="lazy"
        referrerpolicy="no-referrer"
        onload="window.__logoOk('${safeKey}', this)"
        onerror="window.__logoErr('${safeKey}', this, '${letter}')"
      />
    `;
  }

  function splitDexCoin(name) {
    const s = String(name || "").trim();
    const idx = s.indexOf(":");
    if (idx > 0 && idx < s.length - 1) {
      return { dex: s.slice(0, idx), base: s.slice(idx + 1) };
    }
    return { dex: "", base: s };
  }

  function coinCellHtml(coin) {
    const c = coin ?? "";
    const { label, iconKey, isSpot } = resolveSpotDisplay(c);
    const spotTagHtml = isSpot ? `<span class="dex-tag spot-tag">spot</span>` : "";
    return `<span class="asset-cell">${coinIconHtml(iconKey, label)}<span>${label}</span>${spotTagHtml}</span>`;
  }

  function normalizeCoin(coin) {
    return (coin || "").toUpperCase();
  }

  function getLivePriceForCoin(raw) {
    const { dex, base } = splitDexCoin(raw);
    const candidates = [raw, base, normalizeCoin(raw), normalizeCoin(base)];
    for (const key of candidates) {
      if (!key) continue;
      const px = liveMids.get(key);
      if (Number.isFinite(px)) return px;
    }
    return undefined;
  }

  function getMarkPriceForCoin(coin) {
    const norm = normalizeCoin(coin);
    const { base } = splitDexCoin(coin);
    const baseNorm = normalizeCoin(base);
    if (!norm) return null;

    const livePx =
      liveMids.get(norm) ??
      liveMids.get(coin) ??
      liveMids.get(base) ??
      liveMids.get(baseNorm);
    if (Number.isFinite(livePx)) return livePx;

    const position = currentAssetPositions.find((item) => {
      const c = item?.position?.coin;
      return normalizeCoin(c) === norm || normalizeCoin(splitDexCoin(c).base) === baseNorm;
    });
    if (!position) return null;

    const p = position.position;
    const szi = Number(p.szi ?? 0);
    const snapshotValue = Number(p.positionValue ?? 0);
    if (Number.isFinite(snapshotValue) && szi) return Math.abs(snapshotValue) / Math.abs(szi);

    const entryPx = Number(p.entryPx ?? 0);
    return Number.isFinite(entryPx) ? entryPx : null;
  }

  function getAllFillsForCoin(coin) {
    const norm = normalizeCoin(coin);
    if (!norm) return [];
    const combined = [];
    const pushFrom = (arr) => {
      arr.forEach((f) => {
        const resolved = resolveCoinName(f?.coin ?? f?.asset ?? "", f?.asset ?? f?.symbol ?? f?.sym);
        if (resolved) f.coin = resolved;
        const c = normalizeCoin(resolved);
        if (c === norm) combined.push(f);
      });
    };
    pushFrom(historicalFills);
    pushFrom(fills);

    // Deduplicate by composite key
    const seen = new Set();
    const unique = [];
    combined.forEach((f) => {
      const key = [
        normalizeCoin(f?.coin ?? f?.asset ?? ""),
        f?.oid ?? "",
        f?.time ?? f?.timestamp ?? "",
        f?.side ?? (f?.isBuy ? "B" : "S"),
        f?.sz ?? f?.size ?? "",
        f?.px ?? f?.price ?? "",
      ].join("|");
      if (seen.has(key)) return;
      seen.add(key);
      unique.push(f);
    });

    return unique.sort((a, b) => Number(a.time ?? a.timestamp ?? 0) - Number(b.time ?? b.timestamp ?? 0));
  }

  function buildPositionFillDetails(coin, szi, markPx) {
    const fillsForCoin = getAllFillsForCoin(coin);
    const rows = [];
    let netSize = 0;
    let totalUpnl = 0;

    const target = Number(szi) || 0;
    const EPS = 1e-8;

    // Start from most recent fill and walk back until we cover the current exposure
    const sorted = [...fillsForCoin].sort(
      (a, b) => Number(b.time ?? b.timestamp ?? 0) - Number(a.time ?? a.timestamp ?? 0)
    );

    for (const fill of sorted) {
      const sideRaw =
        fill.side ??
        (fill.isBuy !== undefined ? (fill.isBuy ? "B" : "S") : undefined) ??
        fill.dir ??
        fill.direction ??
        "?";
      const sideUpper = String(sideRaw).toUpperCase();
      let side = "?";
      if (sideUpper.startsWith("B") || sideUpper === "1" || sideUpper === "+1") side = "B";
      else if (
        sideUpper.startsWith("S") ||
        sideUpper.startsWith("A") ||
        sideUpper === "-1" ||
        sideUpper === "SELL" ||
        sideUpper === "SHORT"
      )
        side = "S";

      const sizeCandidates = [fill.szi, fill.sz, fill.size, fill.qty, fill.quantity, fill.baseSz, fill.baseSize];
      let sizeRaw = 0;
      for (const cand of sizeCandidates) {
        const n = Number(cand);
        if (!Number.isNaN(n)) {
          sizeRaw = n;
          break;
        }
      }

      // If side is unknown, infer from sign of size
      if (side === "?") {
        if (sizeRaw > 0) side = "B";
        else if (sizeRaw < 0) side = "S";
      }

      const px = Number(fill.px ?? fill.price ?? 0);
      const signed = side === "B" ? Math.abs(sizeRaw) : side === "S" ? -Math.abs(sizeRaw) : sizeRaw;

      netSize += Number.isFinite(signed) ? signed : 0;

      const valueSigned = Number.isFinite(px) && Number.isFinite(signed) ? signed * px : null;
      const upnl = Number.isFinite(markPx) && Number.isFinite(px) && Number.isFinite(signed)
        ? (markPx - px) * signed
        : null;
      if (Number.isFinite(upnl)) totalUpnl += upnl;

      rows.push({
        time: fmtDateTime(fill.time ?? fill.timestamp),
        sideCode: side,
        side: side === "B" ? "LONG" : side === "S" ? "SHORT" : sideLabel(side),
        size: fmtSize(Math.abs(signed)),
        sizeSigned: fmtSignedSize(signed),
        price: fmtPrice(px),
        value: Number.isFinite(valueSigned) ? formatSignedDollar(valueSigned) : "",
        upnl: Number.isFinite(upnl) ? formatSignedDollarWithPlus(upnl) : "",
        upnlRaw: Number.isFinite(upnl) ? upnl : null,
      });

      if (Math.abs(netSize - target) <= EPS) break;
    }

    const matches = Math.abs(netSize - target) <= EPS;

    return {
      rows,
      netSize,
      matches,
      totalUpnl,
    };
  }

  function getTotalPositionsValue() {
    return Number.isFinite(lastComputedTotalNotional) ? lastComputedTotalNotional : 0;
  }

  function getWithdrawableAmount() {
    const w = Number(snapshotWithdrawable ?? 0);
    return Number.isFinite(w) ? w : 0;
  }

  function computeTotal(order) {
    const sz = Number(order.sz ?? order.szi ?? 0);
    const pxStr = order.px ?? order.limitPx;
    const px = Number(pxStr ?? 0);
    if (Number.isNaN(sz) || Number.isNaN(px)) return "";
    return (sz * px).toLocaleString(undefined, {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    });
  }

  function sideLabel(side) { return side === "B" ? "LONG" : "SHORT"; }
  function sidePillClass(side) { return side === "B" ? "pill-buy" : "pill-sell"; }

  function buildPositionsRowsForExport() {
    if (!Array.isArray(currentAssetPositions) || currentAssetPositions.length === 0) return [];

    return currentAssetPositions.map((item) => {
      const p = item.position || {};
      const coin = p.coin ?? "";
      const szi = Number(p.szi ?? 0);
      const dir = szi > 0 ? "LONG" : szi < 0 ? "SHORT" : "FLAT";
      const entryPx = Number(p.entryPx ?? 0);

      const livePx = liveMids.get(coin);
      let markPx = Number.isFinite(livePx) ? livePx : undefined;

        const snapshotValue = Number(p.positionValue ?? 0);
        if ((markPx === undefined || Number.isNaN(markPx)) && szi !== 0 && !Number.isNaN(snapshotValue)) {
          markPx = Math.abs(snapshotValue) / Math.abs(szi);
        }

      let positionValue = snapshotValue;
      if (markPx !== undefined && !Number.isNaN(markPx) && szi !== 0) {
        positionValue = markPx * szi;
      } else if (Number.isFinite(entryPx) && szi !== 0) {
        positionValue = entryPx * szi;
      }

      let upnl = Number(p.unrealizedPnl ?? 0);
      if (markPx !== undefined && !Number.isNaN(markPx) && !Number.isNaN(entryPx) && szi !== 0) {
        upnl = (markPx - entryPx) * szi;
      }

      return [
        coin,
        dir,
        fmtSize(szi),
        fmtPrice(entryPx),
        fmtMoney(positionValue),
        formatSignedDollar(upnl),
      ];
    });
  }

  function renderMarginSummary(summary, withdrawable) {
    if (!summary) {
      marginSummaryEl.innerHTML = "<span class='muted'>No margin summary.</span>";
      return;
    }

    const rows = [
      ["Account Value", fmtMoney(summary.accountValue)],
      ["Notional Exposure", fmtMoney(summary.totalNtlPos)],
      ["Collateral", fmtMoney(summary.totalRawUsd)],
      ["Margin Used", fmtMoney(summary.totalMarginUsed)],
      ["Withdrawable", fmtMoney(withdrawable)],
    ];

    marginSummaryEl.innerHTML = rows
      .map(([label, value]) => `
        <div class="kv-label">${label}</div>
        <div class="kv-value money">${value}</div>
      `)
      .join("");
  }

  function recomputeAndRenderMarginSummary() {
    if (!snapshotMarginSummary) {
      renderMarginSummary(null, snapshotWithdrawable);
      return;
    }

    const base = snapshotMarginSummary;
    const snapshotAV = Number(base.accountValue ?? 0);
    const deltaUpnl = lastComputedUpnlTotal - snapshotUpnlTotal;
    const liveAccountValue = snapshotAV + (Number.isNaN(deltaUpnl) ? 0 : deltaUpnl);

    const summaryLive = {
      ...base,
      accountValue: liveAccountValue,
      totalNtlPos: lastComputedTotalNotional || base.totalNtlPos,
    };

    renderMarginSummary(summaryLive, snapshotWithdrawable);
  }

  function renderPositions(assetPositions) {
    currentAssetPositions = Array.isArray(assetPositions) ? assetPositions : [];
    lastComputedUpnlTotal = 0;
    lastComputedTotalNotional = 0;

    if (!currentAssetPositions.length) {
      positionsBodyEl.innerHTML = "<tr><td colspan='6' class='muted desktop-only'>No open positions.</td></tr>";
      recomputeAndRenderMarginSummary();
      refreshBreakdownIfOpen();
      return;
    }

    positionsBodyEl.innerHTML = currentAssetPositions
      .map((item) => {
        const p = item.position;
        const coin = p.coin;
        const { dex: coinDex, base: coinBase } = splitDexCoin(coin);
        const coinDisplayName = coinBase || coin;
        const { label: spotLabel, iconKey, isSpot } = resolveSpotDisplay(coinDisplayName);
        const spotTagHtml = isSpot ? `<span class="dex-tag spot-tag">spot</span>` : "";
        const szi = Number(p.szi ?? 0);

        const dir = szi > 0 ? "LONG" : szi < 0 ? "SHORT" : "FLAT";
        const dirColor = szi >= 0 ? "#4ade80" : "#fb7185";
        const entryPx = Number(p.entryPx ?? 0);

        const livePx = getLivePriceForCoin(coin);
        let markPx = Number.isFinite(livePx) ? livePx : undefined;

        const snapshotValue = Number(p.positionValue ?? 0);
        if ((markPx === undefined || Number.isNaN(markPx)) && szi !== 0 && !Number.isNaN(snapshotValue)) {
          markPx = Math.abs(snapshotValue) / Math.abs(szi);
        }

        let positionValue = snapshotValue;
        if (markPx !== undefined && !Number.isNaN(markPx) && szi !== 0) {
          positionValue = markPx * szi;
        }

        let upnl = Number(p.unrealizedPnl ?? 0);
        if (markPx !== undefined && !Number.isNaN(markPx) && !Number.isNaN(entryPx) && szi !== 0) {
          upnl = (markPx - entryPx) * szi;
        }

        const currentPriceDisplay =
          markPx !== undefined && !Number.isNaN(markPx) ? fmtPrice(markPx) : "–";

        if (!Number.isNaN(upnl)) lastComputedUpnlTotal += upnl;
        const notional = Math.abs(positionValue);
        if (!Number.isNaN(notional)) lastComputedTotalNotional += notional;

        const upnlFormatted = formatSignedDollarWithPlus(upnl);
        const formattedValue = formatSignedDollar(positionValue);

        const isExpanded = expandedPositions.has(coin);
        let breakdownHtml = "";
        if (isExpanded) {
          const mark = getMarkPriceForCoin(coin);
          const breakdown = buildPositionFillDetails(coin, szi, mark);
          const rowsHtml = breakdown.rows
            .slice()
            .reverse()
            .map(
              (r) => `
              <tr>
                <td class="timestamp">${r.time}</td>
                <td><span class="pill ${sidePillClass(r.sideCode)}">${r.side}</span></td>
                <td class="money">${r.sizeSigned}</td>
                <td class="money">${r.price}</td>
                <td class="money">${r.value}</td>
                <td class="money ${r.upnlRaw >= 0 ? "upnl-pos" : "upnl-neg"}">${r.upnl}</td>
              </tr>
            `
            )
            .join("");

          breakdownHtml = `
            <tr class="position-details">
              <td colspan="7">
                <div class="position-breakdown">
                  <table class="position-subtable">
                    <thead>
                      <tr>
                        <th>Execution Time</th>
                        <th>Side</th>
                        <th>Size</th>
                        <th>Price</th>
                        <th>Notional</th>
                        <th>Unrealized PnL</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${rowsHtml || `<tr><td colspan="6" class="muted">Finding fills for this asset...</td></tr>`}
                      <tr>
                        <td><strong>Net size</strong></td>
                        <td></td>
                        <td class="money"><strong>${fmtSignedSize(breakdown.netSize)}</strong></td>
                        <td></td>
                        <td></td>
                        <td class="money ${breakdown.totalUpnl >= 0 ? "upnl-pos" : "upnl-neg"}">
                          <strong>${Number.isFinite(breakdown.totalUpnl) ? formatSignedDollarWithPlus(breakdown.totalUpnl) : ""}</strong>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                  ${
                    breakdown.matches
                      ? ""
                      : `<div class="position-breakdown-note">Net from listed fills (${fmtSignedSize(
                          breakdown.netSize
                        )}) differs from current exposure (${fmtSignedSize(szi)}); history may be truncated.</div>`
                  }
                </div>
              </td>
            </tr>
          `;
        }

        return `
        <tr class="position-row${isExpanded ? " expanded" : ""}" data-coin="${coin}">
          <td>
            <div class="asset-cell">
              ${coinIconHtml(iconKey, spotLabel)}
              <span>${spotLabel}</span>
              ${spotTagHtml}
              ${coinDex ? `<span class="dex-tag">${coinDex}</span>` : ""}
              <span class="chevron" aria-hidden="true"></span>
            </div>
          </td>
          <td>
            <span class="pill" style="color:${dirColor};border-color:${dirColor}55;background:${dirColor}22;">
              ${dir}
            </span>
          </td>
          <td class="money">${fmtSize(szi)}</td>
          <td class="money">
            <div class="price-stack">
              <span class="current-price">Live: ${currentPriceDisplay}</span>
              <span>Entry: ${fmtPrice(entryPx)}</span>
            </div>
          </td>
          <td class="money">${formattedValue}</td>
          <td class="money ${upnl >= 0 ? "upnl-pos" : "upnl-neg"}">
            ${upnlFormatted}
          </td>
        </tr>
        ${breakdownHtml}
      `;
      })
      .join("");

    recomputeAndRenderMarginSummary();
    refreshBreakdownIfOpen();
  }

  function computeSnapshotUpnlTotal(assetPositions) {
    if (!Array.isArray(assetPositions)) return 0;
    return assetPositions.reduce((sum, item) => {
      const p = item.position;
      const u = Number(p.unrealizedPnl ?? 0);
      return sum + (Number.isNaN(u) ? 0 : u);
    }, 0);
  }

  async function refreshPositionsAndMargin(wallet) {
    try {
      const clearing = await infoClient.clearinghouseState({ user: wallet });
      const { marginSummary, withdrawable, assetPositions } = clearing;
      const mergedPositions = Array.isArray(assetPositions) ? [...assetPositions] : [];

      snapshotMarginSummary = marginSummary || null;
      snapshotWithdrawable = withdrawable;
      snapshotUpnlTotal = computeSnapshotUpnlTotal(mergedPositions);

      renderPositions(mergedPositions);

      // Fetch HIP-3/extra dex positions after main state
      fetchAdditionalDexPositions(wallet).then((extraPositions) => {
        if (!Array.isArray(extraPositions) || extraPositions.length === 0) return;
        const combined = [...mergedPositions, ...extraPositions];
        snapshotUpnlTotal = computeSnapshotUpnlTotal(combined);
        renderPositions(combined);
      });
    } catch (err) {
      console.error("Refresh positions error", err);
      snapshotErrorEl.textContent = "Failed to refresh positions: " + (err?.message || err);
    }
  }

  function renderOpenOrders() {
    const values = Array.from(openOrders.values()).sort((a, b) => (a.oid ?? 0) - (b.oid ?? 0));
    openOrdersCountEl.textContent = values.length.toString();

    const MIN_ROWS = 4;

    // Build real rows
    const rows = values.map((order) => {
      const created = fmtDateTime(order.timestamp);
      const side = order.side ?? "?";
      const coin = resolveCoinName(order.coin, order.asset);
      const orderIdHtml = formatSpotIdHtml(order.oid);
      return `
        <tr>
          <td class="desktop-only">${orderIdHtml}</td>
          <td class="desktop-only"><span class="timestamp">${created}</span></td>
          <td class="asset-cell">${coinCellHtml(coin)}</td>
          <td><span class="pill ${sidePillClass(side)}">${sideLabel(side)}</span></td>
          <td class="money">${fmtSize(order.sz)}</td>
          <td class="money">${fmtLimitPrice(order.limitPx) ?? ""}</td>
        </tr>
      `;
    });

    // If none, show 1 “No open orders.” row, then pad to MIN_ROWS
    if (rows.length === 0) {
      rows.push(`<tr><td colspan="6" class="muted">No open orders.</td></tr>`);
    }

    // Pad with empty rows until we have MIN_ROWS visible rows
    while (rows.length < MIN_ROWS) {
      rows.push(`
        <tr class="placeholder-row">
          <td colspan="6">&nbsp;</td>
        </tr>
      `);
    }

    openOrdersBodyEl.innerHTML = rows.join("");
  }

  function renderCanceledOrders() {
    canceledCountEl.textContent = canceledOrders.length.toString();

    if (canceledOrders.length === 0) {
      canceledOrdersBodyEl.innerHTML = "<tr><td colspan='4' class='muted'>No canceled orders yet.</td></tr>";
      return;
    }

    canceledOrdersBodyEl.innerHTML = canceledOrders
      .map((o) => {
      const created = fmtTimeOnly(o.timestamp);
      const canceledAtTime = fmtTimeOnly(o.statusTimestamp);
      const side = o.side ?? "?";
      const coin = resolveCoinName(o.coin, o.asset);
      const orderIdHtml = formatSpotIdHtml(o.oid);
      return `
        <tr class="flash-cancel">
          <td class="desktop-only">${orderIdHtml}</td>
          <td class="desktop-only"><span class="timestamp">${created}</span></td>
          <td>
            <span class="mobile-only timestamp">${canceledAtTime}</span>
            <span class="desktop-only timestamp">${canceledAtTime}</span>
          </td>
          <td class="asset-cell">${coinCellHtml(coin)}</td>
          <td><span class="pill ${sidePillClass(side)}">${sideLabel(side)}</span></td>  
          <td class="money">${fmtSize(o.sz)}</td>
          <td class="mobile-only money">${fmtLimitPrice(o.limitPx) ?? ""}</td>
        </tr>
      `;
      })
      .join("");
  }

  function renderFills() {
    if (fills.length === 0) {
      fillsBodyEl.innerHTML = "<tr><td colspan='7' class='muted'>Waiting for fills...</td></tr>";
      if (fillsCountEl) fillsCountEl.textContent = "0";
      return;
    }

    fillsBodyEl.innerHTML = fills
      .map((fill) => {
        const tTime = fmtTimeOnly(fill.time);
        const total = computeTotal(fill);
        const side = fill.side ?? "?";
        const orderIdHtml = formatSpotIdHtml(fill.oid);
        const coin = resolveCoinName(fill.coin, fill.asset ?? fill.symbol ?? fill.sym);
        return `
        <tr class="flash">
          <td class="desktop-only">${orderIdHtml}</td>
          <td>
            <span class="mobile-only timestamp">${tTime}</span>
            <span class="desktop-only timestamp">${tTime}</span>
          </td>
          <td><span class="pill ${sidePillClass(side)}">${sideLabel(side)}</span></td>
          <td class="asset-cell">${coinCellHtml(coin)}</td>
          <td class="money">${fmtSize(fill.sz)}</td>
          <td class="money">${fmtPrice(fill.px) ?? ""}</td>
          <td class="desktop-only money">${total ? "$" + total : ""}</td>
        </tr>
      `;
      })
      .join("");

    if (fillsCountEl) fillsCountEl.textContent = `${fills.length}`;
  }

  function renderHistoricalFills() {
    if (!historicalFillsBodyEl) return;

    if (historicalFills.length === 0) {
      historicalFillsBodyEl.innerHTML = "<tr><td colspan='6' class='muted'>No historical fills found.</td></tr>";
      if (historicalFillsCountEl) historicalFillsCountEl.textContent = "0";
      return;
    }

    const filtered = historicalFills.filter((fill) => {
      const sz = Number(fill.sz ?? fill.size ?? 0);
      const px = Number(fill.px ?? fill.price ?? 0);
      const val = sz * px;
      return !(Number.isFinite(val) && Math.abs(val) < 0.0000001);
    });

    historicalFillsBodyEl.innerHTML = filtered
      .map((fill) => {
        const t = fmtDateTime(fill.time ?? fill.timestamp);
        const total = computeTotal(fill);
        const side = fill.side ?? (fill.isBuy ? "B" : "S") ?? "?";
        const orderIdHtml = formatSpotIdHtml(fill.oid ?? "");
        const coin = resolveCoinName(fill.coin ?? "", fill.asset ?? fill.symbol ?? fill.sym);
        return `
        <tr>
          <td class="desktop-only">${orderIdHtml}</td>
          <td><span class="timestamp">${t}</span></td>
          <td><span class="pill ${sidePillClass(side)}">${sideLabel(side)}</span></td>
          <td class="asset-cell">${coinCellHtml(coin)}</td>
          <td class="money">${fmtSize(fill.sz ?? fill.size)}</td>
          <td class="money">${fmtPrice(fill.px ?? fill.price) ?? ""}</td>
        </tr>
      `;
      })
      .join("");

    if (historicalFillsCountEl) historicalFillsCountEl.textContent = `${filtered.length}`;
  }

  function pickOrderId(entry, order) {
    return (
      order?.oid ??
      order?.orderId ??
      order?.order_id ??
      order?.id ??
      entry?.oid ??
      entry?.orderId ??
      entry?.order_id ??
      entry?.id ??
      ""
    );
  }

  function normalizeHistoricalOrder(entry) {
    const o = entry?.order ?? entry ?? {};
    const status = entry?.status ?? o.status ?? "";
    const statusTimestamp = entry?.statusTimestamp ?? o.statusTimestamp ?? o.timestamp ?? null;

    return {
      oid: pickOrderId(entry, o),
      coin: o.coin,
      side: o.side,
      limitPx: o.limitPx ?? o.px,
      sz: o.origSz ?? o.sz,
      timestamp: o.timestamp,
      status,
      statusTimestamp,
      raw: entry,
    };
  }

  function buildLiveOrdersRowsForExport() {
    const values = Array.from(openOrders.values());
    if (!values.length) return [];

    return values
      .sort((a, b) => (a.oid ?? 0) - (b.oid ?? 0))
      .map((order) => {
        const side = order.side ?? "?";
        return [
          order.oid ?? "",
          fmtDateTime(order.timestamp),
          sideLabel(side),
          order.coin ?? "",
          fmtSize(order.sz),
          fmtLimitPrice(order.limitPx) ?? "",
          computeTotal(order) ? `$${computeTotal(order)}` : "",
        ];
      });
  }

  function buildHistoricalOrdersRowsForExport() {
    if (!Array.isArray(historicalOrders) || historicalOrders.length === 0) return [];
    return historicalOrders.map((entry) => {
      const o = normalizeHistoricalOrder(entry);
      const side = o.side ?? (o.isBuy ? "B" : "S") ?? "?";
      return [
        o.oid ?? "",
        fmtDateTime(o.timestamp),
        sideLabel(side),
        o.coin ?? "",
        fmtSize(o.sz ?? o.size),
        fmtLimitPrice(o.limitPx) ?? "",
        computeTotal(o) ? `$${computeTotal(o)}` : "",
        o.status ?? "",
      ];
    });
  }

  function buildLiveFillsRowsForExport() {
    if (!Array.isArray(fills) || fills.length === 0) return [];
    return fills.map((fill) => {
      const side = fill.side ?? "?";
      return [
        fill.oid ?? "",
        fmtDateTime(fill.time ?? fill.timestamp),
        sideLabel(side),
        fill.coin ?? "",
        fmtSize(fill.sz),
        fmtPrice(fill.px) ?? "",
        computeTotal(fill) ? `$${computeTotal(fill)}` : "",
      ];
    });
  }

  function buildHistoricalFillsRowsForExport() {
    if (!Array.isArray(historicalFills) || historicalFills.length === 0) return [];
    return historicalFills.map((fill) => {
      const side = fill.side ?? (fill.isBuy ? "B" : "S") ?? "?";
      return [
        fill.oid ?? "",
        fmtDateTime(fill.time ?? fill.timestamp),
        sideLabel(side),
        fill.coin ?? "",
        fmtSize(fill.sz ?? fill.size),
        fmtPrice(fill.px ?? fill.price) ?? "",
        computeTotal(fill) ? `$${computeTotal(fill)}` : "",
      ];
    });
  }

  function buildPortfolioSummaryRows() {
    if (!snapshotMarginSummary) return [["Status", "Not loaded"]];

    return [
      ["Account Value", fmtMoney(snapshotMarginSummary.accountValue)],
      ["Notional Exposure", fmtMoney(snapshotMarginSummary.totalNtlPos)],
      ["Collateral", fmtMoney(snapshotMarginSummary.totalRawUsd)],
      ["Margin Used", fmtMoney(snapshotMarginSummary.totalMarginUsed)],
      ["Withdrawable", fmtMoney(snapshotWithdrawable)],
    ];
  }

  async function ensureHistoricalDataLoaded() {
    if (!currentWallet) return;
    const tasks = [];
    if (!historicalOrdersLoaded) tasks.push(loadHistoricalOrders(currentWallet));
    if (!historicalFillsLoaded) tasks.push(loadHistoricalFills(currentWallet));
    if (tasks.length) await Promise.all(tasks);
  }

  function toColumnName(idx) {
    let n = idx + 1;
    let name = "";
    while (n > 0) {
      const rem = (n - 1) % 26;
      name = String.fromCharCode(65 + rem) + name;
      n = Math.floor((n - 1) / 26);
    }
    return name;
  }

  function buildSheetXml(rows) {
    const safeRows = (rows && rows.length ? rows : [["No data"]]).map((r) =>
      Array.isArray(r) ? r : [r]
    );

    const rowXml = safeRows
      .map((row, rowIdx) => {
        const cells = row
          .map((cell, colIdx) => {
            const r = `${toColumnName(colIdx)}${rowIdx + 1}`;
            return `<c r="${r}" t="inlineStr"><is><t>${xmlEscape(cell)}</t></is></c>`;
          })
          .join("");
        return `<row r="${rowIdx + 1}">${cells}</row>`;
      })
      .join("");

    return (
      `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>` +
      `<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">` +
      `<sheetData>${rowXml}</sheetData>` +
      `</worksheet>`
    );
  }

  function buildSheets() {
    const generatedAt = fmtDateTime(Date.now());
    return [
      { name: "Metadata", rows: [["Wallet", "Generated At", "Source"], [currentWallet || "", generatedAt, "https://hypermonitor.org/"]] },
      { name: "Portfolio Summary", rows: [["Metric", "Value"], ...buildPortfolioSummaryRows()] },
      {
        name: "Positions",
        rows: [
          ["Asset", "Side", "Size", "Avg Entry", "Notional", "Unrealized PnL"],
          ...buildPositionsRowsForExport(),
        ],
      },
      {
        name: "Live Orders",
        rows: [
          ["Order ID", "Date/Time", "Side", "Asset", "Size", "Limit Price", "Notional"],
          ...buildLiveOrdersRowsForExport(),
        ],
      },
      {
        name: "Historical Orders",
        rows: [
          ["Order ID", "Date/Time", "Side", "Asset", "Size", "Limit Price", "Notional", "Status"],
          ...buildHistoricalOrdersRowsForExport(),
        ],
      },
      {
        name: "Live Trades",
        rows: [
          ["Order ID", "Date/Time", "Side", "Asset", "Size", "Price", "Notional"],
          ...buildLiveFillsRowsForExport(),
        ],
      },
      {
        name: "Historical Trades",
        rows: [
          ["Order ID", "Date/Time", "Side", "Asset", "Size", "Price", "Notional"],
          ...buildHistoricalFillsRowsForExport(),
        ],
      },
    ];
  }

  function buildWorkbookXml(sheets) {
    const sheetsXml = sheets
      .map(
        (sheet, idx) =>
          `<sheet name="${xmlEscape(sheet.name)}" sheetId="${idx + 1}" r:id="rId${idx + 1}"/>`
      )
      .join("");

    return (
      `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>` +
      `<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" ` +
      `xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">` +
      `<sheets>${sheetsXml}</sheets>` +
      `</workbook>`
    );
  }

  function buildWorkbookRels(sheets) {
    const relsXml = sheets
      .map(
        (_sheet, idx) =>
          `<Relationship Id="rId${idx + 1}" ` +
          `Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" ` +
          `Target="worksheets/sheet${idx + 1}.xml"/>`
      )
      .join("");

    return (
      `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>` +
      `<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">` +
      relsXml +
      `</Relationships>`
    );
  }

  function buildRootRels() {
    return (
      `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>` +
      `<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">` +
      `<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>` +
      `</Relationships>`
    );
  }

  function buildContentTypes(sheets) {
    const sheetOverrides = sheets
      .map(
        (_sheet, idx) =>
          `<Override PartName="/xl/worksheets/sheet${idx + 1}.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/>`
      )
      .join("");

    return (
      `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>` +
      `<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">` +
      `<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>` +
      `<Default Extension="xml" ContentType="application/xml"/>` +
      `<Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>` +
      sheetOverrides +
      `</Types>`
    );
  }

  const CRC_TABLE = (() => {
    const table = new Uint32Array(256);
    for (let n = 0; n < 256; n++) {
      let c = n;
      for (let k = 0; k < 8; k++) {
        c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1;
      }
      table[n] = c >>> 0;
    }
    return table;
  })();

  function crc32Uint8(data) {
    let crc = 0xffffffff;
    for (let i = 0; i < data.length; i++) {
      crc = CRC_TABLE[(crc ^ data[i]) & 0xff] ^ (crc >>> 8);
    }
    return (crc ^ 0xffffffff) >>> 0;
  }

  function createZip(files) {
    const encoder = new TextEncoder();
    let offset = 0;
    const localChunks = [];
    const centralChunks = [];

    files.forEach((file) => {
      const nameBytes = encoder.encode(file.path);
      const dataBytes = typeof file.data === "string" ? encoder.encode(file.data) : file.data;
      const crc = crc32Uint8(dataBytes);

      const local = new Uint8Array(30 + nameBytes.length + dataBytes.length);
      const lv = new DataView(local.buffer);
      lv.setUint32(0, 0x04034b50, true);
      lv.setUint16(4, 20, true); // version needed to extract
      lv.setUint16(6, 0, true); // flags
      lv.setUint16(8, 0, true); // compression (0 = store)
      lv.setUint16(10, 0, true); // mod time
      lv.setUint16(12, 0, true); // mod date
      lv.setUint32(14, crc, true);
      lv.setUint32(18, dataBytes.length, true); // compressed size
      lv.setUint32(22, dataBytes.length, true); // uncompressed size
      lv.setUint16(26, nameBytes.length, true);
      lv.setUint16(28, 0, true); // extra length
      local.set(nameBytes, 30);
      local.set(dataBytes, 30 + nameBytes.length);
      localChunks.push(local);

      const central = new Uint8Array(46 + nameBytes.length);
      const cv = new DataView(central.buffer);
      cv.setUint32(0, 0x02014b50, true);
      cv.setUint16(4, 0x031e, true); // version made by
      cv.setUint16(6, 20, true); // version needed
      cv.setUint16(8, 0, true); // flags
      cv.setUint16(10, 0, true); // compression
      cv.setUint16(12, 0, true); // mod time
      cv.setUint16(14, 0, true); // mod date
      cv.setUint32(16, crc, true);
      cv.setUint32(20, dataBytes.length, true);
      cv.setUint32(24, dataBytes.length, true);
      cv.setUint16(28, nameBytes.length, true);
      cv.setUint16(30, 0, true); // extra length
      cv.setUint16(32, 0, true); // file comment length
      cv.setUint16(34, 0, true); // disk number start
      cv.setUint16(36, 0, true); // internal file attrs
      cv.setUint32(38, 0, true); // external file attrs
      cv.setUint32(42, offset, true); // relative offset
      central.set(nameBytes, 46);
      centralChunks.push(central);

      offset += local.length;
    });

    const centralSize = centralChunks.reduce((sum, chunk) => sum + chunk.length, 0);
    const end = new Uint8Array(22);
    const ev = new DataView(end.buffer);
    ev.setUint32(0, 0x06054b50, true);
    ev.setUint16(4, 0, true); // disk number
    ev.setUint16(6, 0, true); // central dir disk
    ev.setUint16(8, files.length, true); // entries this disk
    ev.setUint16(10, files.length, true); // total entries
    ev.setUint32(12, centralSize, true); // central size
    ev.setUint32(16, offset, true); // central offset
    ev.setUint16(20, 0, true); // comment length

    const totalSize = offset + centralSize + end.length;
    const out = new Uint8Array(totalSize);

    let pointer = 0;
    localChunks.forEach((chunk) => {
      out.set(chunk, pointer);
      pointer += chunk.length;
    });

    let centralPointer = offset;
    centralChunks.forEach((chunk) => {
      out.set(chunk, centralPointer);
      centralPointer += chunk.length;
    });

    out.set(end, centralPointer);
    return out;
  }

  function buildXlsxFile() {
    const sheets = buildSheets();
    const sheetFiles = sheets.map((sheet, idx) => ({
      path: `xl/worksheets/sheet${idx + 1}.xml`,
      data: buildSheetXml(sheet.rows),
    }));

    const files = [
      { path: "[Content_Types].xml", data: buildContentTypes(sheets) },
      { path: "_rels/.rels", data: buildRootRels() },
      { path: "xl/workbook.xml", data: buildWorkbookXml(sheets) },
      { path: "xl/_rels/workbook.xml.rels", data: buildWorkbookRels(sheets) },
      ...sheetFiles,
    ];

    return createZip(files);
  }

  async function triggerExcelDownload() {
    try {
      await ensureHistoricalDataLoaded();

      const archive = buildXlsxFile();
      const walletSlug = currentWallet || "wallet";
      const filename = `hypermonitor-${walletSlug}.xlsx`;
      const blob = new Blob([archive], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      link.remove();
      URL.revokeObjectURL(url);
    } catch (err) {
      console.error("Export error", err);
      alert("Failed to export Excel. See console for details.");
    }
  }

  function renderHistoricalOrders() {
    if (!historicalOrdersBodyEl) return;

    const totalCount = historicalOrders.length;
    const sideFilter = historicalSideFilterEl?.value || "all";
    const statusFilter = (historicalStatusFilterEl?.value || "all").toLowerCase();
    const assetFilter = (historicalAssetFilterEl?.value || "").trim().toLowerCase();

    const filtered = historicalOrders
      .map(normalizeHistoricalOrder)
      .filter((o) => {
        const side = o.side ?? (o.isBuy ? "B" : "S");
        const status = (o.status ?? "").toLowerCase();
        const coin = (o.coin ?? "").toLowerCase();

        if (sideFilter !== "all" && side !== sideFilter) return false;
        if (statusFilter !== "all" && !status.includes(statusFilter)) return false;
        if (assetFilter && !coin.includes(assetFilter)) return false;

        return true;
      });

    if (historicalOrdersCountEl) {
      if (historicalOrdersLoaded) historicalOrdersCountEl.textContent = `${filtered.length} / ${totalCount}`;
      else historicalOrdersCountEl.textContent = "–";
    }

    if (filtered.length === 0) {
      historicalOrdersBodyEl.innerHTML = "<tr><td colspan='7' class='muted'>No orders match the current filters.</td></tr>";
      return;
    }

    historicalOrdersBodyEl.innerHTML = filtered
      .map((o) => {
        const created = fmtDateTime(o.timestamp);
        const side = o.side ?? (o.isBuy ? "B" : "S");
        const status = o.status ?? "";
        const orderIdHtml = formatSpotIdHtml(o.oid ?? "");
        const coin = resolveCoinName(o.coin ?? "", o.asset ?? o.symbol ?? o.sym);

        return `
        <tr>
          <td>${orderIdHtml}</td>
          <td><span class="timestamp">${created}</span></td>
          <td><span class="pill ${sidePillClass(side)}">${sideLabel(side)}</span></td>
          <td class="asset-cell">${coinCellHtml(coin)}</td>
          <td class="money">${fmtSize(o.sz ?? o.size)}</td>
          <td class="money">${fmtLimitPrice(o.limitPx) ?? ""}</td>
          <td>${status}</td>
        </tr>
      `;
      })
      .join("");
  }

  async function loadHistoricalOrders(wallet) {
    if (!historicalOrdersBodyEl) return;

    historicalOrdersLoaded = false;
    if (historicalOrdersCountEl) historicalOrdersCountEl.textContent = "–";
    historicalOrdersBodyEl.innerHTML = "<tr><td colspan='7' class='muted'>Loading historical orders…</td></tr>";

    try {
      const body = { type: "historicalOrders", user: wallet };

      const res = await fetch(PORTFOLIO_API_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
      });

      if (!res.ok) throw new Error(`Historical orders error: ${res.status} ${res.statusText}`);

      const data = await res.json();

      historicalOrders.length = 0;
      if (Array.isArray(data)) {
        data.sort((a, b) => {
          const na = normalizeHistoricalOrder(a);
          const nb = normalizeHistoricalOrder(b);
          return (nb.timestamp ?? 0) - (na.timestamp ?? 0);
        });
        historicalOrders.push(...data);
      }

      historicalOrdersLoaded = true;
      renderHistoricalOrders();
    } catch (err) {
      console.error("Historical orders error", err);
      historicalOrdersBodyEl.innerHTML = "<tr><td colspan='7' class='muted'>Failed to load historical orders.</td></tr>";
    }
  }

  async function loadHistoricalFills(wallet) {
    if (!historicalFillsBodyEl) return;

    historicalFillsLoaded = false;
    if (historicalFillsCountEl) historicalFillsCountEl.textContent = "–";
    historicalFillsBodyEl.innerHTML = "<tr><td colspan='6' class='muted'>Loading historical fills…</td></tr>";

    try {
      const fillsData = await infoClient.userFills({ user: wallet, aggregateByTime: true });

      historicalFills.length = 0;
      if (Array.isArray(fillsData)) {
        fillsData
          .sort((a, b) => (Number(b.time ?? b.timestamp ?? 0) - Number(a.time ?? a.timestamp ?? 0)))
          .forEach((f) => historicalFills.push(f));
      }

      historicalFillsLoaded = true;
      renderHistoricalFills();
    } catch (err) {
      console.error("Historical fills error", err);
      if (historicalFillsBodyEl) {
        historicalFillsBodyEl.innerHTML = "<tr><td colspan='6' class='muted'>Failed to load historical fills.</td></tr>";
      }
      if (fillsErrorEl) fillsErrorEl.textContent = "Failed to load historical fills: " + (err?.message || err);
    }
  }

  function resetState() {
    openOrders.clear();
    canceledOrders.length = 0;
    fills.length = 0;
    currentAssetPositions = [];
    liveMids.clear();
    snapshotMarginSummary = null;
    snapshotWithdrawable = null;
    snapshotUpnlTotal = 0;
    lastComputedUpnlTotal = 0;
    lastComputedTotalNotional = 0;

    historicalOrders.length = 0;
    historicalOrdersLoaded = false;
    historicalFills.length = 0;
    historicalFillsLoaded = false;

    openOrdersCountEl.textContent = "–";
    canceledCountEl.textContent = "–";
    if (historicalOrdersCountEl) historicalOrdersCountEl.textContent = "–";
    if (historicalFillsCountEl) historicalFillsCountEl.textContent = "–";
    if (fillsCountEl) fillsCountEl.textContent = "–";

    ordersErrorEl.textContent = "";
    fillsErrorEl.textContent = "";
    snapshotErrorEl.textContent = "";

    openOrdersBodyEl.innerHTML = "<tr><td colspan='7' class='muted'>No open orders.</td></tr>";
    canceledOrdersBodyEl.innerHTML = "<tr><td colspan='6' class='muted'>No canceled orders yet.</td></tr>";
    fillsBodyEl.innerHTML = "<tr><td colspan='7' class='muted'>Waiting for fills…</td></tr>";

    if (historicalOrdersBodyEl) {
      historicalOrdersBodyEl.innerHTML = "<tr><td colspan='7' class='muted'>Loading historical orders…</td></tr>";
    }
    if (historicalFillsBodyEl) {
      historicalFillsBodyEl.innerHTML = "<tr><td colspan='6' class='muted'>Loading historical fills…</td></tr>";
    }

    positionsBodyEl.innerHTML = "<tr><td colspan='6' class='muted desktop-only'>Loading…</td><td colspan='4' class='muted mobile-only'>Loading…</td></tr>";
    marginSummaryEl.innerHTML = "";

    refreshBreakdownIfOpen();
  }

  async function initClients() {
    if (!infoClient) infoClient = new hl.InfoClient({ transport: new hl.HttpTransport() });
    if (!subsClient) subsClient = new hl.SubscriptionClient({ transport: new hl.WebSocketTransport() });
  }

  async function ensurePriceStream() {
    if (!subsClient || allMidsSub) return;
    try {
      allMidsSub = await subsClient.allMids((event) => {
        let mids = event;
        if (event && typeof event === "object") {
          if ("data" in event && event.data) mids = event.data;
          if (mids && typeof mids === "object" && "mids" in mids) mids = mids.mids;
        }
        if (!mids || typeof mids !== "object") return;

        for (const [coin, midStr] of Object.entries(mids)) {
          const px = Number(midStr);
          if (!Number.isNaN(px)) liveMids.set(coin, px);
        }

        if (currentAssetPositions.length) renderPositions(currentAssetPositions);
      });
    } catch (err) {
      console.error("allMids subscription error", err);
    }
  }

  async function loadSnapshot(wallet) {
    try {
      snapshotErrorEl.textContent = "";
      const clearing = await infoClient.clearinghouseState({ user: wallet });
      const { marginSummary, withdrawable, assetPositions } = clearing;
      const mergedPositions = Array.isArray(assetPositions) ? [...assetPositions] : [];

      snapshotMarginSummary = marginSummary || null;
      snapshotWithdrawable = withdrawable;
      snapshotUpnlTotal = computeSnapshotUpnlTotal(mergedPositions);

      renderPositions(mergedPositions);

      // Fetch HIP-3/extra dex positions after first paint
      fetchAdditionalDexPositions(wallet).then((extraPositions) => {
        if (!Array.isArray(extraPositions) || extraPositions.length === 0) return;
        const combined = [...mergedPositions, ...extraPositions];
        snapshotUpnlTotal = computeSnapshotUpnlTotal(combined);
        renderPositions(combined);
      });

      const existingOpen = await infoClient.openOrders({ user: wallet });
      openOrders.clear();
      existingOpen.forEach((order) => openOrders.set(order.oid, order));
      renderOpenOrders();
    } catch (err) {
      console.error("Snapshot error", err);
      snapshotErrorEl.textContent = "Failed to load initial snapshot: " + (err?.message || err);
    }
  }

  async function startStreams(wallet) {
    try {
      ordersErrorEl.textContent = "";
      fillsErrorEl.textContent = "";

      if (orderUpdatesSub) {
        try { await orderUpdatesSub.unsubscribe(); } catch (e) { console.warn("Error unsubscribing orderUpdates", e); }
        orderUpdatesSub = null;
      }
      if (userEventsSub) {
        try { await userEventsSub.unsubscribe(); } catch (e) { console.warn("Error unsubscribing userEvents", e); }
        userEventsSub = null;
      }

      orderUpdatesSub = await subsClient.orderUpdates({ user: wallet }, (event) => {
        try {
          const updates = event?.data ?? event;
          if (!Array.isArray(updates)) return;

          updates.forEach((entry) => {
            const status = entry.status;
            const orderWrapper = entry.order;
            const statusTimestamp = entry.statusTimestamp;
            if (!orderWrapper) return;

            const order = { ...orderWrapper, status, statusTimestamp };

            if (status === "open") {
              openOrders.set(order.oid, order);
              renderOpenOrders();
            } else if (status === "canceled") {
              openOrders.delete(order.oid);
              renderOpenOrders();
              canceledOrders.unshift(order);
              renderCanceledOrders();
            }
          });
        } catch (err) {
          console.error("orderUpdates handler error", err);
          ordersErrorEl.textContent = "Error processing order updates: " + (err?.message || err);
        }
      });

      userEventsSub = await subsClient.userEvents({ user: wallet }, (event) => {
        try {
          const data = event?.data ?? event;
          const fillsArr = Array.isArray(data?.fills) ? data.fills : [];
          if (fillsArr.length === 0) return;

          fillsArr.forEach((fill) => fills.unshift(fill));
          if (fills.length > MAX_FILL_ROWS) fills.length = MAX_FILL_ROWS;
          renderFills();

          if (currentWallet) refreshPositionsAndMargin(currentWallet);
        } catch (err) {
          console.error("userEvents handler error", err);
          fillsErrorEl.textContent = "Error processing fills: " + (err?.message || err);
        }
      });

      setStatus("connected", "Connected to");
    } catch (err) {
      console.error("WebSocket setup error", err);
      setStatus("error", "WebSocket error");
      ordersErrorEl.textContent = "Failed to start real-time streams: " + (err?.message || err);
    }
  }

  function isValidAddress(addr) {
    return /^0x[a-fA-F0-9]{40}$/.test(addr);
  }

  function resetPortfolioSection() {
    portfolioData = null;
    portfolioErrorEl.textContent = "";
    portfolioLoadingEl.textContent = "Loading performance data…";
    if (portfolioCharts.equity) {
      portfolioCharts.equity.destroy();
      portfolioCharts.pnl.destroy();
      portfolioCharts.deposits.destroy();
      portfolioCharts.equity = null;
      portfolioCharts.pnl = null;
      portfolioCharts.deposits = null;
    }
  }

  async function fetchPortfolio(wallet) {
    const body = { type: "portfolio", user: wallet };

    const res = await fetch(PORTFOLIO_API_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });

    if (!res.ok) throw new Error(`Portfolio API error: ${res.status} ${res.statusText}`);

    const raw = await res.json();

    if (Array.isArray(raw)) {
      const obj = {};
      for (const [key, value] of raw) obj[key] = value;
      return obj;
    }

    return raw;
  }

  function buildViewFromSection(section) {
    if (!section) return null;
    const equityHist = section.accountValueHistory || [];
    const pnlHist = section.pnlHistory || [];
    if (!equityHist.length || !pnlHist.length) return null;

    const times = equityHist.map(([t]) => new Date(Number(t)));
    const equity = equityHist.map(([, v]) => Number(v ?? 0));
    const pnl = pnlHist.map(([, v]) => Number(v ?? 0));

    const rawDeposits = equity.map((eq, i) => (eq - (pnl[i] ?? 0)));

    const base = Number.isFinite(rawDeposits[0]) ? rawDeposits[0] : 0;
    const deposits = rawDeposits.map((d) => Math.round((d - base) * 100) / 100);

    return { times, equity, pnl, deposits };
  }

  function getPortfolioView(rangeKey) {
    if (!portfolioData) return null;
    const primary = portfolioData[rangeKey];
    const fallback = portfolioData.allTime;
    return buildViewFromSection(primary) || buildViewFromSection(fallback) || null;
  }

  function buildLabels(times, rangeKey) {
    const showTimeOnly = rangeKey === "day";
    return times.map((d) => {
      if (!(d instanceof Date) || isNaN(d.getTime())) return "";
      if (showTimeOnly) return d.toLocaleTimeString(undefined, { hour: "2-digit", minute: "2-digit" });
      return d.toLocaleDateString();
    });
  }

  function getChartGridColor() {
    return document.body.classList.contains("light")
      ? "rgba(31,41,55,0.2)"
      : "rgba(31,41,55,0.6)";
  }

  function getChartTextColor() {
    return document.body.classList.contains("light") ? "#0f172a" : "#e5e7eb";
  }

  function buildPositionBreakdown() {
    if (!Array.isArray(currentAssetPositions) || currentAssetPositions.length === 0) return [];

    return currentAssetPositions
      .map((item) => {
        const p = item.position;
        const coin = p.coin;
        const { base: coinBase } = splitDexCoin(coin);
        const szi = Number(p.szi ?? 0);
        if (!coin || !Number.isFinite(szi) || szi === 0) return null;

        const entryPx = Number(p.entryPx ?? 0);
        const livePx = getLivePriceForCoin(coin);
        let markPx = Number.isFinite(livePx) ? livePx : undefined;

        const snapshotValue = Number(p.positionValue ?? 0);
        if ((markPx === undefined || Number.isNaN(markPx)) && !Number.isNaN(snapshotValue) && szi !== 0) {
          markPx = Math.abs(snapshotValue) / Math.abs(szi);
        }

        let positionValue = snapshotValue;
        if (markPx !== undefined && !Number.isNaN(markPx) && szi !== 0) {
          positionValue = markPx * szi;
        } else if (Number.isFinite(entryPx) && szi !== 0) {
          positionValue = entryPx * szi;
        }

        const valueAbs = Math.abs(positionValue);
        if (!Number.isFinite(valueAbs) || valueAbs === 0) return null;

        const dirLabel = szi > 0 ? "" : " (short)";
        const labelCoin = coinBase || coin;
        return { label: `${labelCoin}${dirLabel}`, value: valueAbs, coin: labelCoin };
      })
      .filter(Boolean);
  }

  function updatePortfolioBreakdownChart() {
    if (!portfolioDoughnutCanvas) return;

    const positions = buildPositionBreakdown();
    const positionsValue = positions.reduce((sum, p) => sum + (p?.value ?? 0), 0);
    const withdrawableValue = Math.max(0, getWithdrawableAmount());

    if (positionsValueStatEl) positionsValueStatEl.textContent = fmtMoney(positionsValue);
    if (withdrawableValueStatEl) withdrawableValueStatEl.textContent = fmtMoney(withdrawableValue);

    const rawSeries = [
      ...positions,
      { label: "Withdrawable", value: withdrawableValue },
    ].filter((item) => Number.isFinite(item.value));

    const dataValues = rawSeries.map((p) => Math.max(0, p.value));
    const labels = rawSeries.map((p) => p.label);
    const realValues = rawSeries.map((p) => p.value);

    const allZero = dataValues.every((v) => v === 0);
    const displayValues = allZero ? dataValues.map(() => 1) : dataValues;
    const totalReal = realValues.reduce((sum, v) => sum + (Number.isFinite(v) ? Math.max(0, v) : 0), 0);

    const coinColors = {
      BTC: "#f7931a",
      ETH: "#1c3f91",
      SOL: "#6f42c1",
      BNB: "#f0b90b",
      HYPE: "#0b5c2f",
      LINK: "#2a5ada",
    };
    const palette = ["#38bdf8", "#26d97f", "#a78bfa", "#f472b6", "#facc15", "#fb7185", "#22d3ee", "#f59e0b"];
    const colors = rawSeries.map((item, i) => {
      const coin = (item.coin || "").toUpperCase();
      if (coin && coinColors[coin]) return coinColors[coin];
      return palette[i % palette.length];
    });
    const textColor = getChartTextColor();
    const tooltipBg = document.body.classList.contains("light") ? "rgba(15,23,42,0.85)" : "rgba(0,0,0,0.7)";

    if (!portfolioBreakdownChart.chart) {
      portfolioBreakdownChart.chart = new Chart(portfolioDoughnutCanvas.getContext("2d"), {
        type: "doughnut",
        data: {
          labels,
          datasets: [
            {
              data: displayValues,
              realValues: realValues,
              backgroundColor: colors,
              borderColor: colors.map((c) => c + "99"),
              borderWidth: 1,
              hoverOffset: 6,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          cutout: "62%",
          plugins: {
            legend: { position: "bottom", labels: { color: textColor } },
            tooltip: {
              backgroundColor: tooltipBg,
              borderColor: "rgba(148, 163, 184, 0.4)",
              borderWidth: 1,
              displayColors: false,
              callbacks: {
                label: (ctx) => {
                  const real = ctx.dataset.realValues?.[ctx.dataIndex];
                  const val = Number.isFinite(real) ? real : ctx.parsed;
                  const pct = totalReal > 0 ? (Math.max(0, val) / totalReal) * 100 : 0;
                  return `${ctx.label}: ${fmtMoney(val)} (${pct.toFixed(1)}%)`;
                },
              },
            },
          },
        },
      });
    } else {
      const chart = portfolioBreakdownChart.chart;
      chart.data.labels = labels;
      chart.data.datasets[0].data = displayValues;
      chart.data.datasets[0].realValues = realValues;
      chart.data.datasets[0].backgroundColor = colors;
      chart.data.datasets[0].borderColor = colors.map((c) => c + "99");
      chart.options.plugins.legend.labels.color = textColor;
      chart.options.plugins.tooltip.backgroundColor = tooltipBg;
      chart.update();
    }
  }

  function refreshBreakdownIfOpen() {
    if (portfolioModalEl && portfolioModalEl.classList.contains("open")) {
      updatePortfolioBreakdownChart();
    }
  }

  function updateBreakdownTheme() {
    if (!portfolioBreakdownChart.chart) return;
    const textColor = getChartTextColor();
    const tooltipBg = document.body.classList.contains("light") ? "rgba(15,23,42,0.85)" : "rgba(0,0,0,0.7)";
    portfolioBreakdownChart.chart.options.plugins.legend.labels.color = textColor;
    portfolioBreakdownChart.chart.options.plugins.tooltip.backgroundColor = tooltipBg;
    portfolioBreakdownChart.chart.update();
  }

  function openPortfolioModal() {
    if (!portfolioModalEl) return;
    portfolioModalEl.classList.add("open");
    updatePortfolioBreakdownChart();
  }

  function closePortfolioModal() {
    if (!portfolioModalEl) return;
    portfolioModalEl.classList.remove("open");
  }

  function createLineChart(ctx, label, data, color) {
    return new Chart(ctx, {
      type: "line",
      data: {
        labels: data.labels,
        datasets: [
          {
            label,
            data: data.values,
            borderColor: color,
            backgroundColor: color + "2a",
            pointRadius: 0,
            borderWidth: 1.7,
            tension: 0.25,
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: "index", intersect: false },
        plugins: {
          legend: { display: false },
          tooltip: {
            backgroundColor: "rgba(15,23,42,0.5)",
            borderColor: "rgba(148,163,184,0.5)",
            borderWidth: 1,
            titleColor: "#e5e7eb",
            bodyColor: "#e5e7eb",
            displayColors: false,
            padding: 8,
            cornerRadius: 6,
            callbacks: {
              title: (items) => (items && items.length ? (items[0].label || "") : ""),
              label: (ctx) => {
                const v = Number(ctx.parsed.y ?? 0);
                const abs = Math.abs(v).toLocaleString(undefined, { maximumFractionDigits: 2 });
                return v < 0 ? `-$${abs}` : `$${abs}`;
              },
            },
          },
        },
        scales: {
          x: { ticks: { maxTicksLimit: 6 }, grid: { display: false } },
          y: {
            ticks: {
              // ✅ -$1000 not $-1000
              callback: (value) => {
                const n = Number(value);
                if (!Number.isFinite(n)) return "";
                const abs = Math.abs(n).toLocaleString(undefined, { maximumFractionDigits: 0 });
                return n < 0 ? `-$${abs}` : `$${abs}`;
              },
              maxTicksLimit: 6,
            },
            grid: { color: getChartGridColor() },
          },
        },
      },
    });
  }

  function initPortfolioCharts(rangeKey) {
    const view = getPortfolioView(rangeKey);
    if (!view) {
      portfolioLoadingEl.textContent = "";
      portfolioErrorEl.textContent = "No performance data available for this wallet.";
      return;
    }

    portfolioLoadingEl.textContent = "";
    const labels = buildLabels(view.times, rangeKey);

    const colors = {
      equity: "#8b5cf6",   // violet
      pnl: "#f59e0b",      // amber
      deposits: "#14b8a6", // teal
    };

    portfolioCharts.equity = createLineChart(
      equityCanvas.getContext("2d"),
      "Equity",
      { labels, values: view.equity },
      colors.equity
    );

    portfolioCharts.pnl = createLineChart(
      pnlCanvas.getContext("2d"),
      "PnL",
      { labels, values: view.pnl },
      colors.pnl
    );

    portfolioCharts.deposits = createLineChart(
      depositsCanvas.getContext("2d"),
      "Deposits",
      { labels, values: view.deposits },
      colors.deposits
    );
  }

  function updatePortfolioCharts(rangeKey) {
    const view = getPortfolioView(rangeKey);
    if (!view) {
      portfolioErrorEl.textContent = "No performance data available for the selected range.";
      return;
    }
    portfolioErrorEl.textContent = "";

    const labels = buildLabels(view.times, rangeKey);
    const { equity, pnl, deposits } = view;

    const { equity: equityChart, pnl: pnlChart, deposits: depositsChart } = portfolioCharts;
    if (!equityChart || !pnlChart || !depositsChart) {
      initPortfolioCharts(rangeKey);
      return;
    }

    equityChart.data.labels = labels;
    equityChart.data.datasets[0].data = equity;
    equityChart.update();

    pnlChart.data.labels = labels;
    pnlChart.data.datasets[0].data = pnl;
    pnlChart.update();

    depositsChart.data.labels = labels;
    depositsChart.data.datasets[0].data = deposits;
    depositsChart.update();
  }

  async function loadPortfolio(wallet) {
    try {
      portfolioErrorEl.textContent = "";
      portfolioLoadingEl.textContent = "Loading performance data…";
      portfolioData = await fetchPortfolio(wallet);
      initPortfolioCharts(currentRangeKey);
    } catch (err) {
      console.error("Portfolio error", err);
      portfolioLoadingEl.textContent = "";
      portfolioErrorEl.textContent = "Failed to load performance data: " + (err?.message || err);
    }
  }

  function updateChartTheme() {
    const gridColor = getChartGridColor();
    Object.values(portfolioCharts).forEach((chart) => {
      if (!chart) return;
      chart.options.scales.y.grid.color = gridColor;
      chart.update();
    });
  }

  function applyTheme(theme) {
    const bodyEl = document.body;
    if (theme === "light") {
      bodyEl.classList.add("light");
      themeToggleBtn.textContent = "☀️";
    } else {
      bodyEl.classList.remove("light");
      themeToggleBtn.textContent = "🌙";
    }
    try { localStorage.setItem("hypermonitor-theme", theme); } catch (e) {}
    updateSpinnerForTheme(theme);
    updateChartTheme();
    updateBreakdownTheme();
  }

  function initTheme() {
    let initial = "dark";
    try {
      const saved = localStorage.getItem("hypermonitor-theme");
      if (saved === "light" || saved === "dark") initial = saved;
    } catch (e) {}
    applyTheme(initial);
  }

  // ✅ add optional options so boot can "replace" instead of "push"
  async function trackWallet(wallet, { replaceUrl = false } = {}) {
    wallet = wallet.trim();
    if (!isValidAddress(wallet)) {
      snapshotErrorEl.textContent = "Please enter a valid 0x wallet address (40 hex chars).";
      return;
    }

    // ✅ persist both URL + localStorage
    setWalletInUrl(wallet, { replace: replaceUrl });
    saveLastWallet(wallet);

    currentWallet = wallet;
    startedAtEl.textContent = "Started: " + new Date().toLocaleString();
    setStatus("connecting", "Connecting…");

    resetState();
    resetPortfolioSection();

    trackBtnEl.disabled = true;
    try {
      const spotMetaTask = ensureSpotMeta();
      await initClients();
      await ensurePriceStream();
      await spotMetaTask;
      await loadSnapshot(currentWallet);
      await startStreams(currentWallet);
      await loadPortfolio(currentWallet);

      if (ordersHistoryPanelEl && !ordersHistoryPanelEl.classList.contains("hidden")) {
        await loadHistoricalOrders(currentWallet);
      }
      if (fillsHistoryPanelEl && !fillsHistoryPanelEl.classList.contains("hidden")) {
        await loadHistoricalFills(currentWallet);
      }
    } finally {
      trackBtnEl.disabled = false;
    }
  }

  (async function boot() {
    initTheme();

    // ✅ Prefer: URL wallet > last saved wallet > default
    const urlWallet = getWalletFromUrl();
    const savedWallet = getLastWallet();

    const initialWallet =
      (isValidAddress(urlWallet) && urlWallet) ||
      (isValidAddress(savedWallet) && savedWallet) ||
      DEFAULT_WALLET;

    // ✅ show it in the input immediately
    walletInputEl.value = initialWallet;

    startedAtEl.textContent = "Started: " + new Date().toLocaleString();
    setStatus("connecting", "Connecting…");

    await initClients();
    await ensurePriceStream();

    // ✅ Replace URL on first load (so / becomes /?wallet=... without extra history)
    await trackWallet(initialWallet, { replaceUrl: true });
  })();

  trackBtnEl.addEventListener("click", () => {
    trackWallet(walletInputEl.value);
  });

  walletInputEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter") trackWallet(walletInputEl.value);
  });

  rangeButtons.forEach((btn) => {
    btn.addEventListener("click", () => {
      const range = btn.dataset.range;
      currentRangeKey = range;

      rangeButtons.forEach((b) => b.classList.remove("active"));
      btn.classList.add("active");

      if (portfolioData) updatePortfolioCharts(currentRangeKey);
    });
  });

  themeToggleBtn.addEventListener("click", () => {
    const isLight = document.body.classList.contains("light");
    applyTheme(isLight ? "dark" : "light");
  });

  if (exportExcelBtn) {
    exportExcelBtn.addEventListener("click", async () => {
      exportExcelBtn.disabled = true;
      await triggerExcelDownload();
      exportExcelBtn.disabled = false;
    });
  }

  if (positionsChartBtn) {
    positionsChartBtn.addEventListener("click", () => {
      openPortfolioModal();
    });
  }

  if (portfolioModalCloseEl) {
    portfolioModalCloseEl.addEventListener("click", closePortfolioModal);
  }

  if (portfolioModalEl) {
    portfolioModalEl.addEventListener("click", (e) => {
      if (e.target === portfolioModalEl) closePortfolioModal();
    });
  }

  if (positionsBodyEl) {
    positionsBodyEl.addEventListener("click", async (e) => {
      const row = e.target.closest(".position-row");
      if (!row) return;
      row.classList.add("loading");
      const coin = row.dataset.coin;
      if (!coin) return;
      if (!historicalFillsLoaded) await ensureHistoricalDataLoaded();
      if (expandedPositions.has(coin)) expandedPositions.delete(coin);
      else expandedPositions.add(coin);
      renderPositions(currentAssetPositions);
      requestAnimationFrame(() => row.classList.remove("loading"));
    });
  }

  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && portfolioModalEl?.classList.contains("open")) {
      closePortfolioModal();
    }
  });

  ordersTabButtons.forEach((btn) => {
    btn.addEventListener("click", () => {
      const tab = btn.dataset.tab;

      ordersTabButtons.forEach((b) => b.classList.remove("active"));
      btn.classList.add("active");

      if (tab === "history") {
        ordersLivePanelEl.classList.add("hidden");
        ordersHistoryPanelEl.classList.remove("hidden");

        if (currentWallet) loadHistoricalOrders(currentWallet);
      } else {
        ordersHistoryPanelEl.classList.add("hidden");
        ordersLivePanelEl.classList.remove("hidden");
      }
    });
  });

  fillsTabButtons.forEach((btn) => {
    btn.addEventListener("click", () => {
      const tab = btn.dataset.tab;

      fillsTabButtons.forEach((b) => b.classList.remove("active"));
      btn.classList.add("active");

      if (tab === "fills-history") {
        fillsLivePanelEl.classList.add("hidden");
        fillsHistoryPanelEl.classList.remove("hidden");
        if (currentWallet) loadHistoricalFills(currentWallet);
      } else {
        fillsHistoryPanelEl.classList.add("hidden");
        fillsLivePanelEl.classList.remove("hidden");
      }
    });
  });

  if (historicalSideFilterEl) {
    historicalSideFilterEl.addEventListener("change", () => {
      if (historicalOrdersLoaded) renderHistoricalOrders();
    });
  }

  if (historicalStatusFilterEl) {
    historicalStatusFilterEl.addEventListener("change", () => {
      if (historicalOrdersLoaded) renderHistoricalOrders();
    });
  }

  if (historicalAssetFilterEl) {
    historicalAssetFilterEl.addEventListener("input", () => {
      if (historicalOrdersLoaded) renderHistoricalOrders();
    });
  }

  // ✅ Back/Forward support (don’t push a new history entry)
  window.addEventListener("popstate", () => {
    const w = getWalletFromUrl();
    if (isValidAddress(w) && w !== currentWallet) {
      walletInputEl.value = w;
      trackWallet(w, { replaceUrl: true });
    }
  });
</script>
</body>
</html>
