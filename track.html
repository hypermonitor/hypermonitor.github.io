<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hypermonitor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Hyperliquid wallet tracker" />

  <meta property="og:title" content="Hyperliquid wallet tracker" />
  <meta property="og:description" content="Track any Hyperliquid wallet: positions, orders, fills, and performance." />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Hypermonitor" />

  <meta property="og:image" content="https://www.hypermonitor.org/images/track.png" />
  <meta property="og:image:secure_url" content="https://www.hypermonitor.org/images/track.png" />
  <meta property="og:image:type" content="image/png" />
  <meta property="og:image:width" content="1512" />
  <meta property="og:image:height" content="824" />

  <meta property="og:url" content="https://www.hypermonitor.org/" />
  <link rel="canonical" href="https://www.hypermonitor.org/" />

  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Hyperliquid wallet tracker" />
  <meta name="twitter:description" content="Track any Hyperliquid wallet: positions, orders, fills, and performance." />
  <meta name="twitter:image" content="https://www.hypermonitor.org/images/track.png" />

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;700&display=swap" rel="stylesheet">

  <link rel="icon" type="image/png" href="images/favicon.png" />

  <style>
    :root {
      font-family: 'Outfit', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color-scheme: dark;
      --bg: #0b0b0f;
      --card-bg: rgba(12, 12, 16, 0.92);
      --accent: #26d97f;
      --accent-soft: rgba(38, 217, 127, 0.18);
      --danger: #f25f5c;
      --border: rgba(255,255,255,0.08);
      --muted: rgba(245,245,255,0.62);
      --text-main: #f5f5ff;
      --glass: rgba(10, 10, 12, 0.7);
      --glass-border: rgba(255, 255, 255, 0.12);
      --accent-blue: #0070f3;
      --accent-cyan: #00b4d8;
      --control-height: 32px;
      --switch-height: 30px;
      --neutral-blue: rgba(124, 176, 255, 0.95);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--text-main);
    }

    #app {
      max-width: 1520px;
      width: min(1520px, 86vw);
      margin: 0 auto;
      padding: 1.5rem;
      padding-bottom: 4rem;
    }

    @media (max-width: 720px) {
      #app {
        width: 100vw;
        padding-left: 0.4rem;
        padding-right: 0.4rem;
      }
    }

    header {
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto;
      column-gap: 1rem;
      align-items: start;
      margin-bottom: 1.2rem;
    }

    .brand {
      display: inline-flex;
      align-items: center;
      gap: .55rem;
    }

    a.brand,
    a.brand:visited,
    a.brand:hover,
    a.brand:active {
      text-decoration: none !important;
      color: inherit;
    }

    .brand-name {
      font-family: 'Outfit', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      font-weight: 600;
      letter-spacing: 0.04em;
      font-size: 1.05rem;
      text-transform: uppercase;
      margin: 0;
      color: #fff;
      font-style: normal;
    }

    .brand-name .hyper,
    .brand-name em {
      font-style: inherit !important;
      font-weight: inherit !important;
    }

    .wallet-controls {
      display: flex;
      flex-direction: column;
      gap: .45rem;
      max-width: 680px;
      width: 100%;
    }

    .wallet-line {
      font-size: .85rem;
      color: #e2e8f0;
      word-break: break-all;
      display: none;
    }

    /* Match main.html link styling (inline, underline on hover) */
    a {
      color: #e2e8f0;
      text-decoration: none;
      padding: 0;
      border: none;
      background: none;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }

    a:hover { color: inherit; text-decoration: underline; }
    body.light a { color: #475569; }
    body.light a:hover { color: inherit; text-decoration: underline; }

    .wallet-input-row {
      display: grid;
      grid-template-columns: 1fr auto;
      column-gap: 0.4rem;
      row-gap: 0.25rem;
      align-items: stretch;
      width: 100%;
    }

    .wallet-input-actions {
      display: inline-flex;
      gap: 0.35rem;
      align-items: center;
    }

    .wallet-inputs-label {
      font-size: 0.65rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--muted);
      white-space: nowrap;
    }

    .wallet-input-row input {
      padding: 0.55rem 0.75rem;
      border-radius: 12px;
      border: 1px solid var(--glass-border);
      background: rgba(10, 10, 12, 0.45);
      color: var(--text-main);
      font-size: 0.82rem;
      height: 38px;
      outline: none;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .wallet-input-row input:focus {
      border-color: rgba(255, 255, 255, 0.7);
      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.35);
    }

    .wallet-inputs {
      display: grid;
      gap: 0.4rem;
    }

    .wallet-inputs-row {
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto;
      gap: 0.4rem;
      align-items: start;
      width: 100%;
    }

    .wallet-actions {
      display: flex;
      gap: 0.5rem;
      justify-content: flex-start;
      margin-top: 0;
      align-self: start;
    }

    .wallet-fav-btn {
      width: 38px;
      height: 38px;
      border-radius: 10px;
      border: 1px solid var(--glass-border);
      background: rgba(10, 10, 12, 0.45);
      color: #e2e8f0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 0.8rem;
      font-weight: 600;
      transition: transform 0.2s ease, border-color 0.2s ease;
      flex: 0 0 auto;
    }

    .wallet-fav-btn.active {
      color: #fbbf24;
      border-color: rgba(251, 191, 36, 0.6);
    }

    .wallet-fav-btn:hover {
      transform: scale(1.04);
    }

    body.light .wallet-fav-btn {
      background: #ffffff;
      border-color: #e5e7eb;
      color: #475569;
    }

    body.light .wallet-fav-btn:hover {
      border-color: rgba(15, 23, 42, 0.2);
      color: #0f172a;
    }

    .favorites-btn {
      width: 32px;
      height: 32px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(15, 23, 42, 0.5);
      color: #f8fafc;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 0.9rem;
      transition: transform 0.2s ease, border-color 0.2s ease;
    }

    .favorites-btn.active {
      color: #fbbf24;
      border-color: rgba(251, 191, 36, 0.6);
    }

    .favorites-btn:hover {
      transform: scale(1.04);
    }


    .favorites-panel {
      position: fixed;
      inset: 0;
      z-index: 240;
      background: rgba(8, 10, 14, 0.65);
      backdrop-filter: blur(6px);
      display: none;
      align-items: flex-start;
      justify-content: flex-end;
      padding: 1.5rem;
    }

    .favorites-panel.show {
      display: flex;
    }

    .favorites-card {
      width: min(360px, 90vw);
      background: rgba(10, 10, 12, 0.96);
      border: 1px solid var(--glass-border);
      border-radius: 16px;
      box-shadow: 0 22px 40px rgba(0, 0, 0, 0.5);
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .favorites-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 0.95rem;
      font-weight: 600;
    }


    .favorites-add {
      display: flex;
      gap: 0.5rem;
    }

    .favorites-input {
      flex: 1 1 auto;
      border: 1px solid var(--glass-border);
      background: rgba(10, 10, 12, 0.5);
      color: var(--text-main);
      border-radius: 10px;
      padding: 0.45rem 0.6rem;
      font-size: 0.8rem;
      height: 38px;
    }

    .favorites-input:focus {
      outline: none;
      border-color: rgba(255, 255, 255, 0.7);
      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.35);
    }

    .favorites-add-btn {
      border: 1px solid var(--glass-border);
      background: rgba(10, 10, 12, 0.45);
      color: #e2e8f0;
      width: 38px;
      min-width: 38px;
      height: 38px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .favorites-add-btn:hover,
    .favorites-remove-btn:hover,
    .favorites-close:hover {
      border-color: rgba(255,255,255,0.25);
      color: #f8fafc;
    }

    .favorites-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      max-height: 55vh;
      overflow: auto;
      padding-right: 0.2rem;
    }

    .favorites-item {
      border: 1px solid rgba(148, 163, 184, 0.18);
      border-radius: 12px;
      padding: 0.45rem 0.6rem;
      background: rgba(10, 10, 12, 0.45);
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 0.3rem 0.5rem;
      align-items: center;
      position: relative;
      overflow: hidden;
    }

    .favorites-item::before {
      content: "";
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 3px;
      background: var(--fav-accent, rgba(148, 163, 184, 0.45));
      opacity: 0.85;
    }

    .favorites-item:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.25);
      border-color: rgba(255, 255, 255, 0.18);
    }

    .favorites-item {
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
    }

    .favorites-wallet-btn {
      background: none;
      border: none;
      color: var(--text-main);
      text-align: left;
      font-size: 0.78rem;
      cursor: pointer;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    .favorites-wallet-sub {
      color: var(--muted);
      font-weight: 400;
      font-size: 0.7rem;
    }

    .favorites-wallet-full {
      display: none;
      color: var(--muted);
      font-weight: 400;
      font-size: 0.7rem;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    @media (min-width: 720px) {
      .favorites-wallet-full {
        display: inline;
      }
      .favorites-wallet-sub {
        display: none;
      }
    }

    .favorites-chip {
      font-size: 0.6rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      border: 1px solid rgba(148, 163, 184, 0.35);
      color: var(--muted);
      padding: 0.05rem 0.35rem;
      border-radius: 999px;
    }

    .favorites-copy {
      opacity: 0;
      border: none;
      background: rgba(10, 10, 12, 0.45);
      color: var(--muted);
      border-radius: 8px;
      width: 22px;
      height: 22px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: opacity 0.15s ease, color 0.15s ease, border-color 0.15s ease;
      border: 1px solid rgba(148, 163, 184, 0.25);
    }

    .favorites-item:hover .favorites-copy,
    .favorites-wallet-btn:focus-visible .favorites-copy {
      opacity: 1;
    }

    .favorites-copy:hover {
      color: #f8fafc;
      border-color: rgba(255,255,255,0.25);
    }

    .favorites-copy-toast {
      opacity: 0;
      pointer-events: none;
      font-size: 0.65rem;
      color: #e2e8f0;
      background: rgba(10, 10, 12, 0.6);
      border: 1px solid var(--glass-border);
      border-radius: 999px;
      padding: 0.1rem 0.4rem;
      margin-left: 0.35rem;
      transition: opacity 0.2s ease;
    }

    .favorites-copy-toast.show {
      opacity: 1;
    }

    .favorites-metrics {
      display: grid;
      grid-template-columns: 1fr auto;
      column-gap: 0.5rem;
      align-items: center;
      font-size: 0.7rem;
      color: var(--muted);
    }

    .favorites-metrics .favorites-metric {
      grid-column: 1;
    }

    .favorites-spark {
      grid-column: 2;
      grid-row: 1 / span 2;
      height: 22px;
      width: 90px;
      align-self: center;
    }

    .favorites-spark svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    .favorites-metric strong {
      color: var(--text-main);
      font-weight: 600;
    }

    .favorites-remove-btn {
      border: 1px solid var(--glass-border);
      background: rgba(10, 10, 12, 0.45);
      color: #e2e8f0;
      width: 32px;
      height: 32px;
      border-radius: 10px;
      font-size: 0.9rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .market-toggle {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      margin-top: -0.05rem;
      flex-wrap: wrap;
    }

    .market-toggle-label {
      font-size: 0.65rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--muted);
      white-space: nowrap;
    }

    .market-toggle.no-label .market-toggle-label {
      display: none;
    }

    .market-toggle .orders-tabs {
      margin: 0;
      padding: 2px;
      border-radius: 999px;
      border: 1px solid var(--glass-border);
      background: rgba(10, 10, 12, 0.45);
      gap: 0.2rem;
      justify-content: center;
      width: fit-content;
      max-width: 100%;
      position: relative;
      overflow: visible;
      height: var(--switch-height);
    }

    .market-toggle .orders-tab-btn {
      border-color: transparent;
      background: transparent;
      position: relative;
      z-index: 2;
      height: 100%;
    }

    .market-toggle .orders-tab-btn.active {
      border-color: transparent;
      background: rgba(255, 255, 255, 0.08);
    }

    .market-toggle-indicator {
      position: absolute;
      top: 0.2rem;
      bottom: 0.2rem;
      left: 0;
      width: 0;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255,255,255,0.45);
      transition: transform 220ms ease, width 220ms ease;
      z-index: 1;
    }

    body.light .market-toggle .orders-tabs {
      background: #ffffff;
      border-color: #e5e7eb;
    }

    body.light .market-toggle .orders-tab-btn.active {
      border-color: transparent;
      background: #f8fafc;
    }

    body.light .market-toggle-indicator {
      background: #f8fafc;
      border-color: #cbd5f5;
    }

    .section-mode {
      font-size: 0.7rem;
      font-weight: 600;
      color: var(--muted);
      margin-left: 0.4rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .spot-performance-note {
      font-size: 0.78rem;
      color: var(--muted);
      margin-top: 0.6rem;
    }

    .is-hidden {
      display: none !important;
    }

    .hidden {
      display: none !important;
    }

    .wallet-track-btn {
      padding: 0.45rem 0.8rem;
      border-radius: 10px;
      border: 1px solid var(--glass-border);
      background: rgba(10, 10, 12, 0.45);
      color: var(--muted);
      font-size: 0.75rem;
      font-weight: 600;
      cursor: pointer;
      white-space: nowrap;
      flex: 0 0 auto;
      box-shadow: none;
      height: 38px;
    }

    .wallet-track-btn:hover:not(:disabled) {
      color: #f8fafc;
      border-color: rgba(255,255,255,0.22);
    }
    .wallet-track-btn:disabled { opacity: 0.5; cursor: default; }
    .wallet-track-btn:focus-visible {
      outline: none;
      border-color: rgba(255,255,255,0.7);
      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.35);
    }

    .wallet-input-row .wallet-icon-btn {
      padding: 0.35rem 0.65rem;
      border-radius: 10px;
      border: 1px solid var(--glass-border);
      background: rgba(10, 10, 12, 0.45);
      color: #e2e8f0;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      white-space: nowrap;
      width: 38px;
      min-width: 38px;
      text-align: center;
      flex: 0 0 auto;
      height: 38px;
    }

    .wallet-input-row .wallet-icon-btn:hover { color: #fff; border-color: rgba(255,255,255,0.25); }
    .wallet-input-row .wallet-icon-btn:focus-visible {
      outline: none;
      border-color: rgba(255,255,255,0.7);
      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.35);
    }

    button:focus-visible {
      outline: none;
      border-color: rgba(255,255,255,0.7);
      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.35);
    }

    .wallet-input-row .wallet-remove-btn {
      border-color: var(--glass-border);
      color: #e2e8f0;
      background: rgba(10, 10, 12, 0.45);
    }

    @media (max-width: 600px) {
      header { grid-template-columns: 1fr; }
      .wallet-input-row { grid-template-columns: minmax(0, 1fr) auto; }
      .wallet-inputs-row { grid-template-columns: 1fr; }
      .wallet-input-row input { width: 100%; }
      .wallet-input-row .wallet-icon-btn { width: 38px; }
      .wallet-actions { flex-direction: column; align-items: stretch; }
      .wallet-actions .wallet-track-btn { width: 100%; }
      .header-right { align-items: flex-end; margin-top: 0.6rem; }
      .header-right-top { width: 100%; justify-content: flex-end; gap: 0.6rem; }
    }

    @media (max-width: 600px) {
      #app { padding: 0.9rem; }
      header { margin-bottom: 1rem; }
      .card { padding: 0.85rem; border-radius: 12px; }
      .grid { gap: 0.75rem; margin-bottom: 1rem; }
    }

    @media (max-width: 600px) {
      .theme-toggle-btn,
      .orders-tab-btn,
      .chart-range-btn {
        padding: 0.45rem 0.9rem;
        font-size: 0.85rem;
      }
    }

    @media (max-width: 600px) {
      .chart-grid { grid-template-columns: 1fr; }
      .chart-card { min-height: 200px; }
    }

    @media (max-width: 600px) {
      table { font-size: 0.78rem; }
      th, td { padding: 0.3rem 0.35rem; }
      .timestamp { font-size: 0.72rem; }
    }

    div[style*="overflow: auto"] {
      -webkit-overflow-scrolling: touch;
    }

    @media (max-width: 600px) {
      .header-right { align-items: stretch; margin-top: 0.6rem; }
      .header-right-top { justify-content: space-between; gap: 0.6rem; }
      .status-pill { flex: 1; justify-content: center; }
    }

    @media (max-width: 600px) {
      .wallet-input-row label { display: none; }
    }

    /* ===== Mobile table compaction ===== */
    @media (max-width: 600px) {
      /* make all tables denser and more predictable */
      table {
        table-layout: fixed;      /* important: obey widths */
        width: 100%;
        font-size: 0.72rem;       /* smaller than your 0.78 */
      }

      th, td {
        padding: 0.22rem 0.28rem; /* tighter */
        overflow: hidden;         /* prevent stretching */
        text-overflow: ellipsis;  /* show â€¦ */
        white-space: nowrap;
      }

      /* slightly smaller pills in cells */
      .pill { font-size: 0.62rem; padding: 0.1rem 0.35rem; }

      /* if you want even denser timestamps */
      .timestamp { font-size: 0.68rem; }

      .position-subtable {
        table-layout: auto;
      }

      .position-subtable th,
      .position-subtable td {
        white-space: normal;
      }

      /* --- Positions table: hide less critical columns --- */
      /* columns: Asset(1) Size(2) Direction(3) Entry(4) Value(5) uPnL(6) */
      .grid section.card table th:nth-child(4),
      .grid section.card table td:nth-child(4),
      .grid section.card table th:nth-child(5),
      .grid section.card table td:nth-child(5) {
        display: none; /* hide Entry Price + Value on phones */
      }

      .positions-card table {
        table-layout: auto;
      }

      .positions-card th,
      .positions-card td {
        overflow: visible;
        text-overflow: unset;
      }

      .positions-card td:nth-child(2),
      .positions-card th:nth-child(2) {
        white-space: nowrap;
      }

      .positions-card th.sortable,
      .table-sortable th.sortable {
        cursor: pointer;
        user-select: none;
      }

      .table-sortable th.sortable[data-sort-dir="asc"]::after,
      .table-sortable th.sortable[data-sort-dir="desc"]::after {
        content: "";
      }

      .positions-card .sort-indicator {
        margin-left: 0.25rem;
        font-size: 0.5rem;
        letter-spacing: 0.02em;
        opacity: 0.9;
      }

      /* --- Orders / Fills tables: hide time + total (usually widest) --- */
      /* Open Orders: OrderID(1) Time(2) Asset(3) Side(4) Type(5) Size(6) Limit(7) MobilePrice(8) */
      #openOrdersBody td:nth-child(1),
      #openOrdersBody td:nth-child(2),
      #openOrdersBody td:nth-child(7),
      #openOrdersBody th:nth-child(7) {
        display: none;
      }

      /* Trades Stream: OrderID(1) Time(2) Asset(3) Side(4) Size(5) Price(6) Type(7) */
      #fillsBody td:nth-child(1),
      #fillsBody td:nth-child(2),
      #fillsBody td:nth-child(7),
      #fillsBody th:nth-child(1),
      #fillsBody th:nth-child(2),
      #fillsBody th:nth-child(7) {
        display: none;
      }

      /* Historical Orders: OrderID(1) Date/Time(2) Side(3) Asset(4) Size(5) Limit(6) Status(7) */
      #historicalOrdersBody td:nth-child(2),
      #historicalOrdersBody th:nth-child(2) {
        display: none;
      }

      /* Canceled Orders: OrderID(1) Time(2) Asset(3) Side(4) Type(5) Size(6) */
      #canceledOrdersBody th:nth-child(1),
      #canceledOrdersBody td:nth-child(1) {
        display: none;
      }
    }


    .header-right {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 0.25rem;
      justify-self: end;
      align-self: start;
    }

    .header-right-top {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .export-btn {
      border: 1px solid var(--glass-border);
      background: rgba(10, 10, 12, 0.45);
      padding: 0.25rem 0.55rem;
      border-radius: 999px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: #e2e8f0;
      transition: background 0.15s ease, border-color 0.15s ease, color 0.15s ease, transform 0.15s ease;
    }

    .export-btn:hover {
      opacity: 0.95;
      transform: translateY(-1px);
      border-color: rgba(255,255,255,0.22);
      background: rgba(18, 18, 24, 0.6);
    }

    .export-icon {
      width: 16px;
      height: 16px;
      display: inline-block;
    }

    body.light .export-btn {
      background: #ffffff;
      border-color: #e5e7eb;
      color: #475569;
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      border: 0;
    }

    .theme-toggle-btn {
      border-radius: 999px;
      border: 1px solid var(--glass-border);
      background: rgba(10, 10, 12, 0.45);
      color: #e2e8f0;
      font-size: 0.75rem;
      padding: 0 0.7rem;
      height: 30px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      transition: border-color 0.15s ease, background 0.15s ease, color 0.15s ease, transform 0.15s ease;
    }

    .favorites-panel-btn {
      padding: 0 0.7rem;
      line-height: 1;
    }

    .theme-toggle-btn:hover {
      border-color: rgba(255,255,255,0.22);
      background: rgba(18, 18, 24, 0.6);
      color: #f8fafc;
      transform: translateY(-1px);
    }

    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0 0.7rem;
      border-radius: 9999px;
      font-size: 0.75rem;
      border: 1px solid var(--glass-border);
      background: rgba(10, 10, 12, 0.45);
      color: #e2e8f0;
      height: 30px;
    }

    .status-dot {
      width: 0.55rem;
      height: 0.55rem;
      border-radius: 999px;
      background: #fbbf24;
      box-shadow: 0 0 4px rgba(251, 191, 36, 0.6);
    }

    .status-dot.connected {
      background: var(--accent);
      box-shadow: 0 0 6px rgba(34, 197, 94, 0.7);
    }

    .status-dot.error {
      background: var(--danger);
      box-shadow: 0 0 6px rgba(248, 113, 113, 0.7);
    }

    .status-spinner {
      width: 18px;
      height: 18px;
      border-radius: 999px;
      object-fit: contain;
      display: none;
      margin-left: 0.15rem;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .card {
      background: var(--card-bg);
      border: 1px solid rgba(148, 163, 184, 0.12);
      border-radius: 10px;
      padding: 1rem;
      position: relative;
      overflow: hidden;
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.35);
    }

    .card::before {
      content: "";
      position: absolute;
      inset: 0;
      opacity: 0;
      pointer-events: none;
    }

    .card h2 {
      margin: 0 0 0.75rem;
      font-size: 1rem;
      display: flex;
      align-items: center;
      gap: .4rem;
    }

    .card h2 span.badge {
      font-size: .65rem;
      padding: 0.05rem 0.35rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
    }

    .positions-card {
      grid-column: span 2;
      min-width: 640px;
    }

    .positions-card table {
      width: 100%;
      min-width: 100%;
    }

    @media (max-width: 900px) {
      .positions-card {
        grid-column: span 1;
        min-width: 100%;
      }
    }

    /* Stack snapshot + positions for mobile and landscape tablets */
    @media (max-width: 900px), (max-width: 1100px) and (orientation: landscape) {
      .grid {
        grid-template-columns: 1fr;
      }
      .positions-card {
        grid-column: span 1;
        min-width: 100%;
      }
    }

    .kv-list {
      font-size: 0.85rem;
      display: grid;
      grid-template-columns: 1.1fr 1.3fr;
      gap: .25rem .5rem;
    }

    .kv-label { color: var(--muted); }
    .kv-value { text-align: right; }

    .overview-stack {
      display: grid;
      gap: 0.7rem;
    }

    .overview-item {
      border: 1px solid var(--glass-border);
      border-radius: 14px;
      padding: 0.75rem 0.8rem;
      background: rgba(10, 10, 12, 0.55);
      box-shadow: 0 10px 26px rgba(0, 0, 0, 0.3);
    }

    .overview-wallet {
      font-size: 0.68rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.4rem;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .asset-cell {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      white-space: nowrap;
      line-height: 1.1;
    }

    td.asset-cell {
      display: table-cell;
      vertical-align: middle;
    }

    td.asset-cell > .asset-cell {
      display: inline-flex;
    }

    .coinIcon {
      width: 16px;
      height: 16px;
      border-radius: 4px;
      object-fit: cover;
      background: transparent;
      flex-shrink: 0;
      display: block;
    }

    .coinFallback {
      width: 16px;
      height: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      background: var(--border);
      color: var(--muted);
      font-size: 0.65rem;
      font-weight: 700;
      flex-shrink: 0;
    }

    .price-stack {
      display: inline-flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0.15rem;
      line-height: 1.2;
    }

    .price-stack .current-price {
      color: var(--muted);
      font-size: 0.72rem;
    }

    .size-stack {
      align-items: flex-start;
    }

    .size-main {
      font-weight: 600;
    }

    .size-ticker {
      font-size: 0.72rem;
      color: inherit;
      opacity: 0.7;
      font-weight: 500;
      letter-spacing: 0.02em;
    }

    .size-cell {
      text-align: left;
    }

    .position-row { cursor: pointer; }
    .position-row:hover { background: rgba(56, 189, 248, 0.05); }
    .position-row.loading { opacity: 0.6; cursor: progress; }

    .chevron {
      display: inline-block;
      width: 0.6rem;
      height: 0.6rem;
      border-right: 1.6px solid var(--muted);
      border-bottom: 1.6px solid var(--muted);
      transform: rotate(45deg);
      transition: transform 120ms ease, border-color 120ms ease;
    }

    .position-row.expanded .chevron {
      transform: rotate(-135deg);
      border-color: #18bf98;
    }

    .upnl-pos { color: #4ade80; }
    .upnl-neg { color: #fb7185; }

    .position-breakdown {
      margin-top: 0.25rem;
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.4rem 0.5rem;
    }

    .position-details td {
      width: 100%;
    }

    .position-subtable {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.75rem;
    }

    .position-subtable th,
    .position-subtable td {
      padding: 0.2rem 0.25rem;
      border-bottom: 1px solid var(--border);
      text-align: left;
    }

    .position-subtable th {
      color: var(--muted);
      font-weight: 600;
    }

    .position-subtable tr:last-child td {
      border-bottom: none;
    }

    .position-subtable .money {
      text-align: right;
      font-variant-numeric: tabular-nums;
    }

    .position-breakdown-note {
      margin-top: 0.25rem;
      font-size: 0.72rem;
      color: var(--muted);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
    }

    thead {
      background: #17181f;
      position: sticky;
      top: 0;
      z-index: 1;
    }

    th, td {
      padding: 0.35rem 0.45rem;
      text-align: left;
      border-bottom: 1px solid var(--border);
      white-space: nowrap;
    }

    tbody tr:nth-child(even) { background: #14141c; }
    tbody tr.loading-row { background: transparent; }

    .pill {
      display: inline-flex;
      padding: 0.15rem 0.45rem;
      border-radius: 9999px;
      font-size: 0.7rem;
      border: 1px solid rgba(148, 163, 184, 0.4);
      font-weight: 600;
    }

    .dex-tag {
      display: inline-flex;
      align-items: center;
      padding: 0.05rem 0.35rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
      font-size: 0.65rem;
      background: rgba(255, 255, 255, 0.03);
    }

    .spot-tag {
      color: #38bdf8;
      border-color: rgba(56, 189, 248, 0.6);
      background: rgba(56, 189, 248, 0.12);
    }

    .pill-buy {
      color: #4ade80;
      border-color: rgba(22, 163, 74, 0.8);
      background: rgba(22, 163, 74, 0.18);
      box-shadow: 0 0 0 1px rgba(22, 163, 74, 0.2);
    }

    .pill-sell {
      color: #f97373;
      border-color: rgba(248, 113, 113, 0.6);
      background: rgba(220, 38, 38, 0.18);
      box-shadow: 0 0 0 1px rgba(220, 38, 38, 0.2);
    }

    .pill-new {
      color: #facc15;
      border-color: rgba(250, 204, 21, 0.6);
      background: rgba(250, 204, 21, 0.12);
    }

    .pill-cancel {
      color: #f472b6;
      border-color: rgba(236, 72, 153, 0.6);
      background: rgba(190, 24, 93, 0.12);
    }

    .pill-fill {
      color: #22c55e;
      border-color: rgba(22, 163, 74, 0.6);
      background: rgba(21, 128, 61, 0.16);
    }

    .muted { color: var(--muted); }
    .money { font-variant-numeric: tabular-nums; }

    .layout-two {
      display: grid;
      grid-template-columns: minmax(0, 1.05fr) minmax(0, 0.95fr);
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    #liveLayout .layout-two {
      gap: 0;
    }

    #liveLayout .layout-two > *:first-child {
      padding-right: 0.8rem;
      border-right: 1px solid var(--border);
    }

    #liveLayout .layout-two > *:last-child {
      padding-left: 0.8rem;
    }

    @media (max-width: 900px) {
      .layout-two { grid-template-columns: 1fr; }
    }

    .section-title {
      font-size: 0.95rem;
      margin: 0 0 0.4rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: .5rem;
    }

    .section-title h2 {
      margin: 0;
    }

    .section-title small {
      font-size: 0.75rem;
      color: var(--muted);
    }

    #liveLayout > .section-title {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
    }

    #liveLayout > .section-title > h2 {
      justify-self: start;
    }

    #liveLayout > .section-title > .orders-tabs {
      justify-self: center;
    }

    #historyLayout > .section-title {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
    }

    #historyLayout > .section-title > h2 {
      justify-self: start;
    }

    #historyLayout > .section-title > .orders-tabs {
      justify-self: center;
    }

    .history-tabs-row {
      justify-content: flex-start;
    }

    #liveLayout h3,
    #historyLayout h3 {
      margin: 0 0 0.4rem;
      font-size: 0.95rem;
    }

    .section-actions {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    @media (max-width: 720px) {
      .positions-card .section-actions {
        margin-left: auto;
        justify-content: flex-end;
      }
    }

    .tagline { font-size: 0.8rem; color: var(--muted); margin-bottom: 0.35rem; }
    .error { margin-top: .5rem; font-size: .75rem; color: #fecaca; }
    .timestamp { font-size: 0.75rem; color: var(--muted); }

    tbody tr.flash { animation: flashRow 1s ease-out; }
    @keyframes flashRow {
      from { background: rgba(34, 197, 94, 0.22); }
      to { background: #14141c; }
    }

    tbody tr.flash-cancel { animation: flashCancel 1s ease-out; }
    @keyframes flashCancel {
      from { background: rgba(244, 114, 182, 0.22); }
      to { background: #14141c; }
    }

    p { margin: 1.5rem 0; }

    .chart-toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      margin-bottom: 0.4rem;
      font-size: 0.8rem;
    }

    .chart-toolbar-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .chart-toolbar-row .chart-toolbar {
      margin-bottom: 0;
    }

    .performance-title {
      align-items: center;
      gap: 0.5rem;
    }

    .performance-toolbar {
      display: inline-flex;
      align-items: center;
      justify-content: flex-start;
      gap: 0.5rem;
    }

    .chart-actions {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }

    .range-toggle {
      margin: 0;
      padding: 2px;
      border-radius: 999px;
      border: 1px solid var(--glass-border);
      background: rgba(10, 10, 12, 0.45);
      gap: 0.2rem;
      display: inline-flex;
      align-items: stretch;
      justify-content: center;
      width: fit-content;
      max-width: 100%;
      position: relative;
      overflow: visible;
      height: var(--switch-height);
    }

    .range-toggle .chart-range-btn {
      border-color: transparent;
      background: transparent;
      position: relative;
      z-index: 2;
    }

    .range-toggle .chart-range-btn.active {
      border-color: transparent;
      background: rgba(255, 255, 255, 0.08);
    }

    .range-toggle-indicator {
      position: absolute;
      top: 2px;
      bottom: 2px;
      left: 0;
      width: 0;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255,255,255,0.45);
      z-index: 1;
      opacity: 0;
      transition: transform 220ms ease, width 220ms ease, opacity 120ms ease;
    }

    .range-toggle.ready .range-toggle-indicator {
      opacity: 1;
    }

    .performance-share-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .chart-range-btn {
      border-radius: 999px;
      border: 1px solid transparent;
      background: transparent;
      color: var(--muted);
      padding: 0 0.85rem;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.75rem;
      transition: background 0.15s ease, border-color 0.15s ease, color 0.15s ease;
      height: 100%;
    }

    .chart-range-btn:hover {
      border-color: rgba(255,255,255,0.22);
      color: #f8fafc;
      background: rgba(18, 18, 24, 0.6);
    }

    .chart-range-btn.active {
      border-color: transparent;
      color: #f8fafc;
    }

    .chart-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 0.75rem;
      margin-top: 0.5rem;
    }

    .chart-card {
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      padding: 0.6rem 0.75rem 0.75rem;
      position: relative;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 220px;
    }

    .chart-card h3 {
      margin: 0 0 0.25rem;
      font-size: 0.85rem;
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .chart-card h3 span.spark-label {
      font-size: 0.7rem;
      color: var(--muted);
      font-weight: 400;
    }

    .chart-card h3 span.spark-label.positive { color: var(--accent); }
    .chart-card h3 span.spark-label.negative { color: var(--danger); }
    .chart-card h3 span.spark-label.neutral { color: var(--neutral-blue); }

    .chart-canvas-wrap {
      position: relative;
      flex: 1 1 auto;
      min-height: 170px;
    }

    .chart-canvas-wrap canvas {
      width: 100% !important;
      height: 100% !important;
    }

    .chart-loading-wrap {
      position: relative;
      border-radius: 0.75rem;
      overflow: visible;
      --pulse-size: 220px;
    }

    .chart-loading-wrap.loading {
      --pulse-size: 220px;
      background-image: url("images/pulse.gif");
      background-repeat: no-repeat;
      background-position: center 50%;
      background-size: var(--pulse-size) auto;
      overflow: hidden;
    }

    .chart-loading-wrap.loading .chart-grid {
      opacity: 0;
      pointer-events: none;
    }

    .chart-loading-wrap.loading .metrics-card {
      opacity: 0;
      pointer-events: none;
    }


    .chart-loading {
      position: absolute;
      left: 50%;
      top: calc(50% + (var(--pulse-size) * 0.35));
      transform: translate(-50%, -50%);
      font-size: 0.85rem;
      color: var(--muted);
      pointer-events: none;
      display: none;
      text-align: center;
      width: 100%;
    }

    .chart-loading-wrap.loading .chart-loading {
      display: block;
    }

    body.light {
      background: #ffffff;
      color: #0f172a;
      color-scheme: light;
    }

    body.light #app { color: #0f172a; }

    body.light .theme-toggle-btn {
      background: #ffffff;
      color: #0f172a;
      border-color: #e5e7eb;
    }

    body.light .wallet-input-row input {
      background: #ffffff;
      color: #0f172a;
      border-color: #d1d5db;
    }

    body.light .wallet-input-row input:focus {
      border-color: #38bdf8;
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.4);
    }

    body.light .wallet-input-row .wallet-icon-btn {
      background: #ffffff;
      border-color: #d1d5db;
      color: #475569;
    }

    body.light .wallet-input-row .wallet-remove-btn {
      border-color: #d1d5db;
      color: #475569;
      background: #ffffff;
    }

    body.light .status-pill {
      background: #ffffff;
      border-color: #e5e7eb;
      color: #0f172a;
    }

    body.light .status-dot { box-shadow: 0 0 4px rgba(251, 191, 36, 0.6); }

    body.light .card {
      background: #ffffff;
      border: 1px solid #e5e7eb;
    }

    body.light .card { box-shadow: 0 12px 24px rgba(15, 23, 42, 0.08); }

    body.light .card h2 span.badge {
      border-color: #e5e7eb;
      color: #6b7280;
    }

    body.light .kv-label { color: #6b7280; }
    body.light .muted { color: #6b7280; }
    body.light .overview-item { background: #f8fafc; border-color: #e5e7eb; box-shadow: none; }
    body.light .overview-wallet { color: #0f172a; }
    body.light .wallet-tag { border-color: #e5e7eb; color: #6b7280; }

    body.light table { color: #0f172a; }
    body.light thead { background: #f9fafb; }

    body.light th, body.light td { border-bottom: 1px solid #e5e7eb; }
    body.light tbody tr:nth-child(even) { background: #f9fafb; }
    body.light .timestamp { color: #6b7280; }

    body.light .chart-range-btn {
      background: transparent;
      color: #475569;
      border-color: transparent;
    }

    body.light .chart-range-btn:hover { border-color: #d1d5db; }

    body.light .chart-range-btn.active {
      color: #0f172a;
    }

    body.light .range-toggle {
      background: #ffffff;
      border-color: #e5e7eb;
    }

    body.light .range-toggle .chart-range-btn.active {
      background: #f8fafc;
    }

    body.light .range-toggle-indicator {
      background: #f8fafc;
      border-color: #cbd5f5;
    }

    body.light .chart-card {
      background: #ffffff;
      border: 1px solid #e5e7eb;
    }

    body.light .chart-loading { color: #6b7280; }
    body.light .price-stack .current-price { color: #0f172a; }
    body.light .size-ticker { color: #0f172a; opacity: 0.7; }
    body.light .notional-sub { color: #0f172a; opacity: 0.7; }
    body.light .upnl-pos { color: #16a34a; }
    body.light .upnl-neg { color: #dc2626; }
    .favorites-metrics .upnl-pos { color: #22c55e; }
    .favorites-metrics .upnl-neg { color: #f43f5e; }


    .linkedin-badge {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      margin-left: 4px;
      border-radius: 4px;
      text-decoration: none;
      vertical-align: middle;
      transition: background 0.15s ease, border-color 0.15s ease, opacity 0.15s ease;
    }

    .linkedin-badge svg {
      width: 11px;
      height: 11px;
      transition: fill 0.15s ease;
    }

    body:not(.light) .linkedin-badge {
      background: rgba(10, 102, 194, 0.12);
      border: 1px solid rgba(10, 102, 194, 0.35);
    }

    body:not(.light) .linkedin-badge svg { fill: #3396ff; }

    body:not(.light) .linkedin-badge:hover {
      background: rgba(10, 102, 194, 0.20);
      border-color: #3396ff;
    }

    body.light .linkedin-badge {
      background: rgba(10, 102, 194, 0.10);
      border: 1px solid rgba(10, 102, 194, 0.30);
    }

    body.light .linkedin-badge svg { fill: #0a66c2; }

    body.light .linkedin-badge:hover {
      background: rgba(10, 102, 194, 0.18);
      border-color: #0a66c2;
    }

    .linkedin-badge::after {
      content: attr(data-tip);
      position: absolute;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      padding: 3px 6px;
      border-radius: 4px;
      font-size: 0.65rem;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s ease;
      background: #1e293b;
      color: #e2e8f0;
      border: 1px solid #334155;
    }

    body.light .linkedin-badge::after {
      background: #f1f5f9;
      color: #0f172a;
      border: 1px solid #cbd5e1;
    }

    .linkedin-badge:hover::after { opacity: 1; }

    footer {
      margin-top: 0.2rem;
      padding: 0.2rem 0 0;
      border-top: 1px #262637;
      color: #a1a1b5;
      font-size: .78rem;
      line-height: 1.45;
    }

    .status-logo {
      display: inline-flex;
      align-items: center;
      margin-left: 0.25rem;
    }

    .status-logo.hidden { display: none; }
    .status-logo svg { height: 12px; width: auto; }

    body:not(.light) .status-logo { color: #97fde5; }
    body.light .status-logo { color: #072722; }

    .status-logo-link {
      display: inline-flex;
      align-items: center;
      text-decoration: none;
      color: inherit;
      cursor: pointer;
    }

    .orders-tabs {
      display: flex;
      gap: 0.4rem;
      margin: 0.2rem 0 0.6rem;
      font-size: 0.8rem;
    }

    .orders-tabs.switch {
      margin: 0.2rem 0 0.6rem;
      padding: 2px;
      border-radius: 999px;
      border: 1px solid var(--glass-border);
      background: rgba(10, 10, 12, 0.45);
      gap: 0.2rem;
      align-items: stretch;
      justify-content: center;
      width: fit-content;
      max-width: 100%;
      position: relative;
      overflow: visible;
      height: var(--switch-height);
    }

    .orders-tabs.switch .orders-tab-btn {
      border-color: transparent;
      background: transparent;
      position: relative;
      z-index: 2;
      height: 100%;
    }

    .orders-tabs.switch .orders-tab-btn.active {
      border-color: transparent;
      background: rgba(255, 255, 255, 0.08);
    }

    .orders-tabs-indicator {
      position: absolute;
      top: 2px;
      bottom: 2px;
      left: 0;
      width: 0;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255,255,255,0.45);
      z-index: 1;
      opacity: 0;
      transition: transform 220ms ease, width 220ms ease, opacity 120ms ease;
    }

    .orders-tabs.switch.ready .orders-tabs-indicator {
      opacity: 1;
    }

    .orders-tab-btn {
      padding: 0.3rem 0.85rem;
      border-radius: 999px;
      border: 1px solid var(--glass-border);
      background: rgba(10, 10, 12, 0.45);
      color: var(--muted);
      cursor: pointer;
      white-space: nowrap;
      font-size: 0.75rem;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.35rem;
      transition: background 0.15s ease, border-color 0.15s ease, color 0.15s ease;
    }

    .orders-tab-btn:hover {
      border-color: rgba(255,255,255,0.22);
      color: #f8fafc;
      background: rgba(18, 18, 24, 0.6);
    }

    .orders-tab-btn.active {
      border-color: rgba(255,255,255,0.45);
      color: #f8fafc;
      background: rgba(255, 255, 255, 0.08);
    }

    .live-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #ef4444;
      display: inline-block;
      box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.25);
      position: relative;
    }

    body.light .live-dot {
      box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.2);
    }

    .live-dot::after {
      content: "";
      position: absolute;
      inset: -5px;
      border-radius: 999px;
      background: rgba(239, 68, 68, 0.35);
      opacity: 0.6;
      display: none;
    }

    @keyframes livePulse {
      0% { transform: scale(0.6); opacity: 0.6; }
      70% { transform: scale(1.6); opacity: 0; }
      100% { transform: scale(1.6); opacity: 0; }
    }

    .history-icon {
      width: 14px;
      height: 14px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .history-icon svg {
      width: 14px;
      height: 14px;
      transform-origin: center;
      animation: none;
    }

    .orders-tab-btn.active .live-dot::after {
      display: block;
      animation: livePulse 1.6s ease-out infinite;
    }

    .orders-tab-btn.active .history-icon svg {
      animation: historyTick 2.8s ease-in-out infinite;
    }

    @keyframes historyTick {
      0% { transform: rotate(0deg) scale(1); }
      10% { transform: rotate(-12deg) scale(1.03); }
      20% { transform: rotate(6deg) scale(1.01); }
      30% { transform: rotate(0deg) scale(1); }
      100% { transform: rotate(0deg) scale(1); }
    }

    body.light .orders-tab-btn {
      background: #ffffff;
      border-color: #e5e7eb;
      color: #475569;
    }

    body.light .orders-tab-btn:hover { border-color: #d1d5db; }

    body.light .orders-tab-btn.active {
      border-color: #cbd5f5;
      color: #0f172a;
      background: #f8fafc;
    }

    body.light .orders-tabs.switch {
      background: #ffffff;
      border-color: #e5e7eb;
    }

    body.light .orders-tabs.switch .orders-tab-btn.active {
      background: #f8fafc;
    }

    body.light .orders-tabs-indicator {
      background: #f8fafc;
      border-color: #cbd5f5;
    }

    .tab-panel.hidden { display: none; }

    .orders-filter-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      margin: 0.2rem 0 0.6rem;
      font-size: 0.8rem;
    }

    .orders-filter-group {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .orders-filter-label {
      color: var(--muted);
      font-size: 0.75rem;
      white-space: nowrap;
    }

    .orders-filter-input,
    .orders-filter-select {
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #17181f;
      color: var(--text-main);
      font-size: 0.75rem;
      padding: 0.2rem 0.6rem;
      min-width: 80px;
      max-width: 140px;
      outline: none;
    }

    .orders-filter-input::placeholder {
      color: var(--muted);
      opacity: 0.7;
    }

    body.light .orders-filter-input,
    body.light .orders-filter-select {
      background: #ffffff;
      border-color: #e5e7eb;
      color: #0f172a;
    }
    body.light .tagline { color: #0f172a; }
    body.light .wallet-input-row label { color: #0f172a; }
    body.light .brand-name { color: #0f172a; }
    body.light .wallet-inputs-label { color: #0f172a; }

    body.light footer { border-top-color: #e5e7eb; }

    .liq-distance {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      min-width: 110px;
    }

    .liq-bar {
      position: relative;
      height: 8px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      overflow: hidden;
    }

    .liq-bar span {
      display: block;
      height: 100%;
      width: 0%;
      background: var(--accent);
      transition: width 0.3s ease;
    }

    .liq-distance.liq-danger .liq-bar span { background: var(--danger); }
    .liq-distance.liq-warn .liq-bar span { background: #f59e0b; }
    .liq-distance.liq-safe .liq-bar span { background: var(--accent); }
    .liq-distance.liq-high {
      box-shadow: 0 0 0 1px rgba(245, 158, 11, 0.35);
      border-radius: 8px;
      padding: 0.2rem 0.3rem;
      background: rgba(245, 158, 11, 0.08);
    }

    .liq-meta {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.35rem;
      font-size: 0.7rem;
      color: var(--muted);
      letter-spacing: 0.02em;
      white-space: nowrap;
    }

    .liq-pct {
      font-size: 0.7rem;
      color: var(--muted);
      letter-spacing: 0.02em;
    }

    .liq-price {
      font-size: 0.7rem;
      color: var(--muted);
      letter-spacing: 0.02em;
    }

    .liq-flag {
      font-size: 0.62rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: #fbbf24;
      margin-left: 0.35rem;
    }

    body.light .liq-bar {
      background: rgba(15, 23, 42, 0.1);
    }

    body.light .liq-meta,
    body.light .liq-pct,
    body.light .liq-price {
      color: #0f172a;
      opacity: 0.7;
    }

    .placeholder-row td {
      border-bottom: 1px solid var(--border);
      color: transparent; /* hides &nbsp; */
    }

    .desktop-only { display: revert; }
    .mobile-only { display: none; }
    @media (max-width: 600px) {
      .desktop-only { display: none !important; }
      .mobile-only { display: revert !important; }
    }

    .pill-action-btn {
      border-radius: 999px;
      border: 1px solid var(--glass-border);
      background: rgba(10, 10, 12, 0.45);
      color: #e2e8f0;
      padding: 0 0.9rem;
      font-size: 0.78rem;
      font-weight: 600;
      cursor: pointer;
      white-space: nowrap;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      height: var(--control-height);
    }

    .pill-action-btn:hover {
      border-color: rgba(255,255,255,0.22);
      background: rgba(18, 18, 24, 0.6);
      color: #f8fafc;
    }

    body.light .pill-action-btn {
      background: #ffffff;
      color: #475569;
      border-color: #e5e7eb;
    }

    body.light .pill-action-btn:hover {
      border-color: #d1d5db;
      color: #0f172a;
    }

    .portfolio-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.55);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      z-index: 999;
    }

    .portfolio-modal.open { display: flex; }

    .portfolio-modal .modal-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 14px;
      width: min(460px, 100%);
      padding: 1rem;
      box-shadow: 0 12px 36px rgba(0, 0, 0, 0.35);
      backdrop-filter: blur(8px);
    }

    body.light .portfolio-modal .modal-card {
      background: rgba(255, 255, 255, 0.9);
      border-color: #e5e7eb;
      color: #0f172a;
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .modal-header h3 {
      margin: 0;
      font-size: 1rem;
    }

    .modal-close-btn {
      border: none;
      background: transparent;
      color: var(--muted);
      cursor: pointer;
      font-size: 1.1rem;
      line-height: 1;
      padding: 0.2rem;
    }

    .modal-close-btn:hover { color: #fff; }
    body.light .modal-close-btn { color: #0f172a; }
    body.light .modal-close-btn:hover { color: #111827; }

    .modal-body {
      display: grid;
      gap: 0.75rem;
    }

    .portfolio-doughnut-wrap {
      width: 100%;
      height: 260px;
    }

    .breakdown-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 0.5rem;
      font-size: 0.85rem;
    }

    .breakdown-stat {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 0.6rem 0.75rem;
      background: #0f172a33;
    }

    body.light .breakdown-stat {
      background: #f8fafc;
      border-color: #e5e7eb;
    }

    .breakdown-label { color: var(--muted); }
    body.light .breakdown-label { color: #0f172a; }

    .metrics-card {
      margin-top: 0.35rem;
      padding-top: 0.3rem;
    }

    .metrics-card.loading {
      opacity: 0;
      pointer-events: none;
    }

    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
      gap: 0.65rem;
    }

    .metrics-card.collapsed .metrics-grid {
      max-height: none;
      overflow-x: auto;
      overflow-y: hidden;
      display: flex;
      flex-wrap: nowrap;
      gap: 0.65rem;
      padding-bottom: 0.65rem;
      position: relative;
      cursor: grab;
      user-select: none;
      scrollbar-width: none;
    }

    .metrics-card.collapsed .metrics-grid::-webkit-scrollbar {
      height: 0;
    }

    .metrics-card.collapsed .metric {
      min-width: 170px;
      flex: 0 0 auto;
    }

    .metrics-card.collapsed .metrics-grid:active {
      cursor: grabbing;
    }

    .metrics-card.collapsed .metrics-grid::before,
    .metrics-card.collapsed .metrics-grid::after {
      content: "";
      position: sticky;
      top: 0;
      width: 28px;
      height: 100%;
      pointer-events: none;
      z-index: 3;
    }

    .metrics-card.collapsed .metrics-grid::before {
      left: 0;
      background: linear-gradient(90deg, rgba(11, 11, 15, 0.85), rgba(11, 11, 15, 0));
    }

    .metrics-card.collapsed .metrics-grid::after {
      right: 0;
      background: linear-gradient(270deg, rgba(11, 11, 15, 0.85), rgba(11, 11, 15, 0));
    }

    body.light .metrics-card.collapsed .metrics-grid::before {
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0));
    }

    body.light .metrics-card.collapsed .metrics-grid::after {
      background: linear-gradient(270deg, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0));
    }

    .metrics-card {
      position: relative;
    }

    .metrics-scroll-arrow {
      position: absolute;
      top: 50%;
      width: 24px;
      height: 24px;
      border-radius: 999px;
      border: 1px solid var(--glass-border);
      background: rgba(10, 10, 12, 0.6);
      color: #e2e8f0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      z-index: 5;
      pointer-events: auto;
      opacity: 0;
      transition: opacity 0.15s ease;
      transform: translateY(-50%);
      cursor: pointer;
    }

    .metrics-scroll-arrow.left { left: 6px; }
    .metrics-scroll-arrow.right { right: 6px; }

    .metrics-card.show-left .metrics-scroll-arrow.left,
    .metrics-card.show-right .metrics-scroll-arrow.right {
      opacity: 0.85;
    }

    body.light .metrics-scroll-arrow {
      background: rgba(255, 255, 255, 0.85);
      color: #0f172a;
      border-color: #e5e7eb;
    }

    .metrics-toggle {
      border: 1px solid var(--glass-border);
      background: rgba(10, 10, 12, 0.45);
      color: var(--muted);
      border-radius: 999px;
      padding: 0 0.55rem;
      font-size: 0.7rem;
      font-weight: 600;
      cursor: pointer;
      line-height: 1;
      min-width: 32px;
      height: var(--control-height);
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .metrics-toggle:hover { color: #f8fafc; border-color: rgba(255,255,255,0.22); }
    body.light .metrics-toggle {
      background: #f8fafc;
      color: #334155;
      border-color: #d1d5db;
    }

    .positions-card .pill-action-btn,
    .positions-card .export-btn,
    .performance-title .pill-action-btn,
    .performance-title .metrics-toggle {
      height: 25px;
    }

    .metric {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 0.65rem 0.75rem;
      background: transparent;
      overflow: visible;
      cursor: pointer;
    }

    .metrics-grid {
      overflow: visible;
    }

    body.light .metric {
      border-color: #e5e7eb;
    }

    .metric-label {
      font-size: 0.62rem;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: var(--muted);
      position: relative;
      cursor: inherit;
    }

    .metric-value {
      font-size: 1.05rem;
      font-weight: 600;
      margin-top: 0.35rem;
      font-variant-numeric: tabular-nums;
    }

    .metric-value.positive { color: var(--accent); }
    .metric-value.negative { color: var(--danger); }

    .metric-sub {
      margin-top: 0.25rem;
      font-size: 0.7rem;
      color: var(--muted);
    }

    body.light .metric-label,
    body.light .metric-sub {
      color: #64748b;
    }

    .metric-tooltip {
      position: fixed;
      z-index: 2000;
      background: rgba(0, 0, 0, 0.7);
      color: #f1f5f9;
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 8px;
      padding: 0.4rem 0.55rem;
      font-size: 0.7rem;
      letter-spacing: 0.02em;
      text-transform: none;
      white-space: normal;
      width: max-content;
      max-width: 240px;
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.35);
      display: none;
      pointer-events: none;
    }

    .metric-tooltip.show {
      display: block;
    }

    .metric-tooltip::after {
      content: "";
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      border-style: solid;
    }

    .metric-tooltip[data-placement="top"]::after {
      bottom: -6px;
      border-width: 6px 6px 0 6px;
      border-color: rgba(0, 0, 0, 0.7) transparent transparent transparent;
    }

    .metric-tooltip[data-placement="bottom"]::after {
      top: -6px;
      border-width: 0 6px 6px 6px;
      border-color: transparent transparent rgba(0, 0, 0, 0.7) transparent;
    }

    body.light .metric-tooltip {
      background: rgba(15, 23, 42, 0.85);
      border-color: rgba(15, 23, 42, 0.4);
      color: #f8fafc;
    }

    body.light .metric-tooltip[data-placement="top"]::after {
      border-color: rgba(15, 23, 42, 0.85) transparent transparent transparent;
    }

    body.light .metric-tooltip[data-placement="bottom"]::after {
      border-color: transparent transparent rgba(15, 23, 42, 0.85) transparent;
    }

    .pnl-tooltip {
      position: absolute;
      transform: translate(-50%, -100%);
      background: rgba(0, 0, 0, 0.75);
      color: #e5e7eb;
      border: 1px solid rgba(148,163,184,0.5);
      border-radius: 6px;
      padding: 6px 8px;
      font-size: 0.75rem;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.12s ease;
      white-space: nowrap;
      z-index: 50;
    }

    .pnl-tooltip .pnl-tooltip-title {
      font-size: 0.7rem;
      color: #e5e7eb;
      font-weight: 600;
      margin-bottom: 4px;
    }

    /* Trades table: slightly denser and allow the last column to wrap so it fits without scrolling */
    .trades-live-panel table { font-size: 0.78rem; }
    .trades-live-panel th, .trades-live-panel td { padding: 0.3rem 0.35rem; }
    .trades-live-panel td.desktop-only.money:last-child {
      white-space: normal;
      word-break: break-word;
    }

    .price-footer {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 50;
      background: rgba(10, 10, 12, 0.9);
      border-top: 1px solid rgba(255, 255, 255, 0.12);
      backdrop-filter: blur(12px);
      box-shadow: 0 -12px 30px rgba(0, 0, 0, 0.4);
    }

    .price-footer-inner {
      max-width: 1520px;
      width: min(1520px, 86vw);
      margin: 0 auto;
      padding: 0.15rem 1.2rem;
      display: flex;
      align-items: center;
      gap: 0.6rem;
      flex-wrap: nowrap;
    }

    @media (max-width: 720px) {
      .price-footer-inner {
        width: 96vw;
      }
    }

    .price-logo {
      width: 28px;
      height: 28px;
      border-radius: 6px;
      flex: 0 0 auto;
    }

    .price-hint {
      font-size: 0.7rem;
      color: var(--muted);
      letter-spacing: 0.02em;
      margin-right: 0.4rem;
      flex: 0 0 auto;
    }

    .price-ticker {
      flex: 1 1 auto;
      overflow: hidden;
      min-width: 0;
    }

    .price-track {
      display: inline-flex;
      align-items: center;
      gap: 1.2rem;
      white-space: nowrap;
    }

    .price-list {
      display: flex;
      align-items: center;
      gap: 0.8rem;
      flex-wrap: wrap;
    }

    .price-list.clone {
      pointer-events: none;
      display: none;
    }

    .price-item {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      font-size: 0.78rem;
      color: var(--text-main);
      font-weight: 400;
      letter-spacing: 0.02em;
      cursor: grab;
      transition: transform 0.2s ease, opacity 0.2s ease;
    }

    .price-item.dragging {
      opacity: 0.6;
      transform: scale(0.96);
      cursor: grabbing;
    }

    .price-item img,
    .price-item .coinIcon {
      width: 16px;
      height: 16px;
      border-radius: 4px;
      object-fit: contain;
      background: transparent;
      padding: 0;
    }

    .price-item .coin-price {
      font-weight: 400;
      letter-spacing: 0.02em;
      font-variant-numeric: tabular-nums;
      display: inline-block;
      min-width: 6ch;
      text-align: right;
    }

    .price-item .coin-change {
      font-weight: 400;
      letter-spacing: 0.02em;
      font-variant-numeric: tabular-nums;
      display: inline-block;
      min-width: 7ch;
      text-align: right;
      color: var(--muted);
      margin-left: 0.25rem;
    }

    .price-item .coin-change.upnl-pos {
      color: rgba(74, 222, 128, 0.85);
    }

    .price-item .coin-change.upnl-neg {
      color: rgba(251, 113, 133, 0.85);
    }

    .price-footer.hide-change .coin-change {
      display: none;
    }

    .notional-sub {
      font-size: 0.72rem;
      color: var(--muted);
    }

    .roe-sub {
      color: inherit;
      opacity: 0.7;
    }

    .pnl-share-btn {
      margin-left: 0.35rem;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(10, 10, 12, 0.45);
      color: #e2e8f0;
      border-radius: 999px;
      width: 16px;
      height: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 0.6rem;
      padding: 0;
      pointer-events: auto;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.08);
      opacity: 0.6;
      transition: opacity 0.2s ease;
    }

    .position-row:hover .pnl-share-btn,
    .pnl-share-btn:focus-visible {
      opacity: 1;
    }

    .pnl-cell {
      position: relative;
    }

    .pnl-share-btn.centered {
      position: absolute;
      right: 6px;
      top: 50%;
      transform: translateY(-50%);
      margin-left: 0;
    }

    .pnl-share-btn:hover {
      border-color: rgba(255, 255, 255, 0.22);
      background: rgba(18, 18, 24, 0.6);
      color: #f8fafc;
    }

    .share-modal {
      position: fixed;
      inset: 0;
      background: rgba(5, 7, 12, 0.75);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 200;
    }

    .share-modal.open { display: flex; }

    .share-card {
      width: min(520px, 92vw);
      background: rgba(12, 12, 16, 0.96);
      border: 1px solid var(--glass-border);
      border-radius: 16px;
      padding: 1rem;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.45);
    }

    .share-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.6rem;
    }

    .share-preview {
      width: 100%;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: #0b0b0f;
      overflow: hidden;
    }

    .share-preview img {
      width: 100%;
      display: block;
    }

    .share-actions {
      margin-top: 0.8rem;
      display: flex;
      gap: 0.5rem;
      justify-content: flex-end;
      flex-wrap: wrap;
    }

    .share-btn {
      border-radius: 999px;
      border: 1px solid var(--glass-border);
      background: rgba(10, 10, 12, 0.45);
      color: #e2e8f0;
      padding: 0.4rem 0.9rem;
      font-size: 0.78rem;
      font-weight: 600;
      cursor: pointer;
      white-space: nowrap;
    }

    .share-btn:hover {
      border-color: rgba(255,255,255,0.22);
      background: rgba(18, 18, 24, 0.6);
      color: #f8fafc;
    }

    body.light .share-btn {
      background: #ffffff;
      color: #475569;
      border-color: #e5e7eb;
    }

    body.light .favorites-panel {
      background: rgba(226, 232, 240, 0.6);
    }

    body.light .favorites-card {
      background: rgba(255, 255, 255, 0.95);
      border-color: #e5e7eb;
      box-shadow: 0 16px 28px rgba(15, 23, 42, 0.12);
      color: #0f172a;
    }

    body.light .favorites-item {
      background: rgba(248, 250, 252, 0.9);
      border-color: #e5e7eb;
      color: #0f172a;
    }

    body.light .favorites-item:hover {
      border-color: rgba(15, 23, 42, 0.12);
      box-shadow: 0 10px 20px rgba(15, 23, 42, 0.12);
    }

    body.light .favorites-wallet-sub,
    body.light .favorites-wallet-full,
    body.light .favorites-metrics {
      color: #64748b;
    }

    body.light .favorites-wallet-btn,
    body.light .favorites-header {
      color: #0f172a;
    }

    body.light .favorites-chip {
      color: #475569;
      border-color: #cbd5f5;
    }

    body.light .favorites-close {
      color: #0f172a;
    }

    body.light .favorites-copy,
    body.light .favorites-add-btn,
    body.light .favorites-remove-btn,
    body.light .favorites-input {
      background: #ffffff;
      border-color: #e5e7eb;
      color: #475569;
    }

    body.light .favorites-copy:hover,
    body.light .favorites-add-btn:hover,
    body.light .favorites-remove-btn:hover {
      color: #0f172a;
      border-color: rgba(15, 23, 42, 0.2);
    }

    body.light .favorites-copy-toast {
      background: #ffffff;
      border-color: #e5e7eb;
      color: #475569;
    }

    .funding-pos { color: #4ade80; }
    .funding-neg { color: #fb7185; }

    .price-footer.rolling .price-list {
      flex-wrap: nowrap;
    }

    .price-footer.rolling .price-list.clone {
      display: inline-flex;
    }

    .price-footer.rolling .price-track {
      animation: priceScroll 24s linear infinite;
    }

    .price-context-menu {
      position: fixed;
      z-index: 220;
      min-width: 150px;
      background: rgba(12, 12, 16, 0.95);
      border: 1px solid var(--glass-border);
      border-radius: 10px;
      padding: 0.25rem;
      box-shadow: 0 16px 30px rgba(0, 0, 0, 0.45);
      display: none;
      backdrop-filter: blur(10px);
    }

    .price-context-menu.show { display: block; }

    .price-context-menu[data-has-coin="false"] .price-context-item[data-requires-coin="true"] {
      display: none;
    }

    .price-context-item {
      width: 100%;
      background: none;
      border: none;
      color: var(--text-main);
      text-align: left;
      padding: 0.45rem 0.65rem;
      font-size: 0.75rem;
      border-radius: 8px;
      cursor: pointer;
    }

    .price-context-item:hover {
      background: rgba(255, 255, 255, 0.08);
    }

    .price-context-sep {
      height: 1px;
      background: rgba(148, 163, 184, 0.2);
      margin: 0.25rem 0.1rem;
    }

    .price-context-menu.hide-change-options [data-action="change-range"],
    .price-context-menu.hide-change-options .price-context-submenu,
    .price-context-menu.hide-change-options .price-context-sep {
      display: none;
    }

    .price-context-group {
      position: relative;
      padding-right: 6px;
    }

    .price-context-submenu {
      position: absolute;
      top: auto;
      bottom: 0;
      left: 100%;
      margin-left: -2px;
      min-width: 150px;
      background: rgba(12, 12, 16, 0.95);
      border: 1px solid var(--glass-border);
      border-radius: 10px;
      padding: 0.25rem;
      box-shadow: 0 16px 30px rgba(0, 0, 0, 0.45);
      display: none;
      backdrop-filter: blur(10px);
    }

    .price-context-group:hover .price-context-submenu,
    .price-context-group:focus-within .price-context-submenu {
      display: block;
    }

    .price-context-item[data-has-submenu="true"]::after {
      content: "â€º";
      float: right;
      color: rgba(148, 163, 184, 0.7);
    }

    @keyframes priceScroll {
      from { transform: translateX(0); }
      to { transform: translateX(-50%); }
    }

    .price-controls {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      margin-left: auto;
    }

    .price-input {
      padding: 0.3rem 0.5rem;
      border-radius: 8px;
      border: 1px solid var(--glass-border);
      background: rgba(10, 10, 12, 0.35);
      color: #e2e8f0;
      font-size: 0.72rem;
      outline: none;
      width: 90px;
      text-transform: uppercase;
    }

    .price-input:focus {
      border-color: rgba(255,255,255,0.7);
      box-shadow: 0 0 0 1px rgba(255,255,255,0.35);
    }

    .price-add-btn {
      border: 1px solid var(--glass-border);
      background: rgba(10, 10, 12, 0.45);
      color: #e2e8f0;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      font-size: 0.7rem;
      font-weight: 400;
      cursor: pointer;
      transition: background 0.15s ease, border-color 0.15s ease, color 0.15s ease;
    }

    .price-add-btn:hover {
      border-color: rgba(255,255,255,0.22);
      background: rgba(18, 18, 24, 0.6);
      color: #f8fafc;
    }

    body.light .price-footer {
      background: rgba(255, 255, 255, 0.9);
      border-top-color: #e5e7eb;
      box-shadow: 0 -12px 24px rgba(15, 23, 42, 0.08);
    }

    body.light .price-item {
      color: #0f172a;
    }

    body.light .price-input {
      background: #ffffff;
      border-color: #e5e7eb;
      color: #0f172a;
    }
    body.light .price-add-btn {
      border-color: #e5e7eb;
      background: #ffffff;
      color: #0f172a;
    }
    body.light .wallet-track-btn {
      border-color: #e5e7eb;
      background: #f8fafc;
      color: #475569;
    }

    .wallet-tag {
      display: inline-flex;
      align-items: center;
      padding: 0.12rem 0.4rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      color: var(--muted);
      font-size: 0.55rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      background: rgba(148, 163, 184, 0.12);
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.08);
      margin-left: 0.35rem;
      white-space: nowrap;
    }
  </style>
</head>

<body>
<div id="app">
  <header>
    <div class="wallet-controls">
      <a class="brand" href="/" aria-label="Hypermonitor home">
        <img src="images/logo.png" alt="Hypermonitor logo" style="width: 2.8rem; height: auto; border-radius: 4px;" />
        <h1 class="brand-name"><span class="hyper">Hyper</span><em>monitor</em></h1>
      </a>
      <div class="tagline">
        Track any Hyperliquid wallet. No account required.
      </div>
      <div class="wallet-inputs-label">Wallet addresses</div>
      <div class="wallet-inputs-row">
        <div class="wallet-inputs" id="walletInputs">
          <div class="wallet-input-row" data-index="0">
            <input id="walletInput0" class="wallet-input" type="text" placeholder="0x..." autocomplete="off" aria-label="Wallet address" />
            <div class="wallet-input-actions">
              <button class="wallet-fav-btn" type="button" aria-label="Favorite wallet">â˜†</button>
              <button id="addWalletBtn" class="wallet-icon-btn" type="button" aria-label="Add wallet">+</button>
            </div>
          </div>
        </div>
        <div class="wallet-actions">
          <button id="trackBtn" class="wallet-track-btn" aria-label="Track wallets">
            <span class="sr-only">Track wallets</span>
            âŽ
          </button>
        </div>
      </div>
    </div>

    <div class="header-right">
      <div class="header-right-top">
        <button id="themeToggle" class="theme-toggle-btn">â˜€ï¸</button>
        <button id="favoritesPanelBtn" class="theme-toggle-btn favorites-panel-btn" type="button" aria-label="Favorite wallets" title="Favorite wallets">
          â˜…
        </button>
        <div class="status-pill">
          <span id="statusDot" class="status-dot"></span>
          <span id="statusText"></span>
          <img id="statusSpinner" class="status-spinner" alt="Connecting to Hyperliquid" />
          <span class="status-logo hidden" aria-hidden="true">
            <a href="https://app.hyperliquid.xyz/join/HYPERMONITOR" target="_blank" rel="noopener noreferrer" class="status-logo-link">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 179 28">
                <g clip-path="url(#clip0_975_1209)" fill="currentColor">
                    <path d="M31.8056 11.727C31.8346 14.3384 31.2881 16.8337 30.2146 19.2178C28.6816 22.6126 25.0063 25.3885 21.6501 22.4337C18.913 20.0254 18.4052 15.1363 14.3044 14.4206C8.87845 13.7629 8.74788 20.0544 5.20315 20.7653C1.2522 21.5681 -0.0583338 14.9235 -0.000302664 11.9059C0.0577284 8.88828 0.860492 4.64717 4.294 4.64717C8.24495 4.64717 8.51092 10.6292 13.5258 10.3052C18.4923 9.96669 18.5793 3.74285 21.8242 1.07826C24.6242 -1.22364 27.9175 0.464096 29.5665 3.23508C31.0947 5.79812 31.7669 8.80606 31.8007 11.727H31.8056Z"/>
                    <path d="M46.7054 21.8777V1.68286H48.6204V10.4165H60.4297V1.68286H62.3157V21.8777H60.4297V12.0414H48.6204V21.8777H46.7054Z"/>
                    <path d="M67.316 27.9999L69.9274 21.5004L64.2694 7.92114H66.2425L69.9565 17.1191C70.1692 17.68 70.4691 18.4248 70.8559 19.3533C70.914 19.2179 70.972 19.0679 71.03 18.9035C71.0881 18.7391 71.1461 18.5892 71.2041 18.4538C71.3202 18.2023 71.4217 17.9654 71.5088 17.7429C71.5958 17.5205 71.6781 17.3028 71.7554 17.0901L75.2373 7.92114H77.1233L69.2021 27.9999H67.316Z"/>
                    <path d="M79.0383 28.0001V7.92135H80.8372V10.4747C81.3015 9.60426 81.9737 8.89338 82.8538 8.34208C83.734 7.79078 84.7156 7.51514 85.7989 7.51514C87.0949 7.51514 88.2217 7.82947 89.1792 8.45814C90.1367 9.08681 90.8718 9.95728 91.3844 11.0695C91.897 12.1818 92.1533 13.444 92.1533 14.8561C92.1533 16.2682 91.8873 17.5642 91.3554 18.6861C90.8234 19.8081 90.0738 20.6882 89.1067 21.3265C88.1395 21.9649 87.0369 22.284 85.7989 22.284C84.7543 22.284 83.792 22.0326 82.9118 21.5296C82.0317 21.0267 81.3402 20.2916 80.8372 19.3245V28.0001H79.0383ZM85.5378 20.8333C86.4856 20.8333 87.3222 20.5818 88.0476 20.0789C88.773 19.5759 89.3291 18.8747 89.716 17.9752C90.1029 17.0758 90.2963 16.036 90.2963 14.8561C90.2963 13.6761 90.098 12.6992 89.7015 11.8094C89.3049 10.9196 88.7488 10.2281 88.0331 9.73483C87.3174 9.24156 86.4856 8.99493 85.5378 8.99493C84.5899 8.99493 83.7823 9.23673 83.0569 9.72032C82.3315 10.2039 81.7657 10.8906 81.3595 11.7804C80.9533 12.6702 80.7502 13.6954 80.7502 14.8561C80.7502 16.0167 80.9533 17.0758 81.3595 17.9752C81.7657 18.8747 82.3267 19.5759 83.0424 20.0789C83.7581 20.5818 84.5899 20.8333 85.5378 20.8333Z"/>
                    <path d="M100.742 22.284C99.4267 22.284 98.2709 21.9939 97.2747 21.4136C96.2785 20.8333 95.5048 19.9821 94.9535 18.8602C94.4022 17.7383 94.1265 16.3939 94.1265 14.8271C94.1265 13.4343 94.4118 12.1818 94.9825 11.0695C95.5531 9.95728 96.3317 9.08681 97.3182 8.45814C98.3048 7.82947 99.4074 7.51514 100.626 7.51514C101.941 7.51514 103.063 7.81496 103.992 8.41462C104.92 9.01427 105.626 9.86056 106.11 10.9535C106.594 12.0464 106.835 13.3182 106.835 14.769V15.1462H95.9255C95.9255 16.3455 96.1286 17.3708 96.5348 18.2219C96.941 19.073 97.5117 19.721 98.2467 20.1659C98.9818 20.6108 99.8232 20.8333 100.771 20.8333C101.893 20.8333 102.826 20.5673 103.571 20.0353C104.316 19.5034 104.775 18.7055 104.949 17.6416H106.748C106.613 18.5314 106.299 19.3245 105.805 20.0208C105.312 20.7172 104.635 21.2685 103.774 21.6747C102.913 22.0809 101.903 22.284 100.742 22.284ZM104.92 13.7825C104.901 12.3317 104.514 11.1711 103.76 10.3006C103.005 9.43016 101.961 8.99493 100.626 8.99493C99.2913 8.99493 98.2612 9.44467 97.4198 10.3442C96.5783 11.2436 96.0996 12.3897 95.9835 13.7825H104.92Z"/>
                    <path d="M109.616 21.8778V7.92135H111.415V10.7068C111.802 9.77835 112.406 9.01427 113.228 8.41462C114.05 7.81496 115.013 7.51514 116.115 7.51514C116.386 7.51514 116.647 7.53448 116.899 7.57317V9.3141C116.57 9.27541 116.28 9.25607 116.028 9.25607C115.1 9.25607 114.287 9.46401 113.591 9.8799C112.895 10.2958 112.358 10.8906 111.981 11.6644C111.603 12.4381 111.415 13.3376 111.415 14.3628V21.8778H109.616Z"/>
                    <path d="M121.367 21.491L121.285 21.8827H115.593L115.675 21.491C117.247 21.3217 117.89 20.872 118.142 19.6969L121.338 4.63295C121.677 3.09029 121.198 2.83883 119.573 3.17251L119.655 2.7808L123.132 1.60083H123.524L119.679 19.692C119.428 20.872 119.849 21.3169 121.362 21.4861L121.367 21.491Z"/>
                    <path d="M127.78 21.4909L127.697 21.8826H122.006L122.088 21.4909C123.659 21.3216 124.303 20.8719 124.554 19.6967L126.488 10.523C126.827 8.9513 126.377 8.72885 124.723 9.06253L124.806 8.67082L128.283 7.49085H128.674L126.092 19.6919C125.84 20.8719 126.261 21.3168 127.775 21.486L127.78 21.4909ZM128.732 2.41797C129.492 2.41797 129.995 3.00795 129.912 3.76236C129.801 4.5216 129.129 5.08256 128.399 5.08256C127.615 5.08256 127.078 4.5216 127.194 3.76236C127.277 3.00312 127.954 2.41797 128.737 2.41797H128.732Z"/>
                    <path d="M137.582 25.9255L139.144 18.7103C138.162 20.8429 136.117 22.2985 133.955 22.2985C130.478 22.2985 128.848 19.0149 129.888 14.1065C130.618 10.5424 133.815 7.48608 137.601 7.48608C139.342 7.48608 140.769 8.2695 141.359 9.42045L142.679 7.48608H143.071L139.125 25.9158C138.844 27.178 139.855 27.4294 140.866 27.5987L140.783 27.9904H134.25L134.332 27.5987C136.213 27.4294 137.306 27.178 137.587 25.9158L137.582 25.9255ZM134.884 21.2636C136.678 21.2636 138.472 19.721 139.313 17.8688L140.493 12.3414C140.803 10.349 139.85 8.27434 137.127 8.27434C134.405 8.27434 132.277 10.6294 131.576 14.0774C130.676 18.3137 131.938 21.2588 134.884 21.2588V21.2636Z"/>
                    <path d="M162.531 21.4909L162.448 21.8826H156.756L156.839 21.4909C158.41 21.3216 159.054 20.8719 159.305 19.6967L161.239 10.523C161.578 8.9513 161.128 8.72885 159.474 9.06253L159.556 8.67082L163.034 7.49085H163.425L160.843 19.6919C160.591 20.8719 161.012 21.3168 162.526 21.486L162.531 21.4909ZM163.483 2.41797C164.242 2.41797 164.745 3.00795 164.663 3.76236C164.552 4.5216 163.88 5.08256 163.15 5.08256C162.366 5.08256 161.829 4.5216 161.945 3.76236C162.028 3.00312 162.705 2.41797 163.488 2.41797H163.483Z"/>
                    <path d="M154.45 19.6628L155.741 13.5018L157.013 7.49561H156.621L153.144 8.67557L153.062 9.06728C154.687 8.72877 155.165 8.95605 154.827 10.5277L153.173 18.3523C151.35 20.0642 150.059 21.0749 148.487 21.0749C146.553 21.0749 145.542 19.7547 146.021 17.4866L148.153 7.50044H147.762L144.255 8.68041L144.173 9.07212C145.827 8.7336 146.277 8.96089 145.967 10.5326L144.454 17.7139C143.864 20.3785 145.213 22.3129 147.708 22.3129C149.362 22.3129 150.818 21.3892 153.057 18.9858L152.95 19.4935V19.5177H152.946L152.443 21.897H156.055L156.137 21.4714C154.624 21.3022 154.203 20.8524 154.454 19.6773L154.45 19.6628Z"/>
                    <path d="M177.696 6.96871L178.828 1.60083H178.436L174.959 2.7808L174.877 3.17251C176.502 2.83399 176.98 3.09029 176.642 4.63295L175.66 9.2029C175.041 8.16318 173.697 7.49099 172.125 7.49099C168.309 7.49099 165.142 10.5183 164.33 14.3628C163.348 19.0198 164.949 22.2986 168.455 22.2986C170.64 22.2986 172.72 20.814 173.673 18.6813L173.421 19.9048L173 21.8779L176.613 21.8488L176.695 21.4571C175.181 21.2879 174.761 20.8381 175.012 19.663L177.691 6.96871H177.696ZM173.837 17.8399C172.996 19.721 171.201 21.2637 169.378 21.2637C166.433 21.2637 165.171 18.3186 166.012 14.3338C166.796 10.6295 169.04 8.27441 171.651 8.27441C174.437 8.27441 175.365 10.4844 174.998 12.4962L174.867 13.1055L173.842 17.8399H173.837Z"/>
                </g>
                <defs>
                  <clipPath id="clip0_975_1209">
                    <rect width="178.832" height="28" fill="white"/>
                  </clipPath>
                </defs>
              </svg>
            </a>
          </span>
        </div>
      </div>
      <div class="timestamp" id="startedAt"></div>
    </div>
  </header>

  <div class="grid">
    <section class="card">
      <div class="section-title">
        <h2>Account Overview</h2>
        <span class="market-toggle no-label" role="group" aria-label="Market type">
          <span class="market-toggle-label">Market</span>
          <span class="orders-tabs" role="tablist">
            <span class="market-toggle-indicator" aria-hidden="true"></span>
            <button class="orders-tab-btn market-tab-btn active" data-market="perp" type="button" aria-pressed="true">Perps</button>
            <button class="orders-tab-btn market-tab-btn" data-market="spot" type="button" aria-pressed="false">Spot</button>
            <button class="orders-tab-btn market-tab-btn" data-market="all" type="button" aria-pressed="false">All</button>
          </span>
        </span>
      </div>
      <div id="marginSummary"><span class="muted">Loadingâ€¦</span></div>
      <div class="error" id="snapshotError"></div>
    </section>

    <section class="card positions-card" style="overflow: auto;">
      <div class="section-title">
        <h2>Positions</h2>
        <div class="section-actions">
          <button id="positionsChartBtn" class="pill-action-btn" aria-label="Pie chart">
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" style="width:14px;height:14px;">
              <path d="M11 2a10 10 0 1 0 10 10h-9z" fill="currentColor"/>
              <path d="M13 2.05V11h8.95A10 10 0 0 0 13 2.05z" fill="currentColor" opacity="0.6"/>
            </svg>
          </button>
          <button id="exportExcelBtn" class="export-btn" aria-label="Export Excel">
            <svg class="export-icon" viewBox="0 0 24 24" fill="none" aria-hidden="true" focusable="false">
              <path d="M12 3v11" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M8 10l4 4 4-4" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M5 18h14" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"/>
            </svg>
            <span class="sr-only">Export Excel</span>
          </button>
        </div>
      </div>
      <table>
        <thead>
        <tr>
          <th class="sortable" data-sort="asset">Asset</th>
          <th class="sortable" data-sort="side">Side</th>
          <th class="sortable" data-sort="size">Size</th>
          <th class="sortable" data-sort="price">Price</th>
          <th class="desktop-only sortable" data-sort="age">Age</th>
          <th class="desktop-only sortable" data-sort="upnl">Unrealized PnL</th>
          <th class="desktop-only sortable" data-sort="liq">Liq Distance</th>
          <th class="desktop-only sortable" data-sort="funding">Funding</th>
          <th class="mobile-only sortable" data-sort="upnl">PnL</th>
        </tr>
        </thead>
        <tbody id="positionsBody">
        <tr class="loading-row mobile-only">
          <td class="muted">Loadingâ€¦</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        <tr class="loading-row desktop-only">
          <td class="muted">Loadingâ€¦</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
        </tr>
        </tbody>
      </table>
    </section>
  </div>

  <div class="portfolio-modal" id="portfolioModal">
    <div class="modal-card">
      <div class="modal-header">
        <h3>Portfolio breakdown</h3>
        <button id="portfolioModalClose" class="modal-close-btn" aria-label="Close portfolio breakdown">&times;</button>
      </div>
      <div class="modal-body">
        <div class="portfolio-doughnut-wrap">
          <canvas id="portfolioDoughnut"></canvas>
        </div>
        <div class="breakdown-stats">
          <div class="breakdown-stat">
            <div class="breakdown-label">Open positions value</div>
            <div class="money" id="positionsValueStat">$0.00</div>
          </div>
          <div class="breakdown-stat">
            <div class="breakdown-label">Withdrawable</div>
            <div class="money" id="withdrawableValueStat">$0.00</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <section class="card">
    <div class="section-title performance-title">
      <h2>Performance</h2>
      <div class="performance-toolbar is-hidden" id="performanceToolbar">
        <div class="chart-toolbar">
          <span class="range-toggle" role="tablist" aria-label="Performance range">
            <span class="range-toggle-indicator" aria-hidden="true"></span>
            <button class="chart-range-btn" data-range="day">Day</button>
            <button class="chart-range-btn" data-range="week">Week</button>
            <button class="chart-range-btn" data-range="month">Month</button>
            <button class="chart-range-btn active" data-range="allTime">All</button>
          </span>
        </div>
      </div>
      <div class="chart-actions is-hidden" id="performanceActions">
        <button class="pill-action-btn performance-share-btn" id="performanceShareBtn" type="button" title="Share performance" aria-label="Share performance">
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" style="width:10px;height:10px;">
            <path d="M14 3h7v7" stroke="currentColor" stroke-width="1.7" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M10 14L21 3" stroke="currentColor" stroke-width="1.7" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M21 14v5a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5" stroke="currentColor" stroke-width="1.7" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
        <button class="metrics-toggle" id="metricsToggle" type="button" aria-expanded="false">
          <span class="sr-only">Toggle metrics</span>
          <span aria-hidden="true">â–¾</span>
        </button>
      </div>
    </div>

    <div class="chart-loading-wrap loading" id="portfolioLoadingWrap">
      <div class="chart-grid" id="portfolioCharts">
        <div class="chart-card">
          <h3>Equity <span class="spark-label" id="equityTitleValue">[-]</span></h3>
          <div class="chart-canvas-wrap">
            <canvas id="equityChart"></canvas>
          </div>
        </div>

        <div class="chart-card">
          <h3>Profit & Loss <span class="spark-label" id="pnlTitleValue">[-]</span></h3>
          <div class="chart-canvas-wrap">
            <canvas id="pnlChart"></canvas>
          </div>
        </div>

        <div class="chart-card">
          <h3>Deposits & Withdrawals <span class="spark-label" id="depositsTitleValue">[-]</span></h3>
          <div class="chart-canvas-wrap">
            <canvas id="depositsChart"></canvas>
          </div>
        </div>
      </div>

      <div class="metrics-card collapsed loading" id="metricsCard">
      <button class="metrics-scroll-arrow left" type="button" aria-label="Scroll metrics left">â€¹</button>
      <button class="metrics-scroll-arrow right" type="button" aria-label="Scroll metrics right">â€º</button>
      <div class="metrics-grid">
        <div class="metric">
          <div class="metric-label" title="Net change in portfolio PnL over the selected range." data-tooltip="Net change in portfolio PnL over the selected range.">Total PnL</div>
          <div class="metric-value" id="metricTotalPnl">-</div>
          <div class="metric-sub" id="metricTotalPnlSub">PnL change over range</div>
        </div>
        <div class="metric">
          <div class="metric-label" title="PnL change divided by total deposits in the range." data-tooltip="PnL change divided by total deposits in the range.">Return</div>
          <div class="metric-value" id="metricReturn">-</div>
          <div class="metric-sub">PnL vs initial account value</div>
        </div>
        <div class="metric">
          <div class="metric-label" title="Largest peak-to-trough drop vs deposit baseline." data-tooltip="Largest peak-to-trough drop vs deposit baseline.">Max Drawdown</div>
          <div class="metric-value" id="metricMaxDrawdown">-</div>
          <div class="metric-sub">Peak-to-trough vs initial</div>
        </div>
        <div class="metric">
          <div class="metric-label" title="Average PnL change divided by its volatility." data-tooltip="Average PnL change divided by its volatility.">Sharpe (PnL)</div>
          <div class="metric-value" id="metricSharpe">-</div>
          <div class="metric-sub">Mean / stdev of PnL deltas</div>
        </div>
        <div class="metric">
          <div class="metric-label" title="Standard deviation of PnL changes." data-tooltip="Standard deviation of PnL changes.">PnL Volatility</div>
          <div class="metric-value" id="metricVolatility">-</div>
          <div class="metric-sub">Stdev of PnL deltas</div>
        </div>
        <div class="metric">
          <div class="metric-label" title="Largest positive PnL change between adjacent points." data-tooltip="Largest positive PnL change between adjacent points.">Best Interval</div>
          <div class="metric-value" id="metricBestInterval">-</div>
          <div class="metric-sub">Largest positive delta</div>
        </div>
        <div class="metric">
          <div class="metric-label" title="Realized PnL from matched closed positions." data-tooltip="Realized PnL from matched closed positions.">Realized PnL (Fills)</div>
          <div class="metric-value" id="metricRealizedPnl">-</div>
          <div class="metric-sub">From matched closed positions</div>
        </div>
        <div class="metric">
          <div class="metric-label" title="Share of closed positions that were profitable." data-tooltip="Share of closed positions that were profitable.">Win Rate</div>
          <div class="metric-value" id="metricWinRate">-</div>
          <div class="metric-sub">Closed positions with profit</div>
        </div>
        <div class="metric">
          <div class="metric-label" title="Total gains divided by total losses on closed positions." data-tooltip="Total gains divided by total losses on closed positions.">Profit Factor</div>
          <div class="metric-value" id="metricProfitFactor">-</div>
          <div class="metric-sub">Gains / losses</div>
        </div>
        <div class="metric">
        <div class="metric-label" title="Average submitted orders and executed trades per day." data-tooltip="Average submitted orders and executed trades per day.">Orders (Trades) / Day</div>
          <div class="metric-value" id="metricOrdersTradesPerDay">-</div>
          <div class="metric-sub">Submitted (executed) per day</div>
        </div>
        <div class="metric">
          <div class="metric-label" title="Days with at least one trade divided by observed days." data-tooltip="Days with at least one trade divided by observed days.">Active Days Ratio</div>
          <div class="metric-value" id="metricActiveDays">-</div>
          <div class="metric-sub">Days with trades / observed</div>
        </div>
        <div class="metric">
          <div class="metric-label" title="Number of unique products traded." data-tooltip="Number of unique products traded.">Product Count</div>
          <div class="metric-value" id="metricProductCount">-</div>
          <div class="metric-sub">Unique traded products</div>
        </div>
        <div class="metric">
          <div class="metric-label" title="Herfindahl index of notional by product (higher = more concentrated)." data-tooltip="Herfindahl index of notional by product (higher = more concentrated).">Volume Concentration</div>
          <div class="metric-value" id="metricHerfindahl">-</div>
          <div class="metric-sub">Herfindahl index</div>
        </div>
        <div class="metric">
          <div class="metric-label" title="Average absolute price times size per trade." data-tooltip="Average absolute price times size per trade.">Avg Trade Notional</div>
          <div class="metric-value" id="metricAvgNotional">-</div>
          <div class="metric-sub">Mean |price * size|</div>
        </div>
        <div class="metric">
          <div class="metric-label" title="Count of days with at least one trade." data-tooltip="Count of days with at least one trade.">Days Active</div>
          <div class="metric-value" id="metricActiveDaysCount">-</div>
          <div class="metric-sub">Days with at least 1 trade</div>
        </div>
        <div class="metric">
          <div class="metric-label" title="Median holding duration for closed positions." data-tooltip="Median holding duration for closed positions.">Median Holding Time</div>
          <div class="metric-value" id="metricMedianHolding">-</div>
          <div class="metric-sub">Typical position duration</div>
        </div>
        <div class="metric">
          <div class="metric-label" title="Notional buy minus sell, normalized by total notional." data-tooltip="Notional buy minus sell, normalized by total notional.">Buy-Sell Imbalance</div>
          <div class="metric-value" id="metricSideBias">-</div>
          <div class="metric-sub">Notional bias</div>
        </div>
        <div class="metric">
          <div class="metric-label" title="Share of market orders among all orders." data-tooltip="Share of market orders among all orders.">Order Aggressiveness</div>
          <div class="metric-value" id="metricAggressiveness">-</div>
          <div class="metric-sub">Market orders / total</div>
        </div>
        <div class="metric">
          <div class="metric-label" title="Canceled orders divided by total submitted orders." data-tooltip="Canceled orders divided by total submitted orders.">Cancel Ratio</div>
          <div class="metric-value" id="metricCancelRatio">-</div>
          <div class="metric-sub">Canceled / submitted</div>
        </div>
        <div class="metric">
          <div class="metric-label" title="Average time from order submission to fill." data-tooltip="Average time from order submission to fill.">Reaction Speed</div>
          <div class="metric-value" id="metricReactionSpeed">-</div>
          <div class="metric-sub">Order submit to fill</div>
        </div>
        <div class="metric">
          <div class="metric-label" title="Weekly PnL volatility relative to weekly mean." data-tooltip="Weekly PnL volatility relative to weekly mean.">PnL Stability</div>
          <div class="metric-value" id="metricPnlStability">-</div>
          <div class="metric-sub">Weekly CV</div>
        </div>
        <div class="metric">
          <div class="metric-label" title="Autocorrelation of weekly PnL." data-tooltip="Autocorrelation of weekly PnL.">Skill Persistence</div>
          <div class="metric-value" id="metricSkillPersistence">-</div>
          <div class="metric-sub">Weekly autocorrelation</div>
        </div>
        <div class="metric">
          <div class="metric-label" title="PnL minus a BTC benchmark over the same window." data-tooltip="PnL minus a BTC benchmark over the same window.">Excess PnL</div>
          <div class="metric-value" id="metricExcessPnl">-</div>
          <div class="metric-sub">Vs benchmark (BTC)</div>
        </div>
        <div class="metric">
          <div class="metric-label" title="Sensitivity to BTC (beta) and regression intercept (alpha)." data-tooltip="Sensitivity to BTC (beta) and regression intercept (alpha).">Beta & Alpha</div>
          <div class="metric-value" id="metricBetaAlpha">-</div>
          <div class="metric-sub">PnL vs BTC</div>
        </div>
      </div>
      </div>
      <div class="spot-performance-note is-hidden" id="spotPerformanceNote">
        Spot charts are derived from total account value minus perps.
      </div>

      <div class="chart-loading" id="portfolioLoading">Loading performance dataâ€¦</div>
    </div>
    <div class="error" id="portfolioError"></div>
  </section>

  <div class="metric-tooltip" id="metricTooltip" role="tooltip" aria-hidden="true"></div>

  <p></p>

  <section class="card" id="liveLayout">
    <div class="section-title">
      <h2>Orders</h2>
      <div class="orders-tabs switch" id="modeTabs">
        <span class="orders-tabs-indicator" aria-hidden="true"></span>
        <button class="orders-tab-btn mode-tab-btn active" data-tab="live" aria-label="Live">
          <span class="live-dot" aria-hidden="true"></span>
          <span>Live</span>
        </button>
        <button class="orders-tab-btn mode-tab-btn" data-tab="history" aria-label="History">
          <span class="history-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24" focusable="false">
              <path d="M12 8v5l4 2" stroke="currentColor" stroke-width="1.6" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M4 12a8 8 0 1 0 3-6.3" stroke="currentColor" stroke-width="1.6" fill="none" stroke-linecap="round"/>
              <path d="M4 4v4h4" stroke="currentColor" stroke-width="1.6" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </span>
          <span>History</span>
        </button>
      </div>
    </div>

    <div class="layout-two">
      <section class="orders-live-panel">
        <div id="ordersLivePanel" class="tab-panel">
          <div class="section-title">
            <span>Open</span>
            <small id="openOrdersCount">â€“</small>
          </div>
          <div style="height: 160px; overflow: auto; margin-bottom: .75rem;">
            <table>
              <thead>
              <tr>
                <th class="desktop-only">Order ID</th>
                <th class="desktop-only">Time</th>  
                <th style="width: 20%;">Asset</th>
                <th>Side</th>
                <th>Size</th>
                <th class="desktop-only">Type</th>
                <th class="desktop-only">Limit Price</th>
                <th class="mobile-only">Price</th>
              </tr>
              </thead>
              <tbody id="openOrdersBody">
              <tr><td colspan="8" class="muted">Loading open ordersâ€¦</td></tr>
              </tbody>
            </table>
          </div>

          <div class="section-title">
            <span>Canceled</span>
            <small id="canceledCount">â€“</small>
          </div>
          <div style="max-height: 160px; overflow: auto;">
            <table>
              <thead>
              <tr>
                <th class="desktop-only">Order ID</th>
                <th>Time</th>
                <th>Asset</th>
                <th>Side</th>
                <th class="desktop-only">Type</th>
                <th>Size</th>
                <th class="mobile-only">Price</th>
              </tr>
              </thead>
              <tbody id="canceledOrdersBody">
              <tr><td colspan="7" class="muted">No canceled orders yet.</td></tr>
              </tbody>
            </table>
          </div>

          <div class="error" id="ordersError"></div>
        </div>
      </section>

      <section class="trades-live-panel">
        <div id="fillsLivePanel" class="tab-panel">
          <div class="section-title">
            <span>Filled</span>
            <small id="fillsCount">â€“</small>
          </div>
          <div style="max-height: 360px; overflow: auto;">
            <table>
              <thead>
              <tr>
                <th class="desktop-only">Order ID</th>
                <th class="desktop-only">Time</th>
                <th>Asset</th>
                <th>Side</th>
                <th>Size</th>
                <th>Price</th>
                <th class="desktop-only">Type</th>
              </tr>
              </thead>
              <tbody id="fillsBody">
              <tr><td colspan="7" class="muted">Waiting for fillsâ€¦</td></tr>
              </tbody>
            </table>
          </div>
          <div class="error" id="fillsError"></div>
        </div>
      </section>
    </div>
  </section>

  <section class="card tab-panel hidden" id="historyLayout">
    <div class="section-title">
      <h2>History</h2>
      <div class="orders-tabs switch" id="modeTabsHistory">
        <span class="orders-tabs-indicator" aria-hidden="true"></span>
        <button class="orders-tab-btn mode-tab-btn active" data-tab="live" aria-label="Live">
          <span class="live-dot" aria-hidden="true"></span>
          <span>Live</span>
        </button>
        <button class="orders-tab-btn mode-tab-btn" data-tab="history" aria-label="History">
          <span class="history-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24" focusable="false">
              <path d="M12 8v5l4 2" stroke="currentColor" stroke-width="1.6" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M4 12a8 8 0 1 0 3-6.3" stroke="currentColor" stroke-width="1.6" fill="none" stroke-linecap="round"/>
              <path d="M4 4v4h4" stroke="currentColor" stroke-width="1.6" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </span>
          <span>History</span>
        </button>
      </div>
    </div>

    <div class="section-title history-tabs-row">
      <div class="orders-tabs switch" id="historyTabs">
        <span class="orders-tabs-indicator" aria-hidden="true"></span>
        <button class="orders-tab-btn history-tab-btn active" data-tab="orders-history" aria-label="Historical Orders">
          <span>Orders</span>
        </button>
        <button class="orders-tab-btn history-tab-btn" data-tab="fills-history" aria-label="Historical Trades">
          <span>Trades</span>
        </button>
      </div>
    </div>

    <div id="ordersHistoryPanel" class="tab-panel">
      <div class="section-title">
        <span>Historical (last 2000)</span>
        <small id="historicalOrdersCount">â€“</small>
      </div>

      <div class="orders-filter-bar">
        <div class="orders-filter-group">
          <span class="orders-filter-label">Asset</span>
          <input
            id="historicalAssetFilter"
            class="orders-filter-input"
            type="text"
            placeholder="e.g. ETH"
            autocomplete="off"
          />
        </div>

        <div class="orders-filter-group">
          <span class="orders-filter-label">Side</span>
          <select id="historicalSideFilter" class="orders-filter-select">
            <option value="all">All</option>
            <option value="B">Buy</option>
            <option value="S">Sell</option>
          </select>
        </div>

        <div class="orders-filter-group">
          <span class="orders-filter-label">Status</span>
          <select id="historicalStatusFilter" class="orders-filter-select">
            <option value="all">All</option>
            <option value="open">Open</option>
            <option value="filled">Filled</option>
            <option value="canceled">Canceled</option>
            <option value="resting">Resting</option>
          </select>
        </div>
      </div>

      <div style="max-height: 380px; overflow: auto;">
        <table class="table-sortable">
          <thead>
          <tr>
            <th class="sortable" data-sort="orderId">Order ID</th>
            <th class="sortable" data-sort="time">Date / Time</th>
            <th class="sortable" data-sort="side">Side</th>
            <th class="sortable" data-sort="asset">Asset</th>
            <th class="sortable" data-sort="size">Size</th>
            <th class="sortable" data-sort="price">Price</th>
            <th class="sortable" data-sort="status">Status</th>
          </tr>
          </thead>
          <tbody id="historicalOrdersBody">
          <tr><td colspan="7" class="muted">Loading historical ordersâ€¦</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <div id="fillsHistoryPanel" class="tab-panel hidden">
      <div class="section-title">
        <span>Historical (last 2000)</span>
        <small id="historicalFillsCount">â€“</small>
      </div>
      <div style="max-height: 360px; overflow: auto;">
        <table class="table-sortable">
          <thead>
          <tr>
            <th class="desktop-only sortable" data-sort="orderId">Order ID</th>
            <th class="sortable" data-sort="time">Date / Time</th>
            <th class="sortable" data-sort="side">Side</th>
            <th class="sortable" data-sort="asset">Asset</th>
            <th class="sortable" data-sort="size">Size</th>
            <th class="sortable" data-sort="price">Price</th>
            <th class="sortable" data-sort="pnl">Closed PnL</th>
          </tr>
          </thead>
          <tbody id="historicalFillsBody">
          <tr><td colspan="6" class="muted">Loading historical fillsâ€¦</td></tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>

  <footer>
    <div style="margin-top:.1rem;">
    </div>
  </footer>
</div>

<div class="price-footer" aria-label="Live prices">
  <div class="price-footer-inner" id="priceFooter">
    <img class="price-logo" src="images/logo.png" alt="Hypermonitor" />
    <!-- <span class="price-hint">Live prices</span> -->
    <div class="price-ticker" id="priceTicker">
      <div class="price-track" id="priceTrack">
        <div class="price-list" id="priceList"></div>
        <div class="price-list clone" id="priceListClone" aria-hidden="true"></div>
      </div>
    </div>
    <div class="price-controls">
      <input id="priceAddInput" class="price-input" type="text" placeholder="Add coin" autocomplete="off" />
      <button id="priceAddBtn" class="price-add-btn" type="button">Add</button>
    </div>
  </div>
</div>
<div class="price-context-menu" id="priceContextMenu" role="menu" aria-hidden="true">
  <button class="price-context-item" type="button" data-action="pin" data-requires-coin="true">Pin left</button>
  <button class="price-context-item" type="button" data-action="reset">Reset list</button>
  <button class="price-context-item" type="button" data-action="remove" data-requires-coin="true">Remove from bar</button>
  <div class="price-context-sep" role="separator" aria-hidden="true"></div>
  <div class="price-context-group">
    <button class="price-context-item" type="button" data-action="toggle-change" data-has-submenu="true">Show % change</button>
    <div class="price-context-submenu" aria-label="Percent change range">
      <button class="price-context-item" type="button" data-action="change-range" data-range="5m">5 min</button>
      <button class="price-context-item" type="button" data-action="change-range" data-range="1h">1 hr</button>
      <button class="price-context-item" type="button" data-action="change-range" data-range="1d">1 day</button>
      <button class="price-context-item" type="button" data-action="change-range" data-range="1w">1 week</button>
    </div>
  </div>
</div>

<div class="favorites-panel" id="favoritesPanel" aria-hidden="true">
  <div class="favorites-card">
    <div class="favorites-header">
      <span>Favorite wallets</span>
      <div class="modal-close-btn favorites-close" id="favoritesCloseBtn" role="button" tabindex="0" aria-label="Close favorites">&times;</div>
    </div>
    <div class="favorites-add">
      <input class="favorites-input" id="favoritesInput" type="text" placeholder="0x..." autocomplete="off" />
      <button class="favorites-add-btn" id="favoritesAddBtn" type="button">+</button>
    </div>
    <div class="favorites-list" id="favoritesList"></div>
  </div>
</div>

<div class="share-modal" id="pnlShareModal" aria-hidden="true">
  <div class="share-card">
    <div class="share-header">
      <strong id="shareModalTitle">Share Asset Performance</strong>
      <button class="share-btn" id="shareModalClose" type="button">Close</button>
    </div>
    <div class="share-preview">
      <img id="sharePreviewImg" alt="PnL share preview" />
    </div>
    <div class="share-actions">
      <button class="share-btn" id="shareSaveBtn" type="button">Save image</button>
      <button class="share-btn" id="shareNativeBtn" type="button">Share</button>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script type="module">
  import * as hl from "https://esm.sh/jsr/@nktkas/hyperliquid";

  const DEFAULT_WALLET = "0x0b1ace05eb9ef1c3a1951b763700ecad24f27741";

  const MAX_FILL_ROWS = 100;
  const PORTFOLIO_API_URL = "https://api.hyperliquid.xyz/info";

  const walletInputsEl = document.getElementById("walletInputs");
  const addWalletBtnEl = document.getElementById("addWalletBtn");
  const trackBtnEl = document.getElementById("trackBtn");
  const marketToggleButtons = document.querySelectorAll(".market-tab-btn");
  const marketToggleIndicatorEl = document.querySelector(".market-toggle-indicator");
  const rangeToggleIndicatorEl = document.querySelector(".range-toggle-indicator");
  const accountModeLabelEl = document.getElementById("accountModeLabel");
  const positionsModeLabelEl = document.getElementById("positionsModeLabel");
  const performanceModeLabelEl = document.getElementById("performanceModeLabel");

  const statusDotEl = document.getElementById("statusDot");
  const statusTextEl = document.getElementById("statusText");
  const statusSpinnerEl = document.getElementById("statusSpinner");
  const statusLogoEl = document.querySelector(".status-logo");
  const startedAtEl = document.getElementById("startedAt");

  const marginSummaryEl = document.getElementById("marginSummary");
  const snapshotErrorEl = document.getElementById("snapshotError");

  const positionsBodyEl = document.getElementById("positionsBody");
  const positionsChartBtn = document.getElementById("positionsChartBtn");
  const portfolioModalEl = document.getElementById("portfolioModal");
  const portfolioModalCloseEl = document.getElementById("portfolioModalClose");
  const portfolioDoughnutCanvas = /** @type {HTMLCanvasElement} */ (document.getElementById("portfolioDoughnut"));
  const positionsValueStatEl = document.getElementById("positionsValueStat");
  const withdrawableValueStatEl = document.getElementById("withdrawableValueStat");
  const priceFooterEl = document.getElementById("priceFooter");
  const priceFooterWrapEl = document.querySelector(".price-footer");
  const priceTickerEl = document.getElementById("priceTicker");
  const priceTrackEl = document.getElementById("priceTrack");
  const priceListEl = document.getElementById("priceList");
  const priceListCloneEl = document.getElementById("priceListClone");
  const priceAddInputEl = document.getElementById("priceAddInput");
  const priceAddBtnEl = document.getElementById("priceAddBtn");
  const priceContextMenuEl = document.getElementById("priceContextMenu");
  const favoritesBtnEl = document.getElementById("favoritesBtn");
  const favoritesPanelBtnEl = document.getElementById("favoritesPanelBtn");
  const favoritesPanelEl = document.getElementById("favoritesPanel");
  const favoritesCloseBtnEl = document.getElementById("favoritesCloseBtn");
  const favoritesInputEl = document.getElementById("favoritesInput");
  const favoritesAddBtnEl = document.getElementById("favoritesAddBtn");
  const favoritesListEl = document.getElementById("favoritesList");
  const positionsHeaderEls = Array.from(document.querySelectorAll(".positions-card thead th[data-sort]"));
  const historicalOrdersHeaderEls = Array.from(document.querySelectorAll("#ordersHistoryPanel thead th[data-sort]"));
  const historicalFillsHeaderEls = Array.from(document.querySelectorAll("#fillsHistoryPanel thead th[data-sort]"));

  const openOrdersBodyEl = document.getElementById("openOrdersBody");
  const openOrdersCountEl = document.getElementById("openOrdersCount");
  const canceledOrdersBodyEl = document.getElementById("canceledOrdersBody");
  const canceledCountEl = document.getElementById("canceledCount");
  const ordersErrorEl = document.getElementById("ordersError");

  const historicalOrdersBodyEl = document.getElementById("historicalOrdersBody");
  const historicalOrdersCountEl = document.getElementById("historicalOrdersCount");

  const ordersLivePanelEl = document.getElementById("ordersLivePanel");
  const ordersHistoryPanelEl = document.getElementById("ordersHistoryPanel");
  const historyLayoutEl = document.getElementById("historyLayout");
  const liveLayoutEl = document.getElementById("liveLayout");
  const historyTabsEl = document.getElementById("historyTabs");
  const modeTabsEl = document.getElementById("modeTabs");
  const modeTabsHistoryEl = document.getElementById("modeTabsHistory");
  const modeTabButtons = document.querySelectorAll(".mode-tab-btn");
  const historyTabButtons = document.querySelectorAll(".history-tab-btn");

  const historicalSideFilterEl = document.getElementById("historicalSideFilter");
  const historicalStatusFilterEl = document.getElementById("historicalStatusFilter");
  const historicalAssetFilterEl = document.getElementById("historicalAssetFilter");

  const fillsBodyEl = document.getElementById("fillsBody");
  const fillsErrorEl = document.getElementById("fillsError");
  const fillsCountEl = document.getElementById("fillsCount");
  const historicalFillsBodyEl = document.getElementById("historicalFillsBody");
  const historicalFillsCountEl = document.getElementById("historicalFillsCount");
  const fillsLivePanelEl = document.getElementById("fillsLivePanel");
  const fillsHistoryPanelEl = document.getElementById("fillsHistoryPanel");

  const portfolioErrorEl = document.getElementById("portfolioError");
  const portfolioLoadingEl = document.getElementById("portfolioLoading");
  const portfolioLoadingWrapEl = document.getElementById("portfolioLoadingWrap");
  const portfolioChartsEl = document.getElementById("portfolioCharts");
  const performanceToolbarEl = document.getElementById("performanceToolbar");
  const performanceActionsEl = document.getElementById("performanceActions");
  const spotPerformanceNoteEl = document.getElementById("spotPerformanceNote");
  const rangeButtons = document.querySelectorAll(".chart-range-btn");
  const exportExcelBtn = document.getElementById("exportExcelBtn");
  const metricsCardEl = document.getElementById("metricsCard");
  const metricsGridEl = metricsCardEl ? metricsCardEl.querySelector(".metrics-grid") : null;
  const metricsToggleEl = document.getElementById("metricsToggle");
  const performanceShareBtnEl = document.getElementById("performanceShareBtn");
  const metricsWalletLabelEl = document.getElementById("metricsWalletLabel");
  const metricsRangeLabelEl = document.getElementById("metricsRangeLabel");
  const metricTotalPnlEl = document.getElementById("metricTotalPnl");
  const metricTotalPnlSubEl = document.getElementById("metricTotalPnlSub");
  const metricReturnEl = document.getElementById("metricReturn");
  const metricMaxDrawdownEl = document.getElementById("metricMaxDrawdown");
  const metricSharpeEl = document.getElementById("metricSharpe");
  const metricVolatilityEl = document.getElementById("metricVolatility");
  const metricBestIntervalEl = document.getElementById("metricBestInterval");
  const metricRealizedPnlEl = document.getElementById("metricRealizedPnl");
  const metricWinRateEl = document.getElementById("metricWinRate");
  const metricProfitFactorEl = document.getElementById("metricProfitFactor");
  const metricOrdersTradesPerDayEl = document.getElementById("metricOrdersTradesPerDay");
  const metricActiveDaysEl = document.getElementById("metricActiveDays");
  const metricActiveDaysCountEl = document.getElementById("metricActiveDaysCount");
  const metricProductCountEl = document.getElementById("metricProductCount");
  const metricHerfindahlEl = document.getElementById("metricHerfindahl");
  const metricAvgNotionalEl = document.getElementById("metricAvgNotional");
  const metricMedianHoldingEl = document.getElementById("metricMedianHolding");
  const metricSideBiasEl = document.getElementById("metricSideBias");
  const metricAggressivenessEl = document.getElementById("metricAggressiveness");
  const metricCancelRatioEl = document.getElementById("metricCancelRatio");
  const metricReactionSpeedEl = document.getElementById("metricReactionSpeed");
  const metricSlippageEl = document.getElementById("metricSlippage");
  const metricPnlStabilityEl = document.getElementById("metricPnlStability");
  const metricSkillPersistenceEl = document.getElementById("metricSkillPersistence");
  const metricExcessPnlEl = document.getElementById("metricExcessPnl");
  const metricBetaAlphaEl = document.getElementById("metricBetaAlpha");

  const pnlShareModalEl = document.getElementById("pnlShareModal");
  const shareModalTitleEl = document.getElementById("shareModalTitle");
  const sharePreviewImgEl = document.getElementById("sharePreviewImg");
  const shareSaveBtnEl = document.getElementById("shareSaveBtn");
  const shareNativeBtnEl = document.getElementById("shareNativeBtn");
  const shareModalCloseEl = document.getElementById("shareModalClose");

  const equityCanvas = /** @type {HTMLCanvasElement} */ (document.getElementById("equityChart"));
  const pnlCanvas = /** @type {HTMLCanvasElement} */ (document.getElementById("pnlChart"));
  const depositsCanvas = /** @type {HTMLCanvasElement} */ (document.getElementById("depositsChart"));
  const equityTitleValueEl = document.getElementById("equityTitleValue");
  const pnlTitleValueEl = document.getElementById("pnlTitleValue");
  const depositsTitleValueEl = document.getElementById("depositsTitleValue");

  const themeToggleBtn = document.getElementById("themeToggle");

  const COIN_ICON_BASE = "https://app.hyperliquid.xyz/coins/";
  const SPECIAL_LOGOS = new Map([
    ["USA500", "https://s3-symbol-logo.tradingview.com/indices/s-and-p-500--600.png"],
    ["COPPER", "https://s3-symbol-logo.tradingview.com/metal/copper--600.png"],
  ]);
  const logoCache = new Map();
  const expandedPositions = new Set();
  let currentPositionsSort = { key: "asset", dir: "asc" };
  let currentHistoricalOrdersSort = { key: "time", dir: "desc" };
  let currentHistoricalFillsSort = { key: "time", dir: "desc" };
  const coinIdMap = new Map();
  const spotIdMetaMap = new Map();
  let perpDexNames = null;
  let spotMetaPromise = null;
  let logoRetryTimer = null;
  let logoRefreshTimer = null;
  const FOOTER_COINS_KEY = "hypermonitor-footer-coins";
  const FAVORITES_KEY = "hypermonitor-favorite-wallets";
  const COIN_NAME_CACHE_KEY = "hypermonitor-coin-name-cache";
  const COIN_COLOR_CACHE_KEY = "hypermonitor-coin-color-cache";
  const DEFAULT_FOOTER_COINS = ["BTC", "ETH", "SOL", "HYPE", "cash:USA500", "xyz:GOLD", "xyz:SILVER", "xyz:MSTR", "xyz:NVDA"];
  let trackedFooterCoins = [...DEFAULT_FOOTER_COINS];
  const coinNameCache = new Map();
  const coinColorCache = new Map();
  const coinColorPending = new Set();
  const coinPriceDecimals = new Map();
  const lastFooterPrices = new Map();
  let latestLiveEquityValue = null;
  let latestLivePnlValue = null;
  let latestBaseEquityValue = null;
  const chartLastValues = { equity: null, pnl: null, deposits: null };
  const NON_CRYPTO_PREFIXES = ["xyz", "flx", "hyna", "km", "vntl", "cash"];
  const manualMidCoins = new Set();
  let manualMidTimer = null;
  const HYPERLIQUID_TICKERS = new Set(
    [
      "0G", "2Z", "AAVE", "ACE", "ADA", "AERO", "AI", "AI16Z", "AIXBT", "ALGO", "ALT", "ANIME", "APE", "APEX",
      "APT", "AR", "ARB", "ARK", "ASTER", "ATOM", "AVAX", "AVNT", "AXS", "BABY", "BADGER", "BANANA", "BCH",
      "BERA", "BIGTIME", "BIO", "BLAST", "BLUR", "BLZ", "BNB", "BNT", "BOME", "BRETT", "BSV", "BTC", "CAKE",
      "CANTO", "CATI", "CC", "CELO", "CFX", "CHILLGUY", "COMP", "CRV", "CYBER", "DASH", "DOGE", "DOOD", "DOT",
      "DYDX", "DYM", "EIGEN", "ENA", "ENS", "ETC", "ETH", "ETHFI", "FARTCOIN", "FET", "FIL", "FOGO", "FRIEND",
      "FTM", "FTT", "FXS", "GALA", "GAS", "GMT", "GMX", "GOAT", "GRASS", "GRIFFAIN", "HBAR", "HEMI", "HMSTR",
      "HPOS", "HYPE", "HYPER", "ICP", "ILV", "IMX", "INIT", "INJ", "IO", "IOTA", "IP", "JELLY", "JTO", "JUP",
      "KAITO", "KAS", "LAUNCHCOIN", "LAYER", "LDO", "LINEA", "LINK", "LISTA", "LIT", "LOOM", "LTC", "MANTA",
      "MATIC", "MAV", "MAVIA", "ME", "MEGA", "MELANIA", "MEME", "MERL", "MET", "MEW", "MINA", "MKR", "MNT",
      "MON", "MOODENG", "MORPHO", "MOVE", "MYRO", "NEAR", "NEIROETH", "NEO", "NFTI", "NIL", "NOT", "NTRN",
      "NXPC", "OGN", "OM", "OMNI", "ONDO", "OP", "ORBS", "ORDI", "OX", "PANDORA", "PAXG", "PENDLE", "PENGU",
      "PEOPLE", "PIXEL", "PNUT", "POL", "POLYX", "POPCAT", "PROMPT", "PROVE", "PUMP", "PURR", "PYTH", "RDNT",
      "RENDER", "REQ", "RESOLV", "REZ", "RLB", "RNDR", "RSR", "RUNE", "S", "SAGA", "SAND", "SCR", "SEI", "SHIA",
      "SKY", "SNX", "SOL", "SOPH", "SPX", "STABLE", "STBL", "STG", "STRAX", "STRK", "STX", "SUI", "SUPER",
      "SUSHI", "SYRUP", "TAO", "TIA", "TNSR", "TON", "TRB", "TRUMP", "TRX", "TST", "TURBO", "UMA", "UNI",
      "UNIBOT", "USTC", "USUAL", "VINE", "VIRTUAL", "VVV", "W", "WCT", "WIF", "WLD", "WLFI", "XAI", "XLM",
      "XMR", "XPL", "XRP", "YGG", "YZY", "ZEC", "ZEN", "ZEREBRO", "ZETA", "ZK", "ZORA", "ZRO", "KBONK",
      "KDOGS", "KFLOKI", "KLUNC", "KNEIRO", "KPEPE", "KSHIB"
    ].map((t) => t.toUpperCase())
  );


  function loadFooterCoins() {
    try {
      const raw = localStorage.getItem(FOOTER_COINS_KEY);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed) && parsed.length) {
        trackedFooterCoins = parsed.map((c) => normalizeFooterCoinValue(c)).filter(Boolean);
      }
    } catch (e) {}
  }

  function loadFavoriteWallets() {
    try {
      const raw = localStorage.getItem(FAVORITES_KEY);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed)) {
        favoriteWallets = parsed.map(normalizeWalletInput).filter(isValidAddress);
      }
    } catch (e) {}
  }

  function saveFavoriteWallets() {
    try {
      localStorage.setItem(FAVORITES_KEY, JSON.stringify(favoriteWallets));
    } catch (e) {}
  }

  function isFavoriteWallet(wallet) {
    const norm = String(wallet || "").toLowerCase();
    return favoriteWallets.some((w) => String(w).toLowerCase() === norm);
  }

  function updateFavoriteToggle() {
    syncWalletInputStars();
  }

  function syncWalletInputStars() {
    if (!walletInputsEl) return;
    const rows = Array.from(walletInputsEl.querySelectorAll(".wallet-input-row"));
    rows.forEach((row) => {
      const input = row.querySelector(".wallet-input");
      const star = row.querySelector(".wallet-fav-btn");
      if (!star) return;
      const value = input?.value || "";
      const active = isValidAddress(value) && isFavoriteWallet(value);
      star.classList.toggle("active", active);
      star.textContent = active ? "â˜…" : "â˜†";
    });
  }

  function addFavoriteWallet(wallet) {
    const norm = normalizeWalletInput(wallet);
    if (!isValidAddress(norm)) return false;
    if (isFavoriteWallet(norm)) return true;
    favoriteWallets.push(norm);
    saveFavoriteWallets();
    updateFavoriteToggle();
    return true;
  }

  function removeFavoriteWallet(wallet) {
    const norm = String(wallet || "").toLowerCase();
    favoriteWallets = favoriteWallets.filter((w) => String(w).toLowerCase() !== norm);
    favoriteMetricsCache.delete(normalizeWalletInput(wallet));
    saveFavoriteWallets();
    updateFavoriteToggle();
  }

  async function getFavoriteMetrics(wallet) {
    const norm = normalizeWalletInput(wallet);
    if (!isValidAddress(norm)) return null;
    if (favoriteMetricsCache.has(norm)) return favoriteMetricsCache.get(norm);
    const entry = { loading: true, day: null, all: null, spark: null, error: null };
    favoriteMetricsCache.set(norm, entry);
    try {
      const data = await fetchPortfolio(norm);
      const daySection = getPortfolioSection(data, "day", "all");
      const allSection = getPortfolioSection(data, "allTime", "all");
      const dayView = buildViewFromSection(daySection);
      const allView = buildViewFromSection(allSection);
      const dayMetrics = dayView ? computePerformanceMetrics(dayView) : null;
      const allMetrics = allView ? computePerformanceMetrics(allView) : null;
      entry.day = dayMetrics?.returnPct ?? null;
      entry.all = allMetrics?.returnPct ?? null;
      const weekSection = getPortfolioSection(data, "week", "all");
      if (weekSection?.pnlHistory?.length) {
        const hist = weekSection.pnlHistory
          .map(([, v]) => Number(v ?? 0))
          .filter(Number.isFinite);
        const last = hist.slice(-8);
        entry.spark = last.length >= 2 ? last : null;
      }
      entry.loading = false;
    } catch (err) {
      entry.loading = false;
      entry.error = err?.message || "Failed";
    }
    return entry;
  }

  function buildSparklineSvg(values, color) {
    if (!Array.isArray(values) || values.length < 2) return "";
    const min = Math.min(...values);
    const max = Math.max(...values);
    const range = max - min || 1;
    const w = 90;
    const h = 22;
    const step = w / (values.length - 1);
    const points = values.map((v, i) => {
      const x = i * step;
      const y = h - ((v - min) / range) * (h - 2) - 1;
      return `${x.toFixed(1)},${y.toFixed(1)}`;
    });
    return `
      <svg viewBox="0 0 ${w} ${h}" preserveAspectRatio="none">
        <polyline
          fill="none"
          stroke="${color}"
          stroke-width="1.6"
          points="${points.join(" ")}"
        />
      </svg>
    `;
  }

  function renderFavoritesList() {
    if (!favoritesListEl) return;
    if (!favoriteWallets.length) {
      favoritesListEl.innerHTML = "<div class='muted'>No favorites yet.</div>";
      return;
    }
    favoritesListEl.innerHTML = favoriteWallets
      .map((wallet) => {
        const label = formatWalletLabel(wallet);
        const short = `${wallet.slice(0, 4)}â€¦${wallet.slice(-3)}`;
        const showShort = !String(label || "").toLowerCase().includes("0x");
        const full = wallet;
        const tracked = primaryWallet && String(primaryWallet).toLowerCase() === String(wallet).toLowerCase();
        const chip = tracked ? `<span class="favorites-chip">Tracked</span>` : "";
        return `
          <div class="favorites-item" data-wallet="${wallet}">
            <button class="favorites-wallet-btn" type="button" data-action="open" data-wallet="${wallet}">
              <span>${label}</span>
              ${showShort ? `<span class="favorites-wallet-sub">${short}</span>` : ""}
              ${showShort ? `<span class="favorites-wallet-full">${full}</span>` : ""}
              ${chip}
              <span class="favorites-copy" data-action="copy" data-wallet="${wallet}" title="Copy address">â§‰</span>
              <span class="favorites-copy-toast" aria-live="polite">Copied!</span>
            </button>
            <button class="favorites-remove-btn" type="button" data-action="remove" data-wallet="${wallet}">-</button>
            <div class="favorites-metrics" data-wallet="${wallet}">
              <div class="favorites-metric">1 day: <strong>â€¦</strong></div>
              <div class="favorites-metric">All time: <strong>â€¦</strong></div>
              <div class="favorites-spark"></div>
            </div>
          </div>
        `;
      })
      .join("");
    favoriteWallets.forEach(async (wallet) => {
      const metricsEl = favoritesListEl.querySelector(`.favorites-metrics[data-wallet="${wallet}"]`);
      const itemEl = favoritesListEl.querySelector(`.favorites-item[data-wallet="${wallet}"]`);
      if (!metricsEl) return;
      const data = await getFavoriteMetrics(wallet);
      if (!data || data.loading) return;
      const dayText = Number.isFinite(data.day) ? formatSignedPercent(data.day) : "N/A";
      const allText = Number.isFinite(data.all) ? formatSignedPercent(data.all) : "N/A";
      const dayClass = Number.isFinite(data.day) ? (data.day >= 0 ? "upnl-pos" : "upnl-neg") : "";
      const allClass = Number.isFinite(data.all) ? (data.all >= 0 ? "upnl-pos" : "upnl-neg") : "";
      const accent =
        Number.isFinite(data.day)
          ? data.day >= 0
            ? "rgba(74, 222, 128, 0.75)"
            : "rgba(251, 113, 133, 0.75)"
          : "rgba(148, 163, 184, 0.45)";
      if (itemEl) itemEl.style.setProperty("--fav-accent", accent);
      const sparkColor = Number.isFinite(data.day)
        ? data.day >= 0
          ? "rgba(74, 222, 128, 0.85)"
          : "rgba(251, 113, 133, 0.85)"
        : "rgba(148, 163, 184, 0.6)";
      metricsEl.innerHTML = `
        <div class="favorites-metric">1 day: <strong class="${dayClass}">${dayText}</strong></div>
        <div class="favorites-metric">All time: <strong class="${allClass}">${allText}</strong></div>
        <div class="favorites-spark">${data.spark ? buildSparklineSvg(data.spark, sparkColor) : ""}</div>
      `;
    });
  }

  function toggleFavoritesPanel(forceOpen = null) {
    if (!favoritesPanelEl) return;
    const shouldOpen = forceOpen !== null ? forceOpen : !favoritesPanelEl.classList.contains("show");
    favoritesPanelEl.classList.toggle("show", shouldOpen);
    favoritesPanelEl.setAttribute("aria-hidden", shouldOpen ? "false" : "true");
    if (shouldOpen) {
      renderFavoritesList();
      if (favoritesInputEl) favoritesInputEl.focus();
    }
  }

  function loadFooterChangePrefs() {
    try {
      const raw = localStorage.getItem(FOOTER_CHANGE_STORAGE_KEY);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      if (typeof parsed?.enabled === "boolean") footerChangeEnabled = parsed.enabled;
      if (typeof parsed?.range === "string" && FOOTER_CHANGE_RANGES[parsed.range]) {
        footerChangeRange = parsed.range;
      }
    } catch (e) {}
  }

  function saveFooterChangePrefs() {
    try {
      localStorage.setItem(
        FOOTER_CHANGE_STORAGE_KEY,
        JSON.stringify({ enabled: footerChangeEnabled, range: footerChangeRange })
      );
    } catch (e) {}
  }

  function saveFooterCoins() {
    try {
      localStorage.setItem(FOOTER_COINS_KEY, JSON.stringify(trackedFooterCoins));
    } catch (e) {}
  }

  function resetFooterCoins() {
    trackedFooterCoins = [...DEFAULT_FOOTER_COINS];
    saveFooterCoins();
    renderFooterPrices();
  }

  function loadCoinNameCache() {
    try {
      const raw = localStorage.getItem(COIN_NAME_CACHE_KEY);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object") return;
      Object.entries(parsed).forEach(([name, symbol]) => {
        if (!name || !symbol) return;
        coinNameCache.set(String(name), String(symbol));
      });
    } catch (e) {}
  }

  function saveCoinNameCache() {
    try {
      const obj = {};
      coinNameCache.forEach((value, key) => {
        obj[key] = value;
      });
      localStorage.setItem(COIN_NAME_CACHE_KEY, JSON.stringify(obj));
    } catch (e) {}
  }

  function loadCoinColorCache() {
    try {
      const raw = localStorage.getItem(COIN_COLOR_CACHE_KEY);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object") return;
      Object.entries(parsed).forEach(([symbol, color]) => {
        if (!symbol || !color) return;
        coinColorCache.set(normalizeFooterCoinValue(symbol), String(color));
      });
    } catch (e) {}
  }

  function saveCoinColorCache() {
    try {
      const obj = {};
      coinColorCache.forEach((value, key) => {
        obj[key] = value;
      });
      localStorage.setItem(COIN_COLOR_CACHE_KEY, JSON.stringify(obj));
    } catch (e) {}
  }

  function formatWalletLabel(wallet) {
    const w = String(wallet || "");
    if (w.length <= 12) return w;
    return `${w.slice(0, 6)}â€¦${w.slice(-4)}`;
  }

  window.__logoOk = (rawKey, imgEl) => {
    const entry = logoCache.get(rawKey);
    if (!entry) return;
    const nextUrl = imgEl?.currentSrc || imgEl?.src || entry.urls?.[entry.idx];
    const wasOk = entry.state === "ok" && entry.okUrl === nextUrl;
    entry.state = "ok";
    entry.okUrl = nextUrl;
    if (!wasOk) scheduleLogoRefresh();
  };

  window.__logoErr = (rawKey, imgEl, fallbackLetter) => {
    const entry = logoCache.get(rawKey);
    if (!entry) return;

    if (window.location?.protocol === "file:") {
      entry.state = "bad";
      entry.permaFail = true;
      entry.retryCount = 999;
      try {
        if (imgEl && imgEl.outerHTML) {
          imgEl.outerHTML = `<span class="coinFallback">${fallbackLetter || "?"}</span>`;
        }
      } catch {}
      return;
    }

    const nextIdx = (entry.idx ?? 0) + 1;
    if (entry.urls && nextIdx < entry.urls.length) {
      entry.idx = nextIdx;
      const nextUrl = entry.urls[nextIdx];
      try {
        if (imgEl && imgEl.src !== nextUrl) imgEl.src = nextUrl;
      } catch {}
      return;
    }

    entry.state = "bad";
    entry.retryCount = (entry.retryCount || 0) + 1;
    scheduleLogoRetry();
    try {
      if (imgEl && imgEl.outerHTML) {
        imgEl.outerHTML = `<span class="coinFallback">${fallbackLetter || "?"}</span>`;
      }
    } catch {}
  };

  // === URL + LAST WALLET(S) (localStorage) helpers ===
  const LAST_WALLET_KEY = "hypermonitor-last-wallet";
  const LAST_WALLETS_KEY = "hypermonitor-last-wallets";

  function normalizeWalletInput(value) {
    return (value || "").trim();
  }

  function uniqueWallets(wallets) {
    const deduped = [];
    const seen = new Set();
    wallets.forEach((w) => {
      const norm = w.toLowerCase();
      if (!norm || seen.has(norm)) return;
      seen.add(norm);
      deduped.push(w);
    });
    return deduped;
  }

  function saveLastWallets(wallets) {
    try {
      localStorage.setItem(LAST_WALLETS_KEY, JSON.stringify(wallets));
      if (wallets[0]) localStorage.setItem(LAST_WALLET_KEY, wallets[0]);
    } catch (e) {}
  }

  function getLastWallets() {
    try {
      const raw = localStorage.getItem(LAST_WALLETS_KEY);
      if (raw) {
        const parsed = JSON.parse(raw);
        if (Array.isArray(parsed)) return parsed.map(normalizeWalletInput).filter(Boolean);
      }
    } catch (e) {}
    try {
      const single = (localStorage.getItem(LAST_WALLET_KEY) || "").trim();
      return single ? [single] : [];
    } catch (e) {
      return [];
    }
  }

  function setWalletsInUrl(wallets, { replace = false } = {}) {
    try {
      const url = new URL(window.location.href);
      if (wallets.length <= 1) {
        url.searchParams.set("wallet", wallets[0] || "");
        url.searchParams.delete("wallets");
      } else {
        url.searchParams.set("wallets", wallets.join(","));
        url.searchParams.set("wallet", wallets[0] || "");
      }
      if (replace) history.replaceState({ wallets }, "", url.toString());
      else history.pushState({ wallets }, "", url.toString());
    } catch (e) {}
  }

  function getWalletsFromUrl() {
    try {
      const url = new URL(window.location.href);
      const multi = (url.searchParams.get("wallets") || "").trim();
      if (multi) {
        return multi
          .split(",")
          .map((w) => w.trim())
          .filter(Boolean);
      }
      const single = (url.searchParams.get("wallet") || "").trim();
      return single ? [single] : [];
    } catch (e) {
      return [];
    }
  }

  function getWalletInputEls() {
    return Array.from(walletInputsEl?.querySelectorAll(".wallet-input") || []);
  }

  function getWalletConfigFromInputs() {
    const rows = Array.from(walletInputsEl?.querySelectorAll(".wallet-input-row") || []);
    const values = [];

    rows.forEach((row) => {
      const walletEl = row.querySelector(".wallet-input");
      const wallet = normalizeWalletInput(walletEl?.value || "");
      if (!wallet) return;
      values.push(wallet);
    });

    const invalid = values.filter((w) => !isValidAddress(w));
    if (invalid.length) {
      snapshotErrorEl.textContent = "Please enter valid 0x wallet addresses (40 hex chars).";
      return null;
    }
    const deduped = uniqueWallets(values);
    if (!deduped.length) {
      snapshotErrorEl.textContent = "Please enter at least one valid wallet address.";
      return null;
    }
    snapshotErrorEl.textContent = "";
    return { wallets: deduped };
  }

  function addWalletInputRow(value = "") {
    if (!walletInputsEl) return;
    const idx = walletInputsEl.querySelectorAll(".wallet-input-row").length;
    const row = document.createElement("div");
    row.className = "wallet-input-row";
    row.dataset.index = String(idx);

    const inputId = `walletInput${idx}`;
    row.innerHTML = `
      <input id="${inputId}" class="wallet-input" type="text" placeholder="0x..." autocomplete="off" aria-label="Wallet address" />
      <div class="wallet-input-actions">
        <button class="wallet-fav-btn" type="button" aria-label="Favorite wallet">â˜†</button>
        <button class="wallet-icon-btn wallet-remove-btn" type="button" aria-label="Remove wallet">-</button>
      </div>
    `;
    walletInputsEl.appendChild(row);
    const inputEl = row.querySelector("input");
    if (inputEl) inputEl.value = value;
    syncWalletInputStars();
  }

  function setWalletInputs(wallets) {
    if (!walletInputsEl) return;
    const rows = Array.from(walletInputsEl.querySelectorAll(".wallet-input-row"));
    rows.slice(1).forEach((row) => row.remove());

    const primaryInput = walletInputsEl.querySelector(".wallet-input");
    if (primaryInput) primaryInput.value = wallets[0] || "";

    (wallets || []).slice(1).forEach((wallet) => addWalletInputRow(wallet));
    syncWalletInputStars();
  }

  async function getPerpDexNames() {
    if (perpDexNames) return perpDexNames;
    try {
      const res = await fetch(PORTFOLIO_API_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ type: "perpDexs" }),
      });
      if (!res.ok) throw new Error(`perpDexs error: ${res.status} ${res.statusText}`);
      const data = await res.json();
      const names = (Array.isArray(data) ? data : [])
        .map((x) => x?.name)
        .filter((x) => typeof x === "string" && x.length > 0);
      perpDexNames = ["", ...names.filter((n) => n !== "")];
    } catch (err) {
      console.warn("Failed to load perp dex names", err);
      perpDexNames = [""];
    }
    return perpDexNames;
  }

  async function fetchAdditionalDexPositions(wallet) {
    try {
      const dexNames = await getPerpDexNames();
      const extraDexes = (dexNames || []).filter((d) => d);
      if (extraDexes.length === 0) return [];

      const fetches = extraDexes.map(async (dex) => {
        try {
          const res = await fetch(PORTFOLIO_API_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ type: "clearinghouseState", user: wallet, dex }),
          });
          if (!res.ok) throw new Error(`dex ${dex} status ${res.status}`);
          const data = await res.json();
          return Array.isArray(data?.assetPositions) ? data.assetPositions : [];
        } catch (err) {
          console.warn("Additional dex positions error", err);
          return [];
        }
      });

      const results = await Promise.all(fetches);
      return results.flat();
    } catch (err) {
      console.warn("Failed to fetch additional dex positions", err);
      return [];
    }
  }

  function getStablecoinPriceFallback(coin) {
    const base = String(coin || "").toUpperCase();
    const stable = ["USDC", "USDT", "USDE", "USDT0", "USDS"];
    return stable.includes(base) ? 1 : null;
  }

  function normalizeSpotBalances(rawBalances, wallet) {
    if (!Array.isArray(rawBalances)) return [];
    const positions = [];
    rawBalances.forEach((bal) => {
      if (!bal || typeof bal !== "object") return;
      const rawCoin = bal.coin ?? bal.asset ?? bal.symbol ?? bal.token ?? bal.name ?? "";
      const coin = String(rawCoin || "").trim();
      if (!coin) return;

      let total = Number(bal.total ?? bal.balance ?? bal.size ?? bal.qty ?? bal.amount ?? bal.available ?? bal.hold);
      if (!Number.isFinite(total)) {
        const avail = Number(bal.available ?? 0);
        const hold = Number(bal.hold ?? 0);
        if (Number.isFinite(avail) || Number.isFinite(hold)) total = (Number.isFinite(avail) ? avail : 0) + (Number.isFinite(hold) ? hold : 0);
      }
      if (!Number.isFinite(total) || Math.abs(total) < 1e-12) return;

      const entryPx = Number(bal.entryPx ?? bal.entryPrice ?? 0);
      const explicitValue = Number(bal.valueUsd ?? bal.usdValue ?? bal.notional ?? bal.value ?? bal.value_usd);
      let markPx = getLivePriceForCoin(coin);
      if (!Number.isFinite(markPx)) {
        const fallback = getStablecoinPriceFallback(coin);
        if (Number.isFinite(fallback)) markPx = fallback;
      }
      const positionValue = Number.isFinite(explicitValue)
        ? explicitValue
        : Number.isFinite(markPx)
          ? markPx * total
          : 0;

      positions.push({
        wallet,
        marketType: "spot",
        position: {
          coin,
          szi: total,
          entryPx: Number.isFinite(entryPx) ? entryPx : 0,
          positionValue,
          unrealizedPnl: 0,
        },
      });
    });
    return positions;
  }

  async function fetchSpotState(wallet) {
    const payloads = [
      { type: "spotUserState", user: wallet },
      { type: "spotClearinghouseState", user: wallet },
    ];

    for (const body of payloads) {
      try {
        const res = await fetch(PORTFOLIO_API_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
        });
        if (!res.ok) continue;
        const data = await res.json();
        const balances =
          data?.balances ??
          data?.spotBalances ??
          data?.assets ??
          data?.state?.balances ??
          data?.state?.assets;
        if (Array.isArray(balances)) return { balances, raw: data };
      } catch (err) {
        console.warn("Spot state fetch failed", err);
      }
    }
    return null;
  }

  function buildSpotSummary(positions) {
    const totals = {
      accountValue: 0,
      totalNtlPos: 0,
      totalRawUsd: 0,
      totalMarginUsed: 0,
      withdrawable: 0,
    };
    let stableCash = 0;
    positions.forEach((item) => {
      const coin = item?.position?.coin ?? "";
      const value = Number(item?.position?.positionValue ?? 0);
      if (!Number.isFinite(value)) return;
      totals.accountValue += value;
      totals.totalNtlPos += Math.abs(value);
      totals.totalRawUsd += value;
      const fallback = getStablecoinPriceFallback(coin);
      if (fallback === 1) stableCash += value;
    });
    totals.withdrawable = stableCash;
    return totals;
  }

  // === STATE ===
  let currentWallets = [DEFAULT_WALLET];
  let primaryWallet = DEFAULT_WALLET;
  const walletSnapshotsByType = { perp: new Map(), spot: new Map() };
  const walletTotalsByType = { perp: new Map(), spot: new Map() };
  const walletPositionsByType = { perp: new Map(), spot: new Map() };
  const openOrders = new Map();
  const canceledOrders = [];
  const fills = [];

  const historicalOrders = [];
  let historicalOrdersLoaded = false;
  const historicalFills = [];
  let historicalFillsLoaded = false;

  let infoClient = null;
  let subsClient = null;
  const orderUpdatesSubs = new Map();
  const userEventsSubs = new Map();

  let currentAssetPositions = [];
  let currentMarketType = "perp";
  const liveMids = new Map();
  let allMidsSub = null;
  const footerChangePcts = new Map();
  const footerChangeRefs = new Map();
  let footerChangeTimer = null;
  let footerChangeEnabled = true;
  let footerChangeRange = "1d";
  const FOOTER_CHANGE_STORAGE_KEY = "hypermonitor-footer-change";
  const FOOTER_CHANGE_RANGES = {
    "5m": { label: "5 min", interval: "5m", ms: 5 * 60 * 1000 },
    "1h": { label: "1 hr", interval: "1h", ms: 60 * 60 * 1000 },
    "1d": { label: "1 day", interval: "1d", ms: 24 * 60 * 60 * 1000 },
    "1w": { label: "1 week", interval: "1w", ms: 7 * 24 * 60 * 60 * 1000 },
  };
  let favoriteWallets = [];
  const favoriteMetricsCache = new Map();

  let lastComputedUpnlTotal = 0;
  let lastComputedTotalNotional = 0;

  const portfolioDataByWallet = new Map();
  let currentRangeKey = "allTime";
  const portfolioCharts = { equity: null, pnl: null, deposits: null };
  const portfolioBreakdownChart = { chart: null };
  const WALLET_COLOR_PALETTE = ["#38bdf8", "#f59e0b", "#f472b6", "#22d3ee", "#a78bfa", "#34d399", "#f97316", "#60a5fa"];
  const walletColorMap = new Map();

  function updateSpinnerForTheme(theme) {
    if (!statusSpinnerEl) return;
    statusSpinnerEl.src =
      theme === "light"
        ? "https://hyperfoundation.org/landing/blob-dark.gif"
        : "https://hyperfoundation.org/landing/blob_green.gif";
  }

  function setStatus(status, message) {
    statusDotEl.classList.remove("connected", "error");

    if (status === "connected") {
      statusDotEl.classList.add("connected");
      statusTextEl.textContent = message ?? "Connected to";
      if (statusSpinnerEl) statusSpinnerEl.style.display = "none";
      if (statusLogoEl) statusLogoEl.classList.remove("hidden");
    } else if (status === "error") {
      statusDotEl.classList.add("error");
      statusTextEl.textContent = message ?? "Error";
      if (statusSpinnerEl) statusSpinnerEl.style.display = "none";
      if (statusLogoEl) statusLogoEl.classList.add("hidden");
    } else {
      statusTextEl.textContent = "";
      if (statusSpinnerEl) statusSpinnerEl.style.display = "inline-block";
      if (statusLogoEl) statusLogoEl.classList.add("hidden");
    }
  }

  function fmtTime(ms) {
    if (!ms && ms !== 0) return "";
    const d = new Date(Number(ms));
    if (Number.isNaN(d.getTime())) return "";
    return d.toLocaleString();
  }

  function fmtTimeOnly(ms) {
    if (!ms && ms !== 0) return "";
    const d = new Date(Number(ms));
    if (Number.isNaN(d.getTime())) return "";
    return d.toLocaleTimeString(undefined, { hour: "2-digit", minute: "2-digit", second: "2-digit" });
  }

  function fmtDateTime(ms) {
    if (!ms && ms !== 0) return "";
    const d = new Date(Number(ms));
    if (Number.isNaN(d.getTime())) return "";
    const date = d.toLocaleDateString(undefined, { year: "numeric", month: "short", day: "2-digit" });
    const time = d.toLocaleTimeString(undefined, { hour: "2-digit", minute: "2-digit", second: "2-digit" });
    return `${date} ${time}`;
  }

  function fmtMoney(v, decimals = 2) {
    const n = Number(v);
    if (Number.isNaN(n)) return "";
    const sign = n < 0 ? "-" : "";
    const abs = Math.abs(n).toLocaleString(undefined, {
      minimumFractionDigits: decimals,
      maximumFractionDigits: decimals,
    });
    return `${sign}$${abs}`;
  }

  function getCssVar(name, fallback) {
    const val = getComputedStyle(document.body).getPropertyValue(name).trim();
    return val || fallback;
  }

  function getLastFiniteValue(list) {
    if (!Array.isArray(list)) return null;
    for (let i = list.length - 1; i >= 0; i -= 1) {
      const n = Number(list[i]);
      if (Number.isFinite(n)) return n;
    }
    return null;
  }

  function getLastFiniteFromDatasets(datasets) {
    if (!Array.isArray(datasets)) return null;
    for (const ds of datasets) {
      const val = getLastFiniteValue(ds?.data);
      if (Number.isFinite(val)) return val;
    }
    return null;
  }

  function updateChartTitleValues(liveEquityValue = null) {
    const liveEquity = Number.isFinite(liveEquityValue) ? liveEquityValue : null;
    const equityChartValue = Number.isFinite(chartLastValues.equity) ? chartLastValues.equity : null;
    const pnlChartValue = Number.isFinite(chartLastValues.pnl) ? chartLastValues.pnl : null;
    const depositsChartValue = Number.isFinite(chartLastValues.deposits) ? chartLastValues.deposits : null;

    if (equityTitleValueEl) {
      const equityDisplay = liveEquity !== null ? liveEquity : equityChartValue;
      equityTitleValueEl.textContent = equityDisplay !== null ? fmtMoney(equityDisplay, 0) : "-";
      equityTitleValueEl.classList.add("neutral");
    }

    if (pnlTitleValueEl) {
      let pnlDisplay = pnlChartValue;
      if (liveEquity !== null && equityChartValue !== null && pnlChartValue !== null) {
        pnlDisplay = pnlChartValue + (liveEquity - equityChartValue);
      }
      latestLivePnlValue = Number.isFinite(pnlDisplay) ? pnlDisplay : null;
      pnlTitleValueEl.textContent = pnlDisplay !== null ? formatSignedDollarWithPlus(pnlDisplay, 0) : "-";
      pnlTitleValueEl.classList.remove("positive", "negative");
      if (Number.isFinite(pnlDisplay)) {
        pnlTitleValueEl.classList.add(pnlDisplay >= 0 ? "positive" : "negative");
      }
    }

    if (metricTotalPnlEl) {
      const livePnl = Number.isFinite(latestLivePnlValue) ? latestLivePnlValue : null;
      if (livePnl !== null) {
        setMetricValue(metricTotalPnlEl, formatSignedDollarWithPlus(livePnl), livePnl);
      }
    }

    if (metricReturnEl) {
      const livePnl = Number.isFinite(latestLivePnlValue) ? latestLivePnlValue : null;
      const baseEquity = Number.isFinite(latestBaseEquityValue) ? latestBaseEquityValue : null;
      if (livePnl !== null && baseEquity && baseEquity !== 0) {
        const returnPct = livePnl / baseEquity;
        setMetricValue(metricReturnEl, formatSignedPercent(returnPct, 2), returnPct);
      }
    }

    if (depositsTitleValueEl) {
      depositsTitleValueEl.textContent =
        depositsChartValue !== null ? formatSignedDollarWithPlus(depositsChartValue, 0) : "-";
      depositsTitleValueEl.classList.remove("positive", "negative", "neutral");
      if (Number.isFinite(depositsChartValue)) {
        if (depositsChartValue === 0) {
          depositsTitleValueEl.classList.add("neutral");
        } else {
          depositsTitleValueEl.classList.add(depositsChartValue >= 0 ? "negative" : "positive");
        }
      }
    }
  }

  function getRangePnlLabel(rangeKey) {
    switch (rangeKey) {
      case "day":
        return "24 hr PnL change";
      case "week":
        return "7 day PnL change";
      case "month":
        return "30 day PnL change";
      case "allTime":
        return "All time PnL change";
      default:
        return "PnL change";
    }
  }

  function updateTotalPnlSubLabel(rangeKey) {
    if (!metricTotalPnlSubEl) return;
    metricTotalPnlSubEl.textContent = getRangePnlLabel(rangeKey);
  }

  function applyPnlTooltipStyling(chart) {
    if (!chart?.options?.plugins?.tooltip) return;
    const resolve = (v) => (v >= 0 ? getCssVar("--accent", "#22c55e") : getCssVar("--danger", "#ef4444"));
    chart.options.plugins.tooltip.enabled = false;
    chart.options.plugins.tooltip.external = (context) => {
      const { chart, tooltip } = context;
      let tooltipEl = chart.canvas.parentElement?.querySelector(".pnl-tooltip");
      if (!tooltipEl) {
        tooltipEl = document.createElement("div");
        tooltipEl.className = "pnl-tooltip";
        chart.canvas.parentElement?.appendChild(tooltipEl);
      }
      if (!tooltip || tooltip.opacity === 0) {
        tooltipEl.style.opacity = "0";
        return;
      }
      const point = tooltip.dataPoints?.[0];
      const v = Number(point?.parsed?.y ?? point?.raw ?? 0);
      const title = tooltip.title?.[0] || point?.label || "";
      tooltipEl.innerHTML = `
        <div class="pnl-tooltip-title">${title}</div>
        <div class="pnl-tooltip-value">${formatSignedDollarWithPlus(v, 2)}</div>
      `;
      const valueEl = tooltipEl.querySelector(".pnl-tooltip-value");
      if (valueEl) valueEl.style.color = resolve(v);
      positionChartTooltip(tooltipEl, chart, tooltip);
      tooltipEl.style.opacity = "1";
    };
  }

  function applyDepositsTooltipStyling(chart) {
    if (!chart?.options?.plugins?.tooltip) return;
    const resolve = (v) => {
      if (v === 0) return getCssVar("--neutral-blue", "rgba(124, 176, 255, 0.95)");
      return v >= 0 ? getCssVar("--danger", "#ef4444") : getCssVar("--accent", "#22c55e");
    };
    chart.options.plugins.tooltip.enabled = false;
    chart.options.plugins.tooltip.external = (context) => {
      const { chart, tooltip } = context;
      let tooltipEl = chart.canvas.parentElement?.querySelector(".pnl-tooltip");
      if (!tooltipEl) {
        tooltipEl = document.createElement("div");
        tooltipEl.className = "pnl-tooltip";
        chart.canvas.parentElement?.appendChild(tooltipEl);
      }
      if (!tooltip || tooltip.opacity === 0) {
        tooltipEl.style.opacity = "0";
        return;
      }
      const point = tooltip.dataPoints?.[0];
      const v = Number(point?.parsed?.y ?? point?.raw ?? 0);
      const title = tooltip.title?.[0] || point?.label || "";
      tooltipEl.innerHTML = `
        <div class="pnl-tooltip-title">${title}</div>
        <div class="pnl-tooltip-value">${formatSignedDollarWithPlus(v, 2)}</div>
      `;
      const valueEl = tooltipEl.querySelector(".pnl-tooltip-value");
      if (valueEl) valueEl.style.color = resolve(v);
      positionChartTooltip(tooltipEl, chart, tooltip);
      tooltipEl.style.opacity = "1";
    };
  }

  function applyEquityTooltipStyling(chart) {
    if (!chart?.options?.plugins?.tooltip) return;
    chart.options.plugins.tooltip.enabled = false;
    chart.options.plugins.tooltip.external = (context) => {
      const { chart, tooltip } = context;
      let tooltipEl = chart.canvas.parentElement?.querySelector(".pnl-tooltip");
      if (!tooltipEl) {
        tooltipEl = document.createElement("div");
        tooltipEl.className = "pnl-tooltip";
        chart.canvas.parentElement?.appendChild(tooltipEl);
      }
      if (!tooltip || tooltip.opacity === 0) {
        tooltipEl.style.opacity = "0";
        return;
      }
      const point = tooltip.dataPoints?.[0];
      const v = Number(point?.parsed?.y ?? point?.raw ?? 0);
      const title = tooltip.title?.[0] || point?.label || "";
      tooltipEl.innerHTML = `
        <div class="pnl-tooltip-title">${title}</div>
        <div class="pnl-tooltip-value">${fmtMoney(v, 2)}</div>
      `;
      const valueEl = tooltipEl.querySelector(".pnl-tooltip-value");
      if (valueEl) valueEl.style.color = getCssVar("--neutral-blue", "rgba(124, 176, 255, 0.95)");
      positionChartTooltip(tooltipEl, chart, tooltip);
      tooltipEl.style.opacity = "1";
    };
  }

  function positionChartTooltip(tooltipEl, chart, tooltip) {
    if (!tooltipEl || !chart || !tooltip) return;
    const { offsetLeft: positionX, offsetTop: positionY } = chart.canvas;
    const caretX = positionX + tooltip.caretX;
    const caretY = positionY + tooltip.caretY - 8;
    const chartArea = chart.chartArea || { left: 0, right: chart.width };
    const minX = positionX + chartArea.left + 6;
    const maxX = positionX + chartArea.right - 6;
    const halfWidth = tooltipEl.offsetWidth / 2;
    const clampedX = Math.min(Math.max(caretX, minX + halfWidth), maxX - halfWidth);
    const minY = positionY + chartArea.top + 6;
    const maxY = positionY + chartArea.bottom - 6;
    const height = tooltipEl.offsetHeight || 0;
    let top = caretY;
    if (top < minY) {
      top = minY;
    } else if (top + height > maxY) {
      top = maxY - height;
    }
    tooltipEl.style.left = `${clampedX}px`;
    tooltipEl.style.top = `${top}px`;
  }

  function fmtPrice(v) {
    if (v === null || v === undefined) return "";
    const n = Number(v);
    if (Number.isNaN(n)) return String(v);
    const formatted = n.toLocaleString(undefined, {
      maximumFractionDigits: 8,
      useGrouping: true,
    });
    return `$${formatted}`;
  }

  function fmtPriceFixed(v, decimals) {
    if (v === null || v === undefined) return "";
    const n = Number(v);
    if (Number.isNaN(n)) return String(v);
    const formatted = n.toLocaleString(undefined, {
      minimumFractionDigits: decimals,
      maximumFractionDigits: decimals,
      useGrouping: true,
    });
    return `$${formatted}`;
  }

  function fmtLimitPrice(v) { return fmtPrice(v); }

  function formatSignedDollar(v, decimals = 2) {
    const n = Number(v);
    if (Number.isNaN(n)) return "";
    const abs = Math.abs(n).toLocaleString(undefined, {
      minimumFractionDigits: decimals,
      maximumFractionDigits: decimals,
    });
    return n < 0 ? "-$" + abs : "$" + abs;
  }

  function formatSignedDollarWithPlus(v, decimals = 2) {
    const n = Number(v);
    if (Number.isNaN(n)) return "";
    const abs = Math.abs(n).toLocaleString(undefined, {
      minimumFractionDigits: decimals,
      maximumFractionDigits: decimals,
    });
    if (n > 0) return "+$" + abs;
    if (n < 0) return "-$" + abs;
    return "$" + abs;
  }

  function formatLeverage(value) {
    const n = Number(value);
    if (!Number.isFinite(n) || n === 0) return "â€“";
    const rounded = Number.isInteger(n) ? n.toFixed(0) : n.toFixed(1);
    return `${rounded}X`;
  }

  function getEntryLeverage(entry) {
    const leverage =
      entry?.leverage?.value ??
      entry?.leverage ??
      entry?.lever ??
      entry?.leverageValue ??
      entry?.maxLeverage ??
      entry?.lev;
    const n = Number(leverage);
    if (!Number.isFinite(n) || n === 0) return "";
    return formatLeverage(n);
  }

  function getOrderTypeLabel(entry) {
    const raw = entry?.orderType ?? entry?.type ?? entry?.order_type;
    if (typeof raw === "string") return raw.toUpperCase();
    if (raw && typeof raw === "object") {
      if (raw.limit) return "LIMIT";
      if (raw.market) return "MARKET";
      if (raw.trigger) return "TRIGGER";
    }
    if (entry?.isTrigger || entry?.triggerPx || entry?.triggerPrice) return "TRIGGER";
    if (entry?.isMarket || entry?.market) return "MARKET";
    if (entry?.tif) return "LIMIT";
    return "â€“";
  }

  function formatFunding(value) {
    const n = Number(value);
    if (!Number.isFinite(n) || n === 0) return "â€“";
    return formatSignedDollarWithPlus(-n);
  }

  function fundingToneClass(value) {
    const n = Number(value);
    if (!Number.isFinite(n) || n === 0) return "";
    return n < 0 ? "funding-pos" : "funding-neg";
  }

  function getPriceDecimals(value) {
    const n = Number(value);
    if (!Number.isFinite(n)) return null;
    const str = n.toLocaleString(undefined, { maximumFractionDigits: 8, useGrouping: false });
    const dot = str.indexOf(".");
    if (dot === -1) return 0;
    return Math.min(8, str.length - dot - 1);
  }

  function formatPriceWithMaxDecimals(value, maxDecimals) {
    const n = Number(value);
    if (!Number.isFinite(n)) return "";
    const decimals = Number.isFinite(maxDecimals) ? Math.max(0, Math.min(8, maxDecimals)) : 8;
    const formatted = n.toLocaleString(undefined, {
      maximumFractionDigits: decimals,
      useGrouping: true,
    });
    return `$${formatted}`;
  }

  function formatLiqPrice(value, entryPx, markPx) {
    const n = Number(value);
    if (!Number.isFinite(n) || n === 0) return "â€“";
    const entryDecimals = getPriceDecimals(entryPx);
    const markDecimals = getPriceDecimals(markPx);
    const refDecimals = Number.isFinite(entryDecimals) ? entryDecimals : markDecimals;
    return formatPriceWithMaxDecimals(n, refDecimals);
  }

  function computeLiqDistanceRatio(entryPx, markPx, liqPx, size) {
    const entry = Number(entryPx);
    const mark = Number(markPx);
    const liq = Number(liqPx);
    const szi = Number(size);
    if (!Number.isFinite(entry) || !Number.isFinite(mark) || !Number.isFinite(liq) || !Number.isFinite(szi)) return null;
    if (szi > 0) {
      const denom = entry - liq;
      if (!(denom > 0)) return null;
      return (mark - liq) / denom;
    }
    if (szi < 0) {
      const denom = liq - entry;
      if (!(denom > 0)) return null;
      return (liq - mark) / denom;
    }
    return null;
  }

  function getPositionsColspan() {
    return window.matchMedia("(max-width: 600px)").matches ? 4 : 8;
  }

  function getPositionsSortDefaultDir(key) {
    return key === "asset" || key === "side" ? "asc" : "desc";
  }

  function updatePositionsSortHeaders() {
    if (!positionsHeaderEls.length) return;
    positionsHeaderEls.forEach((th) => {
      let indicator = th.querySelector(".sort-indicator");
      if (!indicator) {
        indicator = document.createElement("span");
        indicator.className = "sort-indicator";
        th.appendChild(indicator);
      }
      if (th.dataset.sort === currentPositionsSort?.key) {
        th.setAttribute("data-sort-dir", currentPositionsSort.dir);
        indicator.textContent = currentPositionsSort.dir === "asc" ? " â†‘" : " â†“";
      } else {
        th.removeAttribute("data-sort-dir");
        indicator.textContent = "";
      }
    });
  }

  function updateTableSortHeaders(headerEls, sortState) {
    if (!headerEls.length) return;
    headerEls.forEach((th) => {
      let indicator = th.querySelector(".sort-indicator");
      if (!indicator) {
        indicator = document.createElement("span");
        indicator.className = "sort-indicator";
        th.appendChild(indicator);
      }
      if (th.dataset.sort === sortState?.key) {
        th.setAttribute("data-sort-dir", sortState.dir);
        indicator.textContent = sortState.dir === "asc" ? " â†‘" : " â†“";
      } else {
        th.removeAttribute("data-sort-dir");
        indicator.textContent = "";
      }
    });
  }

  function getGenericSortDefaultDir(key) {
    return ["asset", "side", "status", "orderId"].includes(key) ? "asc" : "desc";
  }

  function getPositionSortMetrics(item) {
    const p = item?.position || {};
    const coin = p.coin || "";
    const { dex: coinDex, base: coinBase } = splitDexCoin(coin);
    const coinDisplayName = coinBase || coin;
    const { label: spotLabel } = resolveSpotDisplay(coinDisplayName);
    const szi = Number(p.szi ?? 0);
    const entryPx = Number(p.entryPx ?? 0);
    const livePx = getLivePriceForCoin(coin);
    let markPx = Number.isFinite(livePx) ? livePx : undefined;
    const snapshotValue = Number(p.positionValue ?? 0);
    if ((markPx === undefined || Number.isNaN(markPx)) && szi !== 0 && !Number.isNaN(snapshotValue)) {
      markPx = Math.abs(snapshotValue) / Math.abs(szi);
    }
    let positionValue = snapshotValue;
    if (markPx !== undefined && !Number.isNaN(markPx) && szi !== 0) {
      positionValue = markPx * szi;
    }
    let upnl = Number(p.unrealizedPnl ?? 0);
    if (markPx !== undefined && !Number.isNaN(markPx) && !Number.isNaN(entryPx) && szi !== 0) {
      upnl = (markPx - entryPx) * szi;
    }
    const notional = Math.abs(Number(positionValue ?? 0));
    const isPerp = item?.marketType !== "spot";
    const fundingValue =
      (p.cumFunding && typeof p.cumFunding === "object"
        ? p.cumFunding.sinceOpen ?? p.cumFunding.sinceChange ?? p.cumFunding.allTime
        : p.cumFunding) ??
      p.funding ??
      p.fundingPaid ??
      p.cumFundingUsd ??
      p.cumFundingUSDC;
    const fundingDisplayValue = Number.isFinite(Number(fundingValue)) ? -Number(fundingValue) : null;
    const liqValue = p.liqPx ?? p.liquidationPx ?? p.liquidationPrice ?? p.liqPrice;
    const liqDistanceRaw = isPerp ? computeLiqDistanceRatio(entryPx, markPx, liqValue, szi) : null;
    const liqDistanceClamped = isPerp
      ? Number.isFinite(liqDistanceRaw)
        ? Math.max(0, Math.min(1, liqDistanceRaw))
        : 0
      : null;
    const liqDistanceDisplay =
      liqDistanceClamped === null ? null : Math.max(0, Math.min(1, 1 - liqDistanceClamped));
    const dir = szi > 0 ? "LONG" : szi < 0 ? "SHORT" : "FLAT";
    const ageMs = computePositionAgeMs(coin, szi, item?.wallet || primaryWallet);
    return {
      asset: (spotLabel || coinDisplayName || coin || "").toUpperCase(),
      side: dir,
      size: Math.abs(szi),
      price: Number.isFinite(markPx) ? markPx : null,
      notional: Number.isFinite(notional) ? notional : null,
      upnl: Number.isFinite(upnl) ? upnl : null,
      funding: Number.isFinite(fundingDisplayValue) ? fundingDisplayValue : null,
      liq: Number.isFinite(liqDistanceDisplay) ? liqDistanceDisplay : null,
      age: Number.isFinite(ageMs) ? ageMs : null,
    };
  }

  function comparePositionSort(a, b, dir) {
    const aEmpty = a === null || a === undefined || (typeof a === "number" && Number.isNaN(a));
    const bEmpty = b === null || b === undefined || (typeof b === "number" && Number.isNaN(b));
    if (aEmpty && bEmpty) return 0;
    if (aEmpty) return 1;
    if (bEmpty) return -1;
    if (typeof a === "string" || typeof b === "string") {
      const cmp = String(a).localeCompare(String(b));
      return dir === "asc" ? cmp : -cmp;
    }
    const diff = a - b;
    return dir === "asc" ? diff : -diff;
  }

  function formatShortWallet(value) {
    const w = String(value || "");
    if (w.length <= 10) return w;
    return `${w.slice(0, 6)}â€¦${w.slice(-4)}`;
  }

  function getShareCoinLogoUrl(rawCoin) {
    const normalized = normalizeFooterCoinValue(rawCoin);
    if (!normalized) return null;
    const special = getSpecialLogoUrl(normalized, normalized);
    if (special) return special;
    const { base } = splitDexCoin(normalized);
    const local = String(base || normalized).replace("/", "_");
    const pngOnly = new Set(["USA500", "COPPER"]);
    const ext = pngOnly.has(local) ? "png" : "svg";
    return `images/coins/${encodeURIComponent(local)}.${ext}`;
  }

  function isSameOriginAsset(url) {
    if (!url) return false;
    if (url.startsWith("images/") || url.startsWith("./") || url.startsWith("/")) return true;
    try {
      const parsed = new URL(url, window.location.href);
      return parsed.origin === window.location.origin;
    } catch (e) {
      return false;
    }
  }

  function drawRoundedRect(ctx, x, y, w, h, r) {
    const radius = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.arcTo(x + w, y, x + w, y + h, radius);
    ctx.arcTo(x + w, y + h, x, y + h, radius);
    ctx.arcTo(x, y + h, x, y, radius);
    ctx.arcTo(x, y, x + w, y, radius);
    ctx.closePath();
  }

  function parseSignedMoney(value) {
    const str = String(value || "");
    const cleaned = str.replace(/[^0-9.-]/g, "");
    const num = Number(cleaned);
    return Number.isFinite(num) ? num : null;
  }

  const DEFAULT_SHARE_META = {
    modalTitle: "Share Asset Performance",
    filename: "hypermonitor-pnl.png",
    title: "Hypermonitor PnL",
    text: "Discover Hypermonitor",
  };
  let activeShareMeta = { ...DEFAULT_SHARE_META };

  function setShareMeta(next) {
    activeShareMeta = { ...DEFAULT_SHARE_META, ...(next || {}) };
    if (shareModalTitleEl) {
      shareModalTitleEl.textContent = activeShareMeta.modalTitle || DEFAULT_SHARE_META.modalTitle;
    }
  }

  function slugifyLabel(value) {
    return String(value || "")
      .trim()
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/(^-|-$)/g, "");
  }

  function formatShareWalletLabel(value) {
    const label = String(value || "").trim();
    if (!label) return "-";
    if (/^0x[a-fA-F0-9]{8,}$/.test(label)) return formatShortWallet(label);
    return label;
  }

  function getMetricText(el) {
    return (el?.textContent || "-").trim() || "-";
  }

  function stripWholeDecimals(text) {
    return String(text || "").replace(/\b(\d[\d,]*)\.00\b/g, "$1");
  }

  async function buildPnlShareImage(data) {
    const canvas = document.createElement("canvas");
    canvas.width = 1080;
    canvas.height = 1350;
    const ctx = canvas.getContext("2d");
    if (!ctx) return null;

    const pnlValue = parseSignedMoney(data.upnl);
    const accent = pnlValue !== null && pnlValue < 0 ? "#fb7185" : "#4ade80";
    const logoAccent = pnlValue !== null && pnlValue < 0 ? "#fb7185" : "#97fde5";

    const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
    gradient.addColorStop(0, "#0b0b0f");
    gradient.addColorStop(1, "#0e141c");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Soft glow blobs to match site aesthetic
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = logoAccent;
    ctx.beginPath();
    ctx.arc(820, 420, 220, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "#1f2937";
    ctx.beginPath();
    ctx.arc(680, 760, 260, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Diagonal waves
    ctx.strokeStyle = logoAccent === "#97fde5" ? "rgba(151, 253, 229, 0.12)" : "rgba(251, 113, 133, 0.12)";
    ctx.lineWidth = 1;
    for (let i = 0; i < 14; i += 1) {
      ctx.beginPath();
      ctx.moveTo(420, 220 + i * 40);
      ctx.bezierCurveTo(620, 140 + i * 42, 840, 180 + i * 38, 1040, 120 + i * 34);
      ctx.stroke();
    }

    // Accent ring + dot
    ctx.strokeStyle = logoAccent;
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.arc(830, 520, 80, 0, Math.PI * 2);
    ctx.stroke();
    ctx.fillStyle = logoAccent;
    ctx.beginPath();
    ctx.arc(830, 520, 8, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "rgba(255,255,255,0.06)";
    drawRoundedRect(ctx, 40, 40, 1000, 1270, 28);
    ctx.fill();

    const canDrawLogo = window.location?.protocol !== "file:";
    let logo = null;
    let coinLogo = null;
    if (canDrawLogo) {
      logo = new Image();
      const logoSrc = "images/logo.png";
      await new Promise((resolve) => {
        logo.onload = resolve;
        logo.onerror = resolve;
        logo.src = logoSrc;
      });

      const coinLogoUrl = getShareCoinLogoUrl(data.coin);
      if (coinLogoUrl && isSameOriginAsset(coinLogoUrl)) {
        coinLogo = new Image();
        await new Promise((resolve) => {
          coinLogo.onload = resolve;
          coinLogo.onerror = resolve;
          coinLogo.src = coinLogoUrl;
        });
      }
    }

    ctx.textBaseline = "top";
    ctx.fillStyle = "#ffffff";
    ctx.font = "700 52px Outfit, sans-serif";
    const title = "HYPERMONITOR";
    const titleY = 92;
    const titleCenterY = titleY + 26;
    if (logo && logo.width) {
      const logoSize = 88;
      const logoY = titleCenterY - logoSize / 2 - 2;
      ctx.drawImage(logo, 90, logoY, logoSize, logoSize);
    }
    ctx.fillText(title, 190, titleY);

    ctx.fillStyle = "rgba(245,245,255,0.8)";
    ctx.font = "500 28px Outfit, sans-serif";
    ctx.fillText(formatShortWallet(data.wallet), 90, 180);

    ctx.fillStyle = "#ffffff";
    ctx.font = "600 36px Outfit, sans-serif";
    const assetText = `${data.asset || ""}`;
    const assetY = 248;
    const assetCenterY = assetY + 18;
    const coinSize = 40;
    const coinY = assetCenterY - coinSize / 2 - 4;
    if (coinLogo && coinLogo.width) {
      ctx.drawImage(coinLogo, 90, coinY, coinSize, coinSize);
    } else {
      const letter = (data.asset || "?").slice(0, 1).toUpperCase();
      ctx.fillStyle = "rgba(151, 253, 229, 0.2)";
      drawRoundedRect(ctx, 90, coinY, coinSize, coinSize, 12);
      ctx.fill();
      ctx.fillStyle = "#97fde5";
      ctx.font = "700 20px Outfit, sans-serif";
      ctx.fillText(letter, 90 + 12, coinY + 8);
      ctx.font = "600 36px Outfit, sans-serif";
    }
    ctx.fillStyle = "#ffffff";
    ctx.fillText(assetText, 145, assetY);

    if (data.spot === "true") {
      const label = "SPOT";
      ctx.font = "600 22px Outfit, sans-serif";
      const pillW = ctx.measureText(label).width + 22;
      const pillH = 32;
      const pillX = 320;
      const pillY = 254;
      ctx.fillStyle = "rgba(0, 112, 243, 0.2)";
      drawRoundedRect(ctx, pillX, pillY, pillW, pillH, 16);
      ctx.fill();
      ctx.strokeStyle = "rgba(0, 112, 243, 0.65)";
      ctx.lineWidth = 1.5;
      ctx.stroke();
      ctx.fillStyle = "#0070f3";
      ctx.fillText(label, pillX + 11, pillY + 5);
    }

    if (data.direction) {
      const pillText = data.direction;
      ctx.font = "600 26px Outfit, sans-serif";
      const pillWidth = ctx.measureText(pillText).width + 30;
      const pillHeight = 40;
      const pillX = 90;
      const pillY = 308;
      const pillColor = data.direction.startsWith("SHORT") ? "#fb7185" : "#4ade80";
      ctx.fillStyle = pillColor + "33";
      drawRoundedRect(ctx, pillX, pillY, pillWidth, pillHeight, 20);
      ctx.fill();
      ctx.strokeStyle = pillColor + "88";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.fillStyle = pillColor;
      ctx.fillText(pillText, pillX + 16, pillY + 6);
    }

    if (data.roe) {
      ctx.fillStyle = accent;
      ctx.font = "700 86px Outfit, sans-serif";
      ctx.fillText(data.roe, 90, 360);
    }

    ctx.fillStyle = "rgba(245,245,255,0.7)";
    ctx.font = "500 26px Outfit, sans-serif";
    ctx.fillText("Unrealized PnL", 90, 470);

    ctx.fillStyle = "#ffffff";
    ctx.font = "700 48px Outfit, sans-serif";
    ctx.fillText(data.upnl || "", 90, 510);

    ctx.fillStyle = "rgba(245,245,255,0.7)";
    ctx.font = "500 26px Outfit, sans-serif";
    ctx.fillText("Entry Price", 90, 620);
    ctx.fillStyle = "#ffffff";
    ctx.font = "600 36px Outfit, sans-serif";
    ctx.fillText(data.entry || "", 90, 660);

    ctx.fillStyle = "rgba(245,245,255,0.7)";
    ctx.font = "500 26px Outfit, sans-serif";
    ctx.fillText("Current Price", 90, 740);
    ctx.fillStyle = "#ffffff";
    ctx.font = "600 36px Outfit, sans-serif";
    ctx.fillText(data.current || "", 90, 780);

    const qrSize = 125;
    const qrX = canvas.width - qrSize - 90;
    const qrY = 1160;
    if (data.wallet) {
      const qrUrl = `https://www.hypermonitor.org/track?wallet=${encodeURIComponent(data.wallet)}`;
      drawQrCode(ctx, qrUrl, qrX, qrY, qrSize);
      ctx.fillStyle = "rgba(245,245,255,0.85)";
      ctx.font = "600 28px Outfit, sans-serif";
      const qrCaptionLine1 = "Scan to track";
      const qrCaptionLine2 = "performance:";
      const line1Width = ctx.measureText(qrCaptionLine1).width;
      const line2Width = ctx.measureText(qrCaptionLine2).width;
      const captionX = qrX - Math.max(line1Width, line2Width) - 22;
      const captionY = qrY + qrSize / 2 - 28;
      ctx.fillText(qrCaptionLine1, captionX, captionY);
      ctx.fillText(qrCaptionLine2, captionX, captionY + 32);
    }

    ctx.fillStyle = "rgba(245,245,255,0.6)";
    ctx.font = "500 26px Outfit, sans-serif";
    ctx.fillText("https://hypermonitor.org/", 90, 1240);

    try {
      return canvas.toDataURL("image/png");
    } catch (err) {
      console.error("Share image export failed", err);
      return null;
    }
  }

  async function buildPerformanceShareImage() {
    const canvas = document.createElement("canvas");
    canvas.width = 1200;
    canvas.height = 1400;
    const ctx = canvas.getContext("2d");
    if (!ctx) return null;

    const rangeLabel = getRangeLabel(currentRangeKey);
    const rangeNaturalLabel =
      rangeLabel === "Day"
        ? "Daily"
        : rangeLabel === "Week"
          ? "Weekly"
          : rangeLabel === "Month"
            ? "Monthly"
            : "All time";
    const rangeSlug = slugifyLabel(rangeLabel);
    const source = getMetricsSource(currentRangeKey);
    const primaryWalletLabel = formatShareWalletLabel(primaryWallet || "");
    const walletLabel =
      currentWallets.length > 1
        ? `Wallets (${currentWallets.length}) Â· ${primaryWalletLabel}`
        : `${primaryWalletLabel}`;
    const marketLabel = currentMarketType === "spot" ? "Spot" : "Perps";

    const totalPnlText = getMetricText(metricTotalPnlEl);
    const returnText = getMetricText(metricReturnEl);
    const maxDrawdownText = getMetricText(metricMaxDrawdownEl);
    const sharpeText = getMetricText(metricSharpeEl);
    const volatilityText = getMetricText(metricVolatilityEl);
    const bestIntervalText = getMetricText(metricBestIntervalEl);
    const winRateText = getMetricText(metricWinRateEl);
    const ordersPerDayText = stripWholeDecimals(getMetricText(metricOrdersTradesPerDayEl));

    const pnlValue = parseSignedMoney(totalPnlText);
    const accent = pnlValue !== null && pnlValue < 0 ? "#fb7185" : "#4ade80";
    const accentSoft = pnlValue !== null && pnlValue < 0 ? "rgba(251, 113, 133, 0.18)" : "rgba(74, 222, 128, 0.18)";

    const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
    gradient.addColorStop(0, "#0b0b0f");
    gradient.addColorStop(1, "#0e141c");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.globalAlpha = 0.12;
    ctx.fillStyle = accent;
    ctx.beginPath();
    ctx.arc(920, 420, 240, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "#1f2937";
    ctx.beginPath();
    ctx.arc(760, 840, 280, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.strokeStyle = pnlValue !== null && pnlValue < 0 ? "rgba(251, 113, 133, 0.12)" : "rgba(151, 253, 229, 0.12)";
    ctx.lineWidth = 1;
    for (let i = 0; i < 14; i += 1) {
      ctx.beginPath();
      ctx.moveTo(420, 220 + i * 40);
      ctx.bezierCurveTo(620, 140 + i * 42, 840, 180 + i * 38, 1040, 120 + i * 34);
      ctx.stroke();
    }

    ctx.fillStyle = "rgba(255,255,255,0.06)";
    drawRoundedRect(ctx, 40, 40, 1120, 1320, 28);
    ctx.fill();

    const canDrawLogo = window.location?.protocol !== "file:";
    let logo = null;
    if (canDrawLogo) {
      logo = new Image();
      const logoSrc = "images/logo.png";
      await new Promise((resolve) => {
        logo.onload = resolve;
        logo.onerror = resolve;
        logo.src = logoSrc;
      });
    }

    if (logo && logo.width) {
      ctx.save();
      ctx.globalAlpha = 0.1;
      const logoSize = 260;
      const logoX = 920 - logoSize / 2;
      const logoY = 420 - logoSize / 2;
      ctx.drawImage(logo, logoX, logoY, logoSize, logoSize);
      ctx.restore();
    }

    ctx.textBaseline = "top";
    ctx.fillStyle = "#ffffff";
    ctx.font = "700 52px Outfit, sans-serif";
    const title = "HYPERMONITOR";
    const titleY = 86;
    const titleCenterY = titleY + 26;
    if (logo && logo.width) {
      const logoSize = 88;
      const logoY = titleCenterY - logoSize / 2 - 2;
      ctx.drawImage(logo, 90, logoY, logoSize, logoSize);
    }
    ctx.fillText(title, 190, titleY);

    ctx.fillStyle = "rgba(245,245,255,0.8)";
    ctx.font = "500 28px Outfit, sans-serif";
    ctx.fillStyle = "rgba(245,245,255,0.7)";
    ctx.font = "500 28px Outfit, sans-serif";
    ctx.fillText(walletLabel, 90, 180);

    const pillY = 254;
    const rangeText = `${rangeNaturalLabel} performance`;
    ctx.fillStyle = "rgba(245,245,255,0.8)";
    ctx.font = "500 30px Outfit, sans-serif";
    ctx.fillText(rangeText, 90, pillY + 2);
    const rangeW = ctx.measureText(rangeText).width;

    ctx.font = "600 24px Outfit, sans-serif";
    const pillText = marketLabel.toUpperCase();
    const pillW = ctx.measureText(pillText).width + 24;
    const pillX = 90 + rangeW + 18;
    ctx.fillStyle = accentSoft;
    drawRoundedRect(ctx, pillX, pillY, pillW, 36, 18);
    ctx.fill();
    ctx.strokeStyle = accent;
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.fillStyle = accent;
    ctx.fillText(pillText, pillX + 12, pillY + 6);
    const returnValue = Number(String(returnText).replace(/[^0-9.+-]/g, ""));
    const returnAccent = Number.isFinite(returnValue) ? (returnValue < 0 ? "#fb7185" : "#4ade80") : "#ffffff";

    ctx.fillStyle = returnAccent;
    ctx.font = "700 98px Outfit, sans-serif";
    ctx.fillText(returnText, 90, 320);

    ctx.fillStyle = "rgba(245,245,255,0.7)";
    ctx.font = "500 28px Outfit, sans-serif";
    ctx.fillText("Return", 90, 430);

    ctx.fillStyle = "#ffffff";
    ctx.font = "700 64px Outfit, sans-serif";
    ctx.fillText(totalPnlText, 90, 470);

    const cards = [
      { label: "Max Drawdown", value: maxDrawdownText },
      { label: "Sharpe (PnL)", value: sharpeText },
      { label: "Volatility", value: volatilityText },
      { label: "Best Interval", value: bestIntervalText },
      { label: "Win Rate", value: winRateText },
      { label: "Orders (Trades) Per Day", value: ordersPerDayText },
    ];
    const cardW = 490;
    const cardH = 140;
    const cardX = 90;
    const cardY = 660;
    const cardGap = 40;

    cards.forEach((card, index) => {
      const col = index % 2;
      const row = Math.floor(index / 2);
      const x = cardX + col * (cardW + cardGap);
      const y = cardY + row * (cardH + 30);
      ctx.fillStyle = "rgba(255,255,255,0.06)";
      drawRoundedRect(ctx, x, y, cardW, cardH, 18);
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.08)";
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.fillStyle = "rgba(245,245,255,0.7)";
      ctx.font = "600 24px Outfit, sans-serif";
      ctx.fillText(card.label.toUpperCase(), x + 22, y + 18);

      ctx.fillStyle = "#ffffff";
      ctx.font = "600 38px Outfit, sans-serif";
      ctx.fillText(card.value, x + 22, y + 62);
    });

    const statsEndY = cardY + 2 * (cardH + 30) + cardH;
    const qrSize = 125;
    const qrX = canvas.width - qrSize - 90;
    const qrY = statsEndY + 40;
    const qrWallet = primaryWallet || "";
    if (qrWallet) {
      const qrUrl = `https://www.hypermonitor.org/track?wallet=${encodeURIComponent(qrWallet)}`;
      drawQrCode(ctx, qrUrl, qrX, qrY, qrSize);
    }

    ctx.fillStyle = "rgba(245,245,255,0.85)";
    ctx.font = "600 28px Outfit, sans-serif";
    const qrCaptionLine1 = "Scan to track";
    const qrCaptionLine2 = "performance:";
    const line1Width = ctx.measureText(qrCaptionLine1).width;
    const line2Width = ctx.measureText(qrCaptionLine2).width;
    const captionX = qrX - Math.max(line1Width, line2Width) - 22;
    const captionY = qrY + qrSize / 2 - 28;
    ctx.fillText(qrCaptionLine1, captionX, captionY);
    ctx.fillText(qrCaptionLine2, captionX, captionY + 32);

    ctx.fillStyle = "rgba(245,245,255,0.6)";
    ctx.font = "500 26px Outfit, sans-serif";
    ctx.fillText("https://hypermonitor.org/", 90, 1280);

    try {
      const dataUrl = canvas.toDataURL("image/png");
      return { dataUrl, rangeSlug };
    } catch (err) {
      console.error("Performance share export failed", err);
      return null;
    }
  }

  function openPnlShareModal(dataUrl, meta) {
    if (!pnlShareModalEl || !sharePreviewImgEl) return;
    setShareMeta(meta);
    sharePreviewImgEl.src = dataUrl || "";
    pnlShareModalEl.classList.add("open");
    pnlShareModalEl.setAttribute("aria-hidden", "false");
  }

  function closePnlShareModal() {
    if (!pnlShareModalEl) return;
    pnlShareModalEl.classList.remove("open");
    pnlShareModalEl.setAttribute("aria-hidden", "true");
  }

  function computePositionAgeMs(coin, szi, wallet) {
    const target = Number(szi) || 0;
    if (target === 0) return null;
    const fillsForCoin = getAllFillsForCoin(coin, wallet, currentMarketType);
    if (!fillsForCoin.length) return null;
    const sorted = [...fillsForCoin].sort(
      (a, b) => Number(b.time ?? b.timestamp ?? 0) - Number(a.time ?? a.timestamp ?? 0)
    );
    let netSize = 0;
    let oldestTime = null;
    const EPS = 1e-8;
    for (const fill of sorted) {
      const sideRaw =
        fill.side ??
        (fill.isBuy !== undefined ? (fill.isBuy ? "B" : "S") : undefined) ??
        fill.dir ??
        fill.direction ??
        "?";
      const sideUpper = String(sideRaw).toUpperCase();
      let side = "?";
      if (sideUpper.startsWith("B") || sideUpper === "1" || sideUpper === "+1") side = "B";
      else if (
        sideUpper.startsWith("S") ||
        sideUpper.startsWith("A") ||
        sideUpper === "-1" ||
        sideUpper === "SELL" ||
        sideUpper === "SHORT"
      )
        side = "S";
      const sizeCandidates = [fill.szi, fill.sz, fill.size, fill.qty, fill.quantity, fill.baseSz, fill.baseSize];
      let sizeRaw = 0;
      for (const cand of sizeCandidates) {
        const n = Number(cand);
        if (!Number.isNaN(n)) {
          sizeRaw = n;
          break;
        }
      }
      if (side === "?") {
        if (sizeRaw > 0) side = "B";
        else if (sizeRaw < 0) side = "S";
      }
      const signed = side === "B" ? Math.abs(sizeRaw) : side === "S" ? -Math.abs(sizeRaw) : sizeRaw;
      netSize += Number.isFinite(signed) ? signed : 0;
      const rawTime = Number(fill.time ?? fill.timestamp ?? 0);
      const normalized = normalizeTimestamp(rawTime);
      if (Number.isFinite(normalized)) oldestTime = normalized;
      if (Math.abs(netSize - target) <= EPS) break;
    }
    if (!Number.isFinite(oldestTime)) return null;
    const age = Date.now() - oldestTime;
    return Number.isFinite(age) && age >= 0 ? age : null;
  }

  function formatSignedPercent(value, decimals = 2) {
    const n = Number(value);
    if (!Number.isFinite(n)) return "";
    const pct = n * 100;
    const abs = Math.abs(pct).toFixed(decimals);
    if (pct > 0) return `+${abs}%`;
    if (pct < 0) return `-${abs}%`;
    return `${abs}%`;
  }

  function formatPercent(value, decimals = 2) {
    const n = Number(value);
    if (!Number.isFinite(n)) return "";
    return `${(n * 100).toFixed(decimals)}%`;
  }

  function formatNumber(value, decimals = 2) {
    const n = Number(value);
    if (!Number.isFinite(n)) return "";
    return n.toLocaleString(undefined, {
      minimumFractionDigits: decimals,
      maximumFractionDigits: decimals,
    });
  }

  function formatRatio(value, decimals = 2) {
    const n = Number(value);
    if (!Number.isFinite(n)) return "";
    return n.toFixed(decimals);
  }

  function formatDuration(ms) {
    const n = Number(ms);
    if (!Number.isFinite(n) || n <= 0) return "";
    const totalSeconds = Math.floor(n / 1000);
    const days = Math.floor(totalSeconds / 86400);
    const hours = Math.floor((totalSeconds % 86400) / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    if (days > 0) return `${days}d ${hours}h`;
    if (hours > 0) return `${hours}h ${minutes}m`;
    if (minutes > 0) return `${minutes}m`;
    return `${totalSeconds}s`;
  }

  function normalizeTimestamp(value) {
    const n = Number(value);
    if (!Number.isFinite(n)) return null;
    if (n < 1e12) return n * 1000;
    return n;
  }

  function getLocalDayKey(ms) {
    const d = new Date(ms);
    if (Number.isNaN(d.getTime())) return "";
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, "0");
    const day = String(d.getDate()).padStart(2, "0");
    return `${y}-${m}-${day}`;
  }

  function rememberCoinAlias(raw, resolved) {
    if (!raw || !resolved) return;
    const key = String(raw).trim();
    const val = String(resolved).trim();
    if (!key || !val) return;
    coinIdMap.set(key, val);
    if (key.startsWith("@")) coinIdMap.set(key.slice(1), val);
  }

  function resolveCoinName(raw, alt) {
    const primary = (raw || "").trim();
    const secondary = (alt || "").trim();

    if (primary && secondary && primary !== secondary) {
      rememberCoinAlias(primary, secondary);
      rememberCoinAlias(secondary, primary);
    }

    if (primary.startsWith("@")) {
      const lookup = coinIdMap.get(primary) || coinIdMap.get(primary.slice(1));
      if (lookup) return lookup;
      if (secondary && !secondary.startsWith("@")) return secondary;
    }
    if (secondary.startsWith("@")) {
      const lookup = coinIdMap.get(secondary) || coinIdMap.get(secondary.slice(1));
      if (lookup) return lookup;
    }

    return primary || secondary;
  }

  function buildTokenIndexMap(tokens) {
    const map = new Map();
    for (const t of tokens) {
      if (t && typeof t.index !== "undefined" && typeof t.name !== "undefined") {
        map.set(Number(t.index), String(t.name));
      }
    }
    return map;
  }

  function deriveSpotPair(u, tokenByIndex) {
    const name = String(u?.name ?? "");
    if (name.includes("/")) {
      const [base, quote] = name.split("/", 2);
      return { pair: name, base, quote };
    }
    const toks = u?.tokens;
    if (Array.isArray(toks) && toks.length >= 2) {
      const base = tokenByIndex.get(Number(toks[0])) ?? `token${toks[0]}`;
      const quote = tokenByIndex.get(Number(toks[1])) ?? `token${toks[1]}`;
      return { pair: `${base}/${quote}`, base, quote };
    }
    return { pair: name || "UNKNOWN", base: "UNKNOWN", quote: "UNKNOWN" };
  }

  async function ensureSpotMeta() {
    if (spotIdMetaMap.size) return;
    if (spotMetaPromise) return spotMetaPromise;

    spotMetaPromise = (async () => {
      try {
        const res = await fetch(PORTFOLIO_API_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ type: "spotMeta" }),
        });
        if (!res.ok) throw new Error(`spotMeta error: ${res.status} ${res.statusText}`);
        const data = await res.json();
        const tokens = data?.tokens;
        const universe = data?.universe;
        if (!Array.isArray(tokens) || !Array.isArray(universe)) {
          throw new Error("spotMeta response missing tokens/universe");
        }
        const tokenByIndex = buildTokenIndexMap(tokens);
        universe
          .filter((u) => u && typeof u.index !== "undefined")
          .forEach((u) => {
            const idx = Number(u.index);
            const spotId = `@${idx}`;
            const { pair, base, quote } = deriveSpotPair(u, tokenByIndex);
            spotIdMetaMap.set(spotId, { base, quote, pair, isCanonical: Boolean(u.isCanonical) });
            rememberCoinAlias(spotId, base);
          });
      } catch (err) {
        console.warn("Failed to load spot meta", err);
      } finally {
        spotMetaPromise = null;
      }
    })();

    return spotMetaPromise;
  }

  function formatSpotIdHtml(rawId) {
    const key = String(rawId ?? "");
    if (!key.startsWith("@")) return key;
    const meta = spotIdMetaMap.get(key);
    if (!meta?.base) return key;
    return `<span class="spot-id">${meta.base}</span> <span class="dex-tag spot-tag">spot</span>`;
  }

  function resolveSpotDisplay(rawName) {
    const key = String(rawName ?? "");
    const meta = key.startsWith("@") ? spotIdMetaMap.get(key) : null;
    return {
      label: meta?.base || key,
      iconKey: meta?.base || key,
      isSpot: Boolean(meta?.base),
    };
  }

  function fmtSize(v) {
    if (v === null || v === undefined) return "";
    const n = Number(v);
    if (Number.isNaN(n)) return String(v);
    return n.toLocaleString();
  }

  function fmtSignedSize(v) {
    const n = Number(v);
    if (Number.isNaN(n)) return "";
    const sign = n > 0 ? "+" : n < 0 ? "-" : "";
    return `${sign}${fmtSize(Math.abs(n))}`;
  }

  function xmlEscape(v) {
    const s = v === null || v === undefined ? "" : String(v);
    return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\"/g, "&quot;").replace(/'/g, "&apos;");
  }

  function walletTagHtml(wallet) {
    if (!wallet || currentWallets.length <= 1) return "";
    const safe = xmlEscape(wallet);
    const label = xmlEscape(formatWalletLabel(wallet));
    return `<span class="wallet-tag" title="${safe}">${label}</span>`;
  }

  function getIconCandidates(rawName, cleanName) {
    const candidates = [];
    const specialLogo = getSpecialLogoUrl(rawName, cleanName);
    if (specialLogo) candidates.push(specialLogo);
    if (rawName) candidates.push(`${COIN_ICON_BASE}${encodeURIComponent(rawName)}.svg`);
    if (cleanName && cleanName !== rawName) candidates.push(`${COIN_ICON_BASE}${encodeURIComponent(cleanName)}.svg`);
    const addUnprefixed = (name) => {
      if (!name || name.length <= 1) return;
      if (name[0] !== "U" && name[0] !== "u") return;
      const unprefixed = name.slice(1);
      if (!unprefixed) return;
      candidates.push(`${COIN_ICON_BASE}${encodeURIComponent(unprefixed)}.svg`);
      const upper = unprefixed.toUpperCase();
      if (upper !== unprefixed) {
        candidates.push(`${COIN_ICON_BASE}${encodeURIComponent(upper)}.svg`);
      }
    };
    addUnprefixed(cleanName);
    addUnprefixed(rawName);
    if (rawName && rawName.includes(":")) candidates.push(`${COIN_ICON_BASE}${encodeURIComponent(rawName)}.svg`);
    return Array.from(new Set(candidates));
  }

  function getSpecialLogoUrl(rawName, cleanName) {
    const keys = [cleanName, rawName];
    for (const key of keys) {
      if (!key) continue;
      const upper = String(key).trim().toUpperCase();
      if (SPECIAL_LOGOS.has(upper)) return SPECIAL_LOGOS.get(upper);
      if (upper.includes(":")) {
        const base = upper.split(":").pop();
        if (SPECIAL_LOGOS.has(base)) return SPECIAL_LOGOS.get(base);
      }
    }
    return null;
  }

  function ensureLogoCache(rawKey, rawName, cleanName) {
    if (logoCache.has(rawKey)) return logoCache.get(rawKey);
    const urls = getIconCandidates(rawName, cleanName);
    const entry = { state: "unknown", idx: 0, urls, okUrl: null };
    logoCache.set(rawKey, entry);
    return entry;
  }

  function scheduleLogoRetry() {
    if (logoRetryTimer) return;
    logoRetryTimer = setTimeout(() => {
      logoRetryTimer = null;
      retryFailedLogos();
    }, 3000);
  }

  function scheduleLogoRefresh() {
    if (logoRefreshTimer) return;
    logoRefreshTimer = setTimeout(() => {
      logoRefreshTimer = null;
      if (currentAssetPositions.length) renderPositions(currentAssetPositions);
      renderOpenOrders();
      renderCanceledOrders();
      renderFills();
      if (historicalOrdersLoaded) renderHistoricalOrders();
      if (historicalFillsLoaded) renderHistoricalFills();
    }, 120);
  }

  function retryFailedLogos() {
    let changed = false;
    logoCache.forEach((entry) => {
      if (entry.state !== "bad") return;
      if (entry.permaFail) return;
      if ((entry.retryCount || 0) > 2) return;
      entry.state = "unknown";
      entry.idx = 0;
      entry.okUrl = null;
      changed = true;
    });
    if (!changed) return;
    if (currentAssetPositions.length) renderPositions(currentAssetPositions);
    renderOpenOrders();
    renderCanceledOrders();
    renderFills();
    if (historicalOrdersLoaded) renderHistoricalOrders();
    if (historicalFillsLoaded) renderHistoricalFills();
  }

  function coinIconHtml(rawName, cleanName) {
    const logoKey = normalizeLogoKey(rawName || cleanName);
    const entry = ensureLogoCache(logoKey, rawName, cleanName);
    const letter = (cleanName?.[0] || rawName?.[0] || "?").toUpperCase();

    if (entry.state === "bad" || !entry.urls.length) {
      return `<span class="coinFallback">${letter}</span>`;
    }

    const src = (entry.state === "ok" && entry.okUrl) ? entry.okUrl : entry.urls[entry.idx || 0];
    const safeKey = logoKey.replace(/'/g, "\\'");

    return `
      <img
        class="coinIcon"
        src="${src}"
        alt="${cleanName || rawName}"
        loading="lazy"
        referrerpolicy="no-referrer"
        onload="window.__logoOk('${safeKey}', this)"
        onerror="window.__logoErr('${safeKey}', this, '${letter}')"
      />
    `;
  }

  function splitDexCoin(name) {
    const s = String(name || "").trim();
    const idx = s.indexOf(":");
    if (idx > 0 && idx < s.length - 1) {
      return { dex: s.slice(0, idx), base: s.slice(idx + 1) };
    }
    return { dex: "", base: s };
  }

  function isSpotKey(raw) {
    return String(raw || "").trim().startsWith("@");
  }

  function getMarketTypeFromCoin(raw) {
    return isSpotKey(raw) ? "spot" : "perp";
  }

  function entryMatchesMarketType(entry, marketType = currentMarketType) {
    if (marketType === "all") return true;
    const explicit = entry?.marketType;
    if (explicit) return explicit === marketType;
    const rawCoin =
      entry?.coin ??
      entry?.asset ??
      entry?.symbol ??
      entry?.sym ??
      entry?.order?.coin ??
      entry?.order?.asset ??
      entry?.order?.symbol ??
      entry?.order?.sym ??
      "";
    return getMarketTypeFromCoin(rawCoin) === marketType;
  }

  function filterEntriesByMarketType(list, marketType = currentMarketType) {
    if (!Array.isArray(list)) return [];
    return list.filter((entry) => entryMatchesMarketType(entry, marketType));
  }

  function combineSnapshotForWallet(wallet) {
    const perp = walletSnapshotsByType.perp.get(wallet) || {};
    const spot = walletSnapshotsByType.spot.get(wallet) || {};
    const perpSummary = perp.summary || null;
    const spotSummary = spot.summary || null;

    if (!perpSummary && !spotSummary) {
      return { summary: null, withdrawable: 0, snapshotUpnlTotal: 0 };
    }

    const combinedSummary = {
      accountValue: Number(perpSummary?.accountValue ?? 0) + Number(spotSummary?.accountValue ?? 0),
      totalNtlPos: Number(perpSummary?.totalNtlPos ?? 0) + Number(spotSummary?.totalNtlPos ?? 0),
      totalRawUsd: Number(perpSummary?.totalRawUsd ?? 0) + Number(spotSummary?.totalRawUsd ?? 0),
      totalMarginUsed: Number(perpSummary?.totalMarginUsed ?? 0) + Number(spotSummary?.totalMarginUsed ?? 0),
    };

    return {
      summary: combinedSummary,
      withdrawable: Number(perp?.withdrawable ?? 0) + Number(spot?.withdrawable ?? 0),
      snapshotUpnlTotal: Number(perp?.snapshotUpnlTotal ?? 0) + Number(spot?.snapshotUpnlTotal ?? 0),
    };
  }

  function getActiveSnapshots() {
    if (currentMarketType !== "all") return walletSnapshotsByType[currentMarketType];
    const combined = new Map();
    currentWallets.forEach((wallet) => {
      combined.set(wallet, combineSnapshotForWallet(wallet));
    });
    return combined;
  }

  function combineTotalsForWallet(wallet) {
    const perp = walletTotalsByType.perp.get(wallet) || { upnlTotal: 0, notionalTotal: 0 };
    const spot = walletTotalsByType.spot.get(wallet) || { upnlTotal: 0, notionalTotal: 0 };
    return {
      upnlTotal: Number(perp.upnlTotal ?? 0) + Number(spot.upnlTotal ?? 0),
      notionalTotal: Number(perp.notionalTotal ?? 0) + Number(spot.notionalTotal ?? 0),
    };
  }

  function getActiveTotals() {
    if (currentMarketType !== "all") return walletTotalsByType[currentMarketType];
    const combined = new Map();
    currentWallets.forEach((wallet) => {
      combined.set(wallet, combineTotalsForWallet(wallet));
    });
    return combined;
  }

  function getActivePositionsMap() {
    return walletPositionsByType[currentMarketType];
  }

  function combinePositionsByType(type) {
    const combined = [];
    const map = walletPositionsByType[type];
    if (!map) return combined;
    map.forEach((vals) => {
      if (Array.isArray(vals) && vals.length) combined.push(...vals);
    });
    return combined;
  }

  function getPositionsForMarketType(type) {
    if (type === "all") {
      return [
        ...combinePositionsByType("perp"),
        ...combinePositionsByType("spot"),
      ];
    }
    return combinePositionsByType(type);
  }

  function updateMarketLabels() {
    const label =
      currentMarketType === "spot"
        ? "Spot"
        : currentMarketType === "all"
          ? "All"
          : "Perps";
    if (accountModeLabelEl) accountModeLabelEl.textContent = label;
    if (positionsModeLabelEl) positionsModeLabelEl.textContent = label;
    if (performanceModeLabelEl) performanceModeLabelEl.textContent = label;
  }

  function updateMarketToggleButtons() {
    marketToggleButtons.forEach((btn) => {
      const isActive = btn.dataset.market === currentMarketType;
      btn.classList.toggle("active", isActive);
      btn.setAttribute("aria-pressed", isActive ? "true" : "false");
    });
    updateMarketToggleIndicator();
  }

  function updateMarketToggleIndicator() {
    if (!marketToggleIndicatorEl) return;
    const active = document.querySelector(".market-tab-btn.active");
    if (!active) return;
    const parent = active.parentElement;
    if (!parent) return;
    const parentRect = parent.getBoundingClientRect();
    const activeRect = active.getBoundingClientRect();
    const left = activeRect.left - parentRect.left;
    marketToggleIndicatorEl.style.width = `${activeRect.width}px`;
    marketToggleIndicatorEl.style.transform = `translateX(${left}px)`;
  }

  function updateRangeToggleIndicator() {
    if (!rangeToggleIndicatorEl) return;
    const active = document.querySelector(".chart-range-btn.active");
    if (!active) return;
    const parent = active.parentElement;
    if (!parent) return;
    const parentRect = parent.getBoundingClientRect();
    const activeRect = active.getBoundingClientRect();
    const left = activeRect.left - parentRect.left;
    rangeToggleIndicatorEl.style.width = `${activeRect.width}px`;
    rangeToggleIndicatorEl.style.transform = `translateX(${left}px)`;
    parent.classList.add("ready");
  }

  function updateTabSwitchIndicator(container) {
    if (!container) return;
    const indicator = container.querySelector(".orders-tabs-indicator");
    const active = container.querySelector(".orders-tab-btn.active");
    if (!indicator || !active) return;
    const parentRect = container.getBoundingClientRect();
    const activeRect = active.getBoundingClientRect();
    const left = activeRect.left - parentRect.left;
    indicator.style.width = `${activeRect.width}px`;
    indicator.style.transform = `translateX(${left}px)`;
    container.classList.add("ready");
  }

  function updatePerformanceVisibility() {
    if (portfolioChartsEl) portfolioChartsEl.classList.remove("is-hidden");
    if (spotPerformanceNoteEl) {
      spotPerformanceNoteEl.classList.toggle("is-hidden", currentMarketType !== "spot");
    }
  }

  function applyMarketFilter() {
    renderPositions(getPositionsForMarketType(currentMarketType));
    renderOpenOrders();
    renderCanceledOrders();
    renderFills();
    if (historicalOrdersLoaded) renderHistoricalOrders();
    if (historicalFillsLoaded) renderHistoricalFills();
    if (portfolioDataByWallet.size) {
      updatePortfolioCharts(currentRangeKey);
    }
    updatePerformanceMetrics(currentRangeKey);
    updatePerformanceVisibility();
  }

  async function setMarketType(nextType) {
    if (!nextType || nextType === currentMarketType) return;
    currentMarketType = nextType;
    updateMarketLabels();
    updateMarketToggleButtons();
    if (currentMarketType === "spot" || currentMarketType === "all") {
      await refreshSpotForWallets(currentWallets);
    }
    applyMarketFilter();
  }

  function coinCellHtml(coin, wallet, forceSpot = false) {
    const c = coin ?? "";
    const { label, iconKey, isSpot } = resolveSpotDisplay(c);
    const spotTagHtml = (forceSpot || isSpot) ? `<span class="dex-tag spot-tag">spot</span>` : "";
    return `<span class="asset-cell">${coinIconHtml(iconKey, label)}<span>${label}</span>${spotTagHtml}${walletTagHtml(wallet)}</span>`;
  }

  function normalizeCoin(coin) {
    return (coin || "").toUpperCase();
  }

  function normalizeFooterCoinValue(value) {
    const cleaned = String(value || "").trim();
    if (!cleaned) return "";
    const { dex, base } = splitDexCoin(cleaned);
    if (dex) return `${dex.toLowerCase()}:${String(base || "").toUpperCase()}`;
    const upper = cleaned.toUpperCase();
    if (upper === "USA500") return "cash:USA500";
    return upper;
  }

  function normalizeLogoKey(value) {
    const cleaned = String(value || "").trim();
    if (!cleaned) return "";
    const { dex, base } = splitDexCoin(cleaned);
    if (dex) return `${dex.toLowerCase()}:${String(base || "").toUpperCase()}`;
    return cleaned.toUpperCase();
  }

  function getFooterBase(coin) {
    const { base } = splitDexCoin(coin);
    return String(base || "").toUpperCase();
  }

  function formatPrefixedCoin(prefix, base) {
    return `${prefix}:${String(base || "").toUpperCase()}`;
  }

  function getPrefixedCandidates(base) {
    return NON_CRYPTO_PREFIXES.map((prefix) => formatPrefixedCoin(prefix, base));
  }

  function isNonCryptoPrefixed(coin) {
    const { dex } = splitDexCoin(coin);
    if (!dex) return false;
    return NON_CRYPTO_PREFIXES.includes(String(dex).toLowerCase());
  }

  function findTrackedFooterCoinByBase(base) {
    const normBase = String(base || "").toUpperCase();
    return trackedFooterCoins.find((coin) => getFooterBase(coin) === normBase) || null;
  }

  function getLivePriceForCoin(raw) {
    const { dex, base } = splitDexCoin(raw);
    const candidates = [raw, base, normalizeCoin(raw), normalizeCoin(base)];
    for (const key of candidates) {
      if (!key) continue;
      const px = liveMids.get(key);
      if (Number.isFinite(px)) return px;
    }
    return undefined;
  }

  function getFooterChangePct(raw) {
    const coin = String(raw || "").toUpperCase();
    const base = getFooterBase(coin);
    const key = footerChangeRefs.has(coin) ? coin : footerChangeRefs.has(base) ? base : null;
    if (!key) {
      if (footerChangePcts.has(coin)) return footerChangePcts.get(coin);
      if (footerChangePcts.has(base)) return footerChangePcts.get(base);
      return null;
    }
    const ref = footerChangeRefs.get(key);
    const prev = Number(ref?.prev);
    if (!Number.isFinite(prev) || prev === 0) return null;
    const live = getLivePriceForCoin(coin);
    const last = Number.isFinite(live) ? live : Number(ref?.last);
    if (!Number.isFinite(last)) return null;
    return (last - prev) / prev;
  }

  async function fetchChangeFromCandles(rawCoin, rangeKey) {
    const coin = String(rawCoin || "").trim();
    const range = FOOTER_CHANGE_RANGES[rangeKey] || FOOTER_CHANGE_RANGES["1d"];
    if (!coin || !range) return null;
    const end = Date.now();
    const start = end - range.ms * 4;
    const res = await fetch(PORTFOLIO_API_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ type: "candleSnapshot", req: { coin, interval: range.interval, startTime: start, endTime: end } }),
    });
    if (!res.ok) throw new Error(`candleSnapshot error: ${res.status} ${res.statusText}`);
    const data = await res.json();
    const candles = (Array.isArray(data) ? data : [])
      .map((c) => ({
        time: Number(c.t),
        open: Number(c.o),
        close: Number(c.c),
      }))
      .filter((c) => Number.isFinite(c.time) && Number.isFinite(c.open) && Number.isFinite(c.close))
      .sort((a, b) => a.time - b.time);
    if (candles.length >= 2) {
      const prev = candles[candles.length - 2].close;
      const last = candles[candles.length - 1].close;
      if (Number.isFinite(prev) && prev !== 0 && Number.isFinite(last)) return { prev, last };
    }
    if (candles.length === 1) {
      const prev = candles[0].open;
      const last = candles[0].close;
      if (Number.isFinite(prev) && prev !== 0 && Number.isFinite(last)) return { prev, last };
    }
    return null;
  }

  async function refreshFooterChanges() {
    try {
      if (!footerChangeEnabled) {
        footerChangePcts.clear();
        renderFooterPrices();
        return;
      }

      const dexes = new Set();
      trackedFooterCoins.forEach((coin) => {
        const { dex } = splitDexCoin(coin);
        if (!dex) return;
        const low = dex.toLowerCase();
        if (NON_CRYPTO_PREFIXES.includes(low)) return;
        dexes.add(dex);
      });

      const fetchCtxs = async (dex = "") => {
        const payload = dex ? { type: "metaAndAssetCtxs", dex } : { type: "metaAndAssetCtxs" };
        const res = await fetch(PORTFOLIO_API_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (!res.ok) throw new Error(`metaAndAssetCtxs error: ${res.status} ${res.statusText}`);
        const data = await res.json();
        return {
          dex,
          universe: Array.isArray(data) ? data?.[0]?.universe : data?.meta?.universe,
          assetCtxs: Array.isArray(data) ? data[1] : data?.assetCtxs,
        };
      };

      footerChangePcts.clear();
      footerChangeRefs.clear();

      if (footerChangeRange === "1d") {
        const results = await Promise.allSettled([fetchCtxs(), ...Array.from(dexes).map((d) => fetchCtxs(d))]);
        results.forEach((res) => {
          if (res.status !== "fulfilled") return;
          const { dex, universe, assetCtxs } = res.value || {};
          if (!Array.isArray(assetCtxs)) return;
          assetCtxs.forEach((ctx, idx) => {
            if (!ctx || typeof ctx !== "object") return;
            const fallbackName = Array.isArray(universe) ? universe[idx]?.name : "";
            const coinRaw = String(ctx.coin ?? ctx.symbol ?? ctx.asset ?? fallbackName ?? "");
            const coin = coinRaw.toUpperCase();
            if (!coin) return;
            const mark = Number(ctx.markPx ?? ctx.mark ?? ctx.midPx ?? ctx.mid ?? ctx.px);
            const prev = Number(ctx.prevDayPx ?? ctx.prevDay ?? ctx.prevPx ?? ctx.openPx);
            if (!Number.isFinite(mark) || !Number.isFinite(prev) || prev === 0) return;
            footerChangeRefs.set(coin, { prev, last: mark });
            if (dex) {
              const key = `${String(dex).toUpperCase()}:${coin}`;
              footerChangeRefs.set(key, { prev, last: mark });
            }
          });
        });
      }

      const missing = trackedFooterCoins
        .map((c) => normalizeFooterCoinValue(c))
        .filter(Boolean)
        .filter((coin) => !Number.isFinite(getFooterChangePct(coin)));

      await Promise.allSettled(
        missing.map(async (coin) => {
          try {
            let change = await fetchChangeFromCandles(coin, footerChangeRange);
            if ((!change || !Number.isFinite(change.prev)) && coin.includes(":")) {
              const base = getFooterBase(coin);
              if (base) change = await fetchChangeFromCandles(base, footerChangeRange);
            }
            if (!change || !Number.isFinite(change.prev)) return;
            const upper = String(coin).toUpperCase();
            footerChangeRefs.set(upper, change);
            const base = getFooterBase(coin);
            if (base) footerChangeRefs.set(base, change);
          } catch (err) {
            console.warn("Footer candle fallback failed", coin, err);
          }
        })
      );

      renderFooterPrices();
    } catch (err) {
      console.warn("Footer 24h change fetch failed", err);
    }
  }

  function ensureFooterChangeTimer() {
    if (footerChangeTimer) return;
    footerChangeTimer = setInterval(refreshFooterChanges, 60000);
  }

  function applyFooterChangeVisibility() {
    if (!priceFooterWrapEl) return;
    priceFooterWrapEl.classList.toggle("hide-change", !footerChangeEnabled);
  }

  function updateFooterChangeMenu() {
    if (!priceContextMenuEl) return;
    const toggleBtn = priceContextMenuEl.querySelector('[data-action="toggle-change"]');
    if (toggleBtn) {
      toggleBtn.textContent = `Show % change: ${footerChangeEnabled ? "On" : "Off"}`;
    }
    priceContextMenuEl.classList.toggle("hide-change-options", !footerChangeEnabled);
    priceContextMenuEl.querySelectorAll('[data-action="change-range"]').forEach((btn) => {
      const range = btn.getAttribute("data-range");
      const label = FOOTER_CHANGE_RANGES[range]?.label || btn.textContent.trim();
      btn.textContent = `${footerChangeRange === range ? "âœ“ " : ""}${label}`;
    });
  }

  function ensureManualMidTimer() {
    if (manualMidTimer || manualMidCoins.size === 0) return;
    manualMidTimer = setInterval(() => {
      refreshManualMids();
    }, 12000);
  }

  function stopManualMidTimerIfIdle() {
    if (!manualMidTimer) return;
    if (manualMidCoins.size > 0) return;
    clearInterval(manualMidTimer);
    manualMidTimer = null;
  }

  async function fetchL2BookMid(coin) {
    try {
      const res = await fetch(PORTFOLIO_API_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ type: "l2Book", coin }),
      });
      if (!res.ok) return null;
      const data = await res.json();
      const levels = data?.levels;
      if (!Array.isArray(levels) || levels.length < 2) return null;
      const getPx = (entry) => {
        if (!entry) return null;
        if (typeof entry.px !== "undefined") return Number(entry.px);
        if (Array.isArray(entry)) return Number(entry[0]);
        return null;
      };
      const bestBid = getPx(levels[0]?.[0]);
      const bestAsk = getPx(levels[1]?.[0]);
      if (!Number.isFinite(bestBid) || !Number.isFinite(bestAsk)) return null;
      return (bestBid + bestAsk) / 2;
    } catch (e) {
      return null;
    }
  }

  async function refreshManualMids() {
    const coins = Array.from(manualMidCoins);
    if (!coins.length) {
      stopManualMidTimerIfIdle();
      return;
    }
    const updates = await Promise.all(coins.map((coin) => fetchL2BookMid(coin)));
    updates.forEach((mid, idx) => {
      const coin = coins[idx];
      if (!Number.isFinite(mid)) return;
      liveMids.set(coin, mid);
    });
    renderFooterPrices();
    if (currentAssetPositions.length) renderPositions(currentAssetPositions);
  }

  async function primeManualMidsForFooter() {
    const manualCoins = trackedFooterCoins.filter((coin) => coin.includes(":"));
    if (!manualCoins.length) return;
    manualCoins.forEach((coin) => manualMidCoins.add(coin));
    ensureManualMidTimer();
    await refreshManualMids();
  }

  async function sanitizeFooterCoins() {
    const next = [];
    const seenBases = new Set();
    for (const raw of trackedFooterCoins) {
      const normalized = normalizeFooterCoinValue(raw);
      const base = getFooterBase(normalized);
      if (!base || seenBases.has(base)) continue;
      if (normalized.includes(":") || HYPERLIQUID_TICKERS.has(base)) {
        next.push(normalized);
        seenBases.add(base);
        continue;
      }
      // eslint-disable-next-line no-await-in-loop
      const baseResult = await evaluateFooterCandidate(base);
      if (baseResult) {
        next.push(baseResult.coinKey);
        seenBases.add(base);
        continue;
      }
      let added = false;
      for (const prefixed of getPrefixedCandidates(base)) {
        // eslint-disable-next-line no-await-in-loop
        const prefixedResult = await evaluateFooterCandidate(prefixed);
        if (prefixedResult) {
          next.push(prefixedResult.coinKey);
          seenBases.add(base);
          added = true;
          break;
        }
      }
      if (!added) {
        // Drop coins that have no logo and no price data.
      }
    }
    trackedFooterCoins = next;
    saveFooterCoins();
  }

  function rememberLogoOk(rawKey, okUrl) {
    const normalized = normalizeLogoKey(rawKey);
    const entry = ensureLogoCache(normalized, rawKey, rawKey);
    entry.state = "ok";
    entry.idx = 0;
    entry.okUrl = okUrl;
    entry.urls = [okUrl];
  }

  function checkLogoUrl(url) {
    return new Promise((resolve) => {
      const img = new Image();
      let done = false;
      const finish = (ok) => {
        if (done) return;
        done = true;
        resolve(ok);
      };
      const timer = setTimeout(() => finish(false), 3000);
      img.onload = () => {
        clearTimeout(timer);
        finish(true);
      };
      img.onerror = () => {
        clearTimeout(timer);
        finish(false);
      };
      img.referrerPolicy = "no-referrer";
      img.src = url;
    });
  }

  async function findAvailableLogoUrl(rawName) {
    const candidates = getIconCandidates(rawName, rawName);
    for (const url of candidates) {
      // eslint-disable-next-line no-await-in-loop
      const ok = await checkLogoUrl(url);
      if (ok) return url;
    }
    return null;
  }

  async function evaluateFooterCandidate(coinKey) {
    const existing = getLivePriceForCoin(coinKey);
    let mid = Number.isFinite(existing) ? existing : null;
    let logoUrl = null;
    if (Number.isFinite(existing) && coinKey.includes(":")) {
      manualMidCoins.add(coinKey);
      ensureManualMidTimer();
    }
    if (!Number.isFinite(existing)) {
      logoUrl = await findAvailableLogoUrl(coinKey);
      if (logoUrl) rememberLogoOk(coinKey, logoUrl);
      mid = await fetchL2BookMid(coinKey);
      if (Number.isFinite(mid)) {
        liveMids.set(coinKey, mid);
        manualMidCoins.add(coinKey);
        ensureManualMidTimer();
      }
    }
    if (!logoUrl && Number.isFinite(existing)) {
      return { coinKey, hasLogo: false, hasPrice: true };
    }
    if (logoUrl || Number.isFinite(mid)) {
      return { coinKey, hasLogo: Boolean(logoUrl), hasPrice: Number.isFinite(mid) || Number.isFinite(existing) };
    }
    return null;
  }

  async function extractDominantColorFromLogo(symbol) {
    if (window.location?.protocol === "file:") return null;
    const normalized = normalizeFooterCoinValue(symbol);
    if (!normalized) return null;
    const { base } = splitDexCoin(normalized);
    const local = String(base || normalized).replace("/", "_");
    if (local === "USA500" || local === "COPPER") return null;
    const iconUrl = `images/coins/${encodeURIComponent(local)}.svg`;
    if (!isSameOriginAsset(iconUrl)) return null;
    try {
      const res = await fetch(iconUrl);
      if (!res.ok) return null;
      const svgText = await res.text();
      const matches = svgText.match(/#[0-9a-fA-F]{3,6}/g) || [];
      if (!matches.length) return null;

      const counts = new Map();
      const normalizeHex = (hex) => {
        const h = hex.replace("#", "");
        if (h.length === 3) return `#${h[0]}${h[0]}${h[1]}${h[1]}${h[2]}${h[2]}`.toLowerCase();
        return `#${h.padEnd(6, "0").slice(0, 6)}`.toLowerCase();
      };
      const brightness = (hex) => {
        const h = normalizeHex(hex).slice(1);
        const r = parseInt(h.slice(0, 2), 16);
        const g = parseInt(h.slice(2, 4), 16);
        const b = parseInt(h.slice(4, 6), 16);
        return (r * 299 + g * 587 + b * 114) / 1000;
      };

      matches.forEach((hex) => {
        const norm = normalizeHex(hex);
        const b = brightness(norm);
        if (b > 240 || b < 20) return;
        counts.set(norm, (counts.get(norm) || 0) + 1);
      });

      let best = null;
      let bestCount = 0;
      counts.forEach((count, color) => {
        if (count > bestCount) {
          best = color;
          bestCount = count;
        }
      });
      return best;
    } catch (e) {
      return null;
    }
  }

  function renderFooterPrices() {
    if (!priceFooterEl) return;
    if (!priceListEl || !priceListCloneEl) return;
    const coinColors = {
      "0G": "#b75fff",
      "2Z": "#747474",
      "AAVE": "#b6509e",
      "ACE": "#aabbcc",
      "ADA": "#0033ad",
      "AERO": "#ebe8e1",
      "AI": "#f45b5b",
      "AI16Z": "#7c625f",
      "AIXBT": "#ac77f0",
      "ALGO": "#e5e7eb",
      "ALT": "#8f96e8",
      "ANIME": "#fdd274",
      "APE": "#89d0ff",
      "APEX": "#fed702",
      "APT": "#e5e7eb",
      "AR": "#222326",
      "ARB": "#213147",
      "ARK": "#f70000",
      "ASTER": "#f4d4af",
      "ATOM": "#b7b9c8",
      "AVAX": "#e84142",
      "AVNT": "#7e11fd",
      "AXS": "#303030",
      "BABY": "#7c8f86",
      "BADGER": "#c1c1c3",
      "BANANA": "#efcf8c",
      "BCH": "#0ac18e",
      "BERA": "#814625",
      "BIGTIME": "#e5e7eb",
      "BIO": "#324224",
      "BLAST": "#fcfc03",
      "BLUR": "#650901",
      "BLZ": "#ff00ff",
      "BNB": "#f0b90b",
      "BNT": "#e5e7eb",
      "BOME": "#50832b",
      "BRETT": "#007c9e",
      "BSV": "#eab300",
      "BTC": "#f7931a",
      "CAKE": "#633001",
      "CANTO": "#303030",
      "CATI": "#d4a44b",
      "CC": "#f3ff97",
      "CELO": "#fcff52",
      "CFX": "#181818",
      "CHILLGUY": "#435136",
      "COMP": "#00d395",
      "CRV": "#80ff77",
      "CYBER": "#e5e7eb",
      "DASH": "#303030",
      "DOGE": "#cfb66c",
      "DOOD": "#8c8c8c",
      "DOT": "#e6007a",
      "DYDX": "#6966ff",
      "DYM": "#24201f",
      "EIGEN": "#1a0c6d",
      "ENA": "#3a3a3a",
      "ENS": "#a0a8d4",
      "ETC": "#3ab83a",
      "ETH": "#8c8c8c",
      "ETHFI": "#29bcfa",
      "FARTCOIN": "#9b9b9b",
      "FET": "#202944",
      "FIL": "#0090ff",
      "FOGO": "#303030",
      "FRIEND": "#a3effd",
      "FTM": "#1969ff",
      "FTT": "#02a6c2",
      "FXS": "#e5e7eb",
      "GALA": "#e5e7eb",
      "GAS": "#01e397",
      "GMT": "#776942",
      "GMX": "#03d1cf",
      "GOAT": "#86958c",
      "GRASS": "#acf601",
      "GRIFFAIN": "#9ffa9f",
      "HBAR": "#e5e7eb",
      "HEMI": "#ff6a00",
      "HMSTR": "#fea404",
      "HPOS": "#bc1e2d",
      "HYPE": "#97fce4",
      "HYPER": "#dc6cc9",
      "ICP": "#d74d59",
      "ILV": "#500586",
      "IMX": "#e5e7eb",
      "INIT": "#898989",
      "INJ": "#4d3dff",
      "IO": "#e5e7eb",
      "IOTA": "#e5e7eb",
      "IP": "#ffe8ae",
      "JELLY": "#514f4f",
      "JTO": "#807f80",
      "JUP": "#c7f284",
      "KAITO": "#32ffdc",
      "KAS": "#49eacb",
      "LAUNCHCOIN": "#5ecc57",
      "LAYER": "#2b6558",
      "LDO": "#f89791",
      "LINEA": "#61dfff",
      "LINK": "#2a5ada",
      "LISTA": "#201a8a",
      "LIT": "#e5e7eb",
      "LOOM": "#4bc0c8",
      "LTC": "#345d9d",
      "MANTA": "#29ccb9",
      "MATIC": "#8247e5",
      "MAV": "#780eff",
      "MAVIA": "#1c54c2",
      "ME": "#f30676",
      "MEGA": "#19191a",
      "MELANIA": "#939393",
      "MEME": "#451834",
      "MERL": "#2a2cbf",
      "MET": "#f5bd00",
      "MEW": "#ec1c24",
      "MINA": "#2d2d2d",
      "MKR": "#4fa89b",
      "MNT": "#2ec1a1",
      "MON": "#836ef9",
      "MOODENG": "#1f5926",
      "MORPHO": "#2470ff",
      "MOVE": "#f1bb15",
      "MYRO": "#303030",
      "NEAR": "#e5e7eb",
      "NEIROETH": "#b99f32",
      "NEO": "#00e599",
      "NFTI": "#29796e",
      "NIL": "#e5e7eb",
      "NOT": "#e5e7eb",
      "NTRN": "#e5e7eb",
      "NXPC": "#47f0c9",
      "OGN": "#0074f0",
      "OM": "#373535",
      "OMNI": "#0564ff",
      "ONDO": "#e5e7eb",
      "OP": "#ff0420",
      "ORBS": "#556195",
      "ORDI": "#e5e7eb",
      "OX": "#ffb7a5",
      "PANDORA": "#9a9a9a",
      "PAXG": "#ede70a",
      "PENDLE": "#dedede",
      "PENGU": "#575b5f",
      "PEOPLE": "#303030",
      "PIXEL": "#69bd00",
      "PNUT": "#e1d2c8",
      "POL": "#8247e5",
      "POLYX": "#ff2e72",
      "POPCAT": "#a49793",
      "PROMPT": "#121b13",
      "PROVE": "#fe11c5",
      "PUMP": "#e8f2f1",
      "PURR": "#88d4ee",
      "PYTH": "#e5e7eb",
      "RDNT": "#00ffaa",
      "RENDER": "#cf1011",
      "REQ": "#008c62",
      "RESOLV": "#ffedd7",
      "REZ": "#c4ff61",
      "RLB": "#fea101",
      "RNDR": "#cf1011",
      "RSR": "#e5e7eb",
      "RUNE": "#00ccff",
      "S": "#e5e7eb",
      "SAGA": "#e5e7eb",
      "SAND": "#00adef",
      "SCR": "#ebc28e",
      "SEI": "#9d1f19",
      "SHIA": "#361d0c",
      "SKY": "#a273ff",
      "SNX": "#00d1ff",
      "SOL": "#00ffa3",
      "SOPH": "#e5e7eb",
      "SPX": "#d5a141",
      "STABLE": "#e5e7eb",
      "STBL": "#bb93e9",
      "STG": "#a6a6a6",
      "STRAX": "#21bbc0",
      "STRK": "#ec796b",
      "STX": "#5546ff",
      "SUI": "#4ca3ff",
      "SUPER": "#00eaea",
      "SUSHI": "#03b8ff",
      "SYRUP": "#fc784a",
      "TAO": "#e5e7eb",
      "TIA": "#7b2bf9",
      "TNSR": "#404040",
      "TON": "#0098ea",
      "TRB": "#00ff8f",
      "TRUMP": "#9a9a9a",
      "TRX": "#ec0927",
      "TST": "#eeb207",
      "TURBO": "#cfab7f",
      "UMA": "#ff4a4a",
      "UNI": "#ff007a",
      "UNIBOT": "#a13987",
      "USTC": "#093dac",
      "USUAL": "#e5e7eb",
      "VINE": "#01bf8f",
      "VIRTUAL": "#44bcc3",
      "VVV": "#042d48",
      "W": "#7168be",
      "WCT": "#0c88f0",
      "WIF": "#e5e7eb",
      "WLD": "#e5e7eb",
      "WLFI": "#eaac08",
      "XAI": "#f30019",
      "XLM": "#e5e7eb",
      "XMR": "#f26822",
      "XPL": "#e5e7eb",
      "XRP": "#23292f",
      "YGG": "#1d1f22",
      "YZY": "#303030",
      "ZEC": "#cf8724",
      "ZEN": "#0e9de5",
      "ZEREBRO": "#1b1b19",
      "ZETA": "#005741",
      "ZK": "#e5e7eb",
      "ZORA": "#7f8ee9",
      "ZRO": "#575757",
      "KBONK": "#303030",
      "KDOGS": "#303030",
      "KFLOKI": "#303030",
      "KLUNC": "#303030",
      "KNEIRO": "#303030",
      "KPEPE": "#303030",
      "KSHIB": "#303030",
    };

    const existing = new Map(
      Array.from(priceListEl.querySelectorAll(".price-item")).map((el) => [el.dataset.coin, el])
    );
    const desired = trackedFooterCoins.map((c) => normalizeFooterCoinValue(c)).filter(Boolean);

    existing.forEach((el, coin) => {
      if (!desired.includes(coin)) el.remove();
    });

    desired.forEach((coin) => {
      let item = existing.get(coin);
      if (!item) {
        item = document.createElement("span");
        item.className = "price-item";
        item.dataset.coin = coin;
        item.setAttribute("draggable", "true");
        item.innerHTML = `
          ${coinIconHtml(coin, coin)}
          <span class="coin-price">--</span>
          <span class="coin-change">(--%)</span>
        `;
        priceListEl.appendChild(item);
      } else {
        priceListEl.appendChild(item);
      }
    });

    desired.forEach((coin) => {
      const item = priceListEl.querySelector(`.price-item[data-coin="${coin}"]`);
      if (!item) return;
      const priceEl = item.querySelector(".coin-price");
      const changeEl = item.querySelector(".coin-change");
      const price = getLivePriceForCoin(coin);
      const base = getFooterBase(coin);
      const isLightTheme = document.body.classList.contains("light");
      let color =
        coinColors[coin] ||
        coinColors[base] ||
        coinColorCache.get(coin) ||
        coinColorCache.get(base) ||
        "#e5e7eb";
      if (isNonCryptoPrefixed(coin)) {
        color = isLightTheme ? "#0f172a" : "#e5e7eb";
      } else if (isLightTheme && isColorTooLight(color)) {
        color = "#0f172a";
      }
      if (priceEl) {
        if (Number.isFinite(price)) {
          let decimals = coinPriceDecimals.get(coin);
          if (decimals === undefined) {
            const abs = Math.abs(price);
            if (abs >= 10000) decimals = 0;
            else if (abs >= 1000) decimals = 1;
            else if (abs >= 100) decimals = 2;
            else if (abs >= 10) decimals = 3;
            else if (abs >= 1) decimals = 4;
            else if (abs >= 0.1) decimals = 5;
            else if (abs >= 0.01) decimals = 6;
            else decimals = 8;
            coinPriceDecimals.set(coin, decimals);
          }
          const formatted = fmtPriceFixed(price, decimals);
          priceEl.textContent = formatted;
          lastFooterPrices.set(coin, formatted);
        } else {
          priceEl.textContent = lastFooterPrices.get(coin) || "--";
        }
        priceEl.style.color = color;
      }

      if (changeEl) {
        if (!footerChangeEnabled) {
          changeEl.textContent = "";
          changeEl.classList.remove("upnl-pos", "upnl-neg");
          return;
        }
        const changePct = getFooterChangePct(coin);
        if (Number.isFinite(changePct)) {
          changeEl.textContent = `(${formatSignedPercent(changePct, 2)})`;
          changeEl.classList.toggle("upnl-pos", changePct > 0);
          changeEl.classList.toggle("upnl-neg", changePct < 0);
        } else {
          changeEl.textContent = "(--%)";
          changeEl.classList.remove("upnl-pos", "upnl-neg");
        }
      }
    });

    priceListCloneEl.innerHTML = priceListEl.innerHTML;
    priceListCloneEl.querySelectorAll(".price-item").forEach((item) => {
      item.removeAttribute("draggable");
    });

    requestAnimationFrame(updatePriceTickerRolling);

    desired.forEach(async (coin) => {
      if (coinColors[coin] || coinColorCache.has(coin) || coinColorPending.has(coin)) return;
      coinColorPending.add(coin);
      const color = await extractDominantColorFromLogo(coin);
      coinColorPending.delete(coin);
      if (!color) return;
      const isLightTheme = document.body.classList.contains("light");
      const displayColor = isLightTheme && isColorTooLight(color) ? "#0f172a" : color;
      coinColorCache.set(normalizeFooterCoinValue(coin), color);
      saveCoinColorCache();
      const item = priceListEl.querySelector(`.price-item[data-coin="${coin}"] .coin-price`);
      if (item) item.style.color = displayColor;
      const cloneItem = priceListCloneEl.querySelector(`.price-item[data-coin="${coin}"] .coin-price`);
      if (cloneItem) cloneItem.style.color = displayColor;
    });
  }

  function updatePriceTickerRolling() {
    if (!priceFooterWrapEl || !priceListEl || !priceTickerEl) return;
    const items = priceListEl.querySelectorAll(".price-item");
    if (!items.length) {
      priceFooterWrapEl.classList.remove("rolling");
      return;
    }
    const tops = new Set(Array.from(items).map((el) => el.offsetTop));
    const isWrapped = tops.size > 1;
    const isOverflow = priceListEl.scrollWidth > priceTickerEl.clientWidth + 4;
    const forceRoll = items.length >= 12;
    priceFooterWrapEl.classList.toggle("rolling", forceRoll || isWrapped || isOverflow);
  }

  async function resolveCoinSymbol(input) {
    const cleaned = String(input || "").trim();
    if (!cleaned) return null;
    if (cleaned.includes(":")) return normalizeFooterCoinValue(cleaned);
    const lookup = cleaned.toLowerCase();
    if (coinNameCache.has(lookup)) return coinNameCache.get(lookup);

    const simple = lookup.replace(/[^a-z0-9]/g, "");
    if (simple && simple === lookup && simple.length <= 6) {
      return simple.toUpperCase();
    }

    try {
      const res = await fetch(`https://api.coingecko.com/api/v3/search?query=${encodeURIComponent(cleaned)}`);
      if (!res.ok) throw new Error("search failed");
      const data = await res.json();
      const first = data?.coins?.[0];
      const symbol = first?.symbol ? String(first.symbol).toUpperCase() : null;
      if (symbol) {
        coinNameCache.set(lookup, symbol);
        const name = first?.name ? String(first.name).toLowerCase() : "";
        if (name) coinNameCache.set(name, symbol);
        saveCoinNameCache();
        return symbol;
      }
    } catch (e) {}

    return cleaned.toUpperCase();
  }

  function getInputCandidateSymbol(input) {
    const cleaned = String(input || "").trim();
    if (!cleaned) return null;
    if (cleaned.includes(":")) return normalizeFooterCoinValue(cleaned);
    const lookup = cleaned.toLowerCase();
    if (coinNameCache.has(lookup)) return coinNameCache.get(lookup);
    const simple = lookup.replace(/[^a-z0-9]/g, "");
    if (simple && simple === lookup && simple.length <= 6) return simple.toUpperCase();
    return cleaned.toUpperCase();
  }

  function updateFooterActionLabel() {
    if (!priceAddBtnEl || !priceAddInputEl) return;
    const candidate = getInputCandidateSymbol(priceAddInputEl.value);
    if (candidate && findTrackedFooterCoinByBase(getFooterBase(candidate))) {
      priceAddBtnEl.textContent = "Remove";
    } else {
      priceAddBtnEl.textContent = "Add";
    }
  }

  let priceContextCoin = null;

  function hidePriceContextMenu() {
    if (!priceContextMenuEl) return;
    priceContextMenuEl.classList.remove("show");
    priceContextMenuEl.setAttribute("aria-hidden", "true");
    priceContextMenuEl.setAttribute("data-has-coin", "false");
    priceContextCoin = null;
  }

  function showPriceContextMenu(x, y, coin) {
    if (!priceContextMenuEl) return;
    priceContextCoin = coin || null;
    priceContextMenuEl.classList.add("show");
    priceContextMenuEl.setAttribute("aria-hidden", "false");
    priceContextMenuEl.setAttribute("data-has-coin", coin ? "true" : "false");
    updateFooterChangeMenu();
    const rect = priceContextMenuEl.getBoundingClientRect();
    const padding = 8;
    const left = Math.min(x, window.innerWidth - rect.width - padding);
    const top = Math.min(y, window.innerHeight - rect.height - padding);
    priceContextMenuEl.style.left = `${Math.max(padding, left)}px`;
    priceContextMenuEl.style.top = `${Math.max(padding, top)}px`;
  }

  async function addFooterCoin(raw) {
    const symbol = await resolveCoinSymbol(raw);
    if (!symbol) return;
    const normalized = normalizeFooterCoinValue(symbol);
    const base = getFooterBase(normalized);
    if (!base) return;
    if (findTrackedFooterCoinByBase(base)) return;

    const baseResult = await evaluateFooterCandidate(base);
    if (baseResult) {
      trackedFooterCoins.push(baseResult.coinKey);
      saveFooterCoins();
      renderFooterPrices();
      return;
    }

    for (const prefixed of getPrefixedCandidates(base)) {
      // eslint-disable-next-line no-await-in-loop
      const prefixedResult = await evaluateFooterCandidate(prefixed);
      if (prefixedResult) {
        trackedFooterCoins.push(prefixedResult.coinKey);
        saveFooterCoins();
        renderFooterPrices();
        return;
      }
    }
  }

  function removeFooterCoin(symbol) {
    trackedFooterCoins = trackedFooterCoins.filter((c) => c !== symbol);
    manualMidCoins.delete(symbol);
    liveMids.delete(symbol);
    coinPriceDecimals.delete(symbol);
    stopManualMidTimerIfIdle();
    saveFooterCoins();
    renderFooterPrices();
  }

  async function toggleFooterCoin(raw) {
    const symbol = await resolveCoinSymbol(raw);
    if (!symbol) return;
    const normalized = normalizeFooterCoinValue(symbol);
    const base = getFooterBase(normalized);
    if (!base) return;
    const existing = findTrackedFooterCoinByBase(base);
    if (existing) {
      removeFooterCoin(existing);
    } else {
      addFooterCoin(normalized);
    }
  }

  function getMarkPriceForCoin(coin) {
    const norm = normalizeCoin(coin);
    const { base } = splitDexCoin(coin);
    const baseNorm = normalizeCoin(base);
    if (!norm) return null;

    const livePx =
      liveMids.get(norm) ??
      liveMids.get(coin) ??
      liveMids.get(base) ??
      liveMids.get(baseNorm);
    if (Number.isFinite(livePx)) return livePx;

    const position = currentAssetPositions.find((item) => {
      const c = item?.position?.coin;
      return normalizeCoin(c) === norm || normalizeCoin(splitDexCoin(c).base) === baseNorm;
    });
    if (!position) return null;

    const p = position.position;
    const szi = Number(p.szi ?? 0);
    const snapshotValue = Number(p.positionValue ?? 0);
    if (Number.isFinite(snapshotValue) && szi) return Math.abs(snapshotValue) / Math.abs(szi);

    const entryPx = Number(p.entryPx ?? 0);
    return Number.isFinite(entryPx) ? entryPx : null;
  }

  function getAllFillsForCoin(coin, wallet, marketType = currentMarketType) {
    const norm = normalizeCoin(coin);
    if (!norm) return [];
    const combined = [];
    const pushFrom = (arr) => {
      arr.forEach((f) => {
        if (marketType && !entryMatchesMarketType(f, marketType)) return;
        if (wallet) {
          const fWallet = String(f?.wallet || "");
          if (!fWallet || fWallet.toLowerCase() !== wallet.toLowerCase()) return;
        }
        const resolved = resolveCoinName(f?.coin ?? f?.asset ?? "", f?.asset ?? f?.symbol ?? f?.sym);
        if (resolved) f.coin = resolved;
        const c = normalizeCoin(resolved);
        if (c === norm) combined.push(f);
      });
    };
    pushFrom(historicalFills);
    pushFrom(fills);

    // Deduplicate by composite key
    const seen = new Set();
    const unique = [];
    combined.forEach((f) => {
      const key = [
        normalizeCoin(f?.coin ?? f?.asset ?? ""),
        f?.oid ?? "",
        f?.time ?? f?.timestamp ?? "",
        f?.side ?? (f?.isBuy ? "B" : "S"),
        f?.sz ?? f?.size ?? "",
        f?.px ?? f?.price ?? "",
      ].join("|");
      if (seen.has(key)) return;
      seen.add(key);
      unique.push(f);
    });

    return unique.sort((a, b) => Number(a.time ?? a.timestamp ?? 0) - Number(b.time ?? b.timestamp ?? 0));
  }

  function buildPositionFillDetails(coin, szi, markPx, wallet) {
    const fillsForCoin = getAllFillsForCoin(coin, wallet, currentMarketType);
    const rows = [];
    let netSize = 0;
    let totalUpnl = 0;

    const target = Number(szi) || 0;
    const EPS = 1e-8;

    // Start from most recent fill and walk back until we cover the current exposure
    const sorted = [...fillsForCoin].sort(
      (a, b) => Number(b.time ?? b.timestamp ?? 0) - Number(a.time ?? a.timestamp ?? 0)
    );

    for (const fill of sorted) {
      const sideRaw =
        fill.side ??
        (fill.isBuy !== undefined ? (fill.isBuy ? "B" : "S") : undefined) ??
        fill.dir ??
        fill.direction ??
        "?";
      const sideUpper = String(sideRaw).toUpperCase();
      let side = "?";
      if (sideUpper.startsWith("B") || sideUpper === "1" || sideUpper === "+1") side = "B";
      else if (
        sideUpper.startsWith("S") ||
        sideUpper.startsWith("A") ||
        sideUpper === "-1" ||
        sideUpper === "SELL" ||
        sideUpper === "SHORT"
      )
        side = "S";

      const sizeCandidates = [fill.szi, fill.sz, fill.size, fill.qty, fill.quantity, fill.baseSz, fill.baseSize];
      let sizeRaw = 0;
      for (const cand of sizeCandidates) {
        const n = Number(cand);
        if (!Number.isNaN(n)) {
          sizeRaw = n;
          break;
        }
      }

      // If side is unknown, infer from sign of size
      if (side === "?") {
        if (sizeRaw > 0) side = "B";
        else if (sizeRaw < 0) side = "S";
      }

      const px = Number(fill.px ?? fill.price ?? 0);
      const signed = side === "B" ? Math.abs(sizeRaw) : side === "S" ? -Math.abs(sizeRaw) : sizeRaw;

      netSize += Number.isFinite(signed) ? signed : 0;

      const valueSigned = Number.isFinite(px) && Number.isFinite(signed) ? signed * px : null;
      const upnl = Number.isFinite(markPx) && Number.isFinite(px) && Number.isFinite(signed)
        ? (markPx - px) * signed
        : null;
      if (Number.isFinite(upnl)) totalUpnl += upnl;

      rows.push({
        time: fmtDateTime(fill.time ?? fill.timestamp),
        sideCode: side,
        side: side === "B" ? "LONG" : side === "S" ? "SHORT" : sideLabel(side),
        size: fmtSize(Math.abs(signed)),
        sizeSigned: fmtSignedSize(signed),
        price: fmtPrice(px),
        value: Number.isFinite(valueSigned) ? formatSignedDollar(valueSigned) : "",
        upnl: Number.isFinite(upnl) ? formatSignedDollarWithPlus(upnl) : "",
        upnlRaw: Number.isFinite(upnl) ? upnl : null,
      });

      if (Math.abs(netSize - target) <= EPS) break;
    }

    const matches = Math.abs(netSize - target) <= EPS;

    return {
      rows,
      netSize,
      matches,
      totalUpnl,
    };
  }

  function getTotalPositionsValue() {
    const totals = getActiveTotals();
    return Array.from(totals.values()).reduce((sum, t) => {
      const val = Number(t?.notionalTotal ?? 0);
      return sum + (Number.isFinite(val) ? val : 0);
    }, 0);
  }

  function getWithdrawableAmount() {
    const snapshots = getActiveSnapshots();
    return Array.from(snapshots.values()).reduce((sum, snap) => {
      const w = Number(snap?.withdrawable ?? 0);
      return sum + (Number.isFinite(w) ? w : 0);
    }, 0);
  }

  function computeTotal(order) {
    const sz = Number(order.sz ?? order.szi ?? 0);
    const pxStr = order.px ?? order.limitPx;
    const px = Number(pxStr ?? 0);
    if (Number.isNaN(sz) || Number.isNaN(px)) return "";
    return (sz * px).toLocaleString(undefined, {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    });
  }

  function sideLabel(side) { return side === "B" ? "LONG" : "SHORT"; }
  function sidePillClass(side) { return side === "B" ? "pill-buy" : "pill-sell"; }

  function buildPositionsRowsForExport() {
    if (!Array.isArray(currentAssetPositions) || currentAssetPositions.length === 0) return [];

    return currentAssetPositions.map((item) => {
      const p = item.position || {};
      const wallet = item.wallet || primaryWallet;
      const coin = p.coin ?? "";
      const szi = Number(p.szi ?? 0);
      const dir = szi > 0 ? "LONG" : szi < 0 ? "SHORT" : "FLAT";
      const entryPx = Number(p.entryPx ?? 0);

      const livePx = liveMids.get(coin);
      let markPx = Number.isFinite(livePx) ? livePx : undefined;

        const snapshotValue = Number(p.positionValue ?? 0);
        if ((markPx === undefined || Number.isNaN(markPx)) && szi !== 0 && !Number.isNaN(snapshotValue)) {
          markPx = Math.abs(snapshotValue) / Math.abs(szi);
        }

      let positionValue = snapshotValue;
      if (markPx !== undefined && !Number.isNaN(markPx) && szi !== 0) {
        positionValue = markPx * szi;
      } else if (Number.isFinite(entryPx) && szi !== 0) {
        positionValue = entryPx * szi;
      }

      let upnl = Number(p.unrealizedPnl ?? 0);
      if (markPx !== undefined && !Number.isNaN(markPx) && !Number.isNaN(entryPx) && szi !== 0) {
        upnl = (markPx - entryPx) * szi;
      }

      return [
        wallet,
        coin,
        dir,
        fmtSize(szi),
        fmtPrice(entryPx),
        fmtMoney(positionValue),
        formatSignedDollar(upnl),
      ];
    });
  }

  function renderMarginSummary(items) {
    if (!Array.isArray(items) || items.length === 0) {
      marginSummaryEl.innerHTML = "<span class='muted'>No margin summary.</span>";
      return;
    }

    const weights = getNormalizedWeights(items.map((item) => item.wallet));

    marginSummaryEl.innerHTML = `
      <div class="overview-stack">
        ${items
          .map((item, idx) => {
            if (!item?.summary) {
              return `
                <div class="overview-item">
                  <div class="overview-wallet" title="${xmlEscape(item.wallet || "")}">
                    ${xmlEscape(formatWalletLabel(item.wallet || ""))}
                    <span>${Math.round((weights[idx] || 0) * 100)}%</span>
                  </div>
                  <div class="muted">No margin summary.</div>
                </div>
              `;
            }

            const rows = [
              ["Equity", fmtMoney(item.summary.accountValue)],
              ["Notional Exposure", fmtMoney(item.summary.totalNtlPos)],
              ["Collateral", fmtMoney(item.summary.totalRawUsd)],
              ["Margin Used", fmtMoney(item.summary.totalMarginUsed)],
              ["Withdrawable", fmtMoney(item.withdrawable)],
            ];

            return `
              <div class="overview-item">
                <div class="overview-wallet" title="${xmlEscape(item.wallet || "")}">
                  ${xmlEscape(formatWalletLabel(item.wallet || ""))}
                  <span>${Math.round((weights[idx] || 0) * 100)}%</span>
                </div>
                <div class="kv-list">
                  ${rows
                    .map(
                      ([label, value]) => `
                        <div class="kv-label">${label}</div>
                        <div class="kv-value money">${value}</div>
                      `
                    )
                    .join("")}
                </div>
              </div>
            `;
          })
          .join("")}
      </div>
    `;
  }

  function recomputeAndRenderMarginSummary() {
    if (!currentWallets.length) {
      renderMarginSummary([]);
      latestLiveEquityValue = null;
      updateChartTitleValues(latestLiveEquityValue);
      return;
    }

    const snapshots = getActiveSnapshots();
    let totalsMap = getActiveTotals();

    if (currentMarketType === "all") {
      const totals = new Map();
      currentAssetPositions.forEach((item) => {
        const wallet = item.wallet || primaryWallet;
        const p = item.position || {};
        const szi = Number(p.szi ?? 0);
        if (!Number.isFinite(szi) || szi === 0) return;
        const snapshotValue = Number(p.positionValue ?? 0);
        const entryPx = Number(p.entryPx ?? 0);
        let positionValue = snapshotValue;
        if (!Number.isNaN(entryPx) && szi !== 0 && (!Number.isFinite(positionValue) || positionValue === 0)) {
          positionValue = entryPx * szi;
        }
        let upnl = Number(p.unrealizedPnl ?? 0);
        if (!Number.isFinite(upnl)) upnl = 0;
        const notional = Math.abs(Number(positionValue ?? 0));
        const agg = totals.get(wallet) || { upnlTotal: 0, notionalTotal: 0 };
        agg.upnlTotal += upnl;
        if (Number.isFinite(notional)) agg.notionalTotal += notional;
        totals.set(wallet, agg);
      });
      totalsMap = totals;
    }

    const items = currentWallets.map((wallet) => {
      const snap = snapshots.get(wallet) || {};
      const totals = totalsMap.get(wallet) || { upnlTotal: 0, notionalTotal: 0 };
      const base = snap.summary || null;
      if (!base) {
        return { wallet, summary: null, withdrawable: snap.withdrawable };
      }
      const snapshotAV = Number(base.accountValue ?? 0);
      const deltaUpnl = (totals.upnlTotal ?? 0) - (snap.snapshotUpnlTotal ?? 0);
      const liveAccountValue = snapshotAV + (Number.isNaN(deltaUpnl) ? 0 : deltaUpnl);

      const summaryLive = {
        ...base,
        accountValue: liveAccountValue,
        totalNtlPos: totals.notionalTotal || base.totalNtlPos,
      };

      return { wallet, summary: summaryLive, withdrawable: snap.withdrawable };
    });

    renderMarginSummary(items);
    const weights = getNormalizedWeights(currentWallets.map((w) => String(w)));
    latestLiveEquityValue = items.reduce((sum, item, idx) => {
      const val = Number(item?.summary?.accountValue ?? 0);
      const weight = Number(weights[idx] ?? 0);
      return sum + (Number.isFinite(val) ? val * weight : 0);
    }, 0);
    updateChartTitleValues(latestLiveEquityValue);
  }

  function renderPositions(assetPositions) {
    currentAssetPositions = Array.isArray(assetPositions) ? assetPositions : [];
    lastComputedUpnlTotal = 0;
    lastComputedTotalNotional = 0;
    const walletTotals = getActiveTotals();
    walletTotals.clear();
    const positionsColspan = getPositionsColspan();
    updatePositionsSortHeaders();

    if (!currentAssetPositions.length) {
      positionsBodyEl.innerHTML = `<tr><td colspan='${positionsColspan}' class='muted'>No open positions.</td></tr>`;
      recomputeAndRenderMarginSummary();
      refreshBreakdownIfOpen();
      return;
    }

    let positionsToRender = currentAssetPositions.slice();
    if (currentPositionsSort?.key) {
      const metricsMap = new Map();
      const keyFor = (item) => `${item.marketType || "perp"}:${item.wallet || ""}:${item.position?.coin || ""}`;
      const getMetrics = (item) => {
        const key = keyFor(item);
        if (!metricsMap.has(key)) metricsMap.set(key, getPositionSortMetrics(item));
        return metricsMap.get(key);
      };
      const sortKey = currentPositionsSort.key;
      const sortDir = currentPositionsSort.dir;
      positionsToRender.sort((a, b) => {
        const ma = getMetrics(a);
        const mb = getMetrics(b);
        return comparePositionSort(ma?.[sortKey], mb?.[sortKey], sortDir);
      });
    }

    positionsBodyEl.innerHTML = positionsToRender
      .map((item) => {
        const p = item.position;
        const coin = p.coin;
        const wallet = item.wallet || primaryWallet;
        const { dex: coinDex, base: coinBase } = splitDexCoin(coin);
        const coinDisplayName = coinBase || coin;
        const { label: spotLabel, iconKey, isSpot: isSpotMeta } = resolveSpotDisplay(coinDisplayName);
        const iconKeyForLogo = coinDex ? `${coinDex}:${spotLabel}` : iconKey;
        const isSpot = item.marketType === "spot" || isSpotMeta;
        const spotTagHtml = isSpot ? `<span class="dex-tag spot-tag">spot</span>` : "";
        const szi = Number(p.szi ?? 0);

        const dir = szi > 0 ? "LONG" : szi < 0 ? "SHORT" : "FLAT";
        const dirColor = szi >= 0 ? "#4ade80" : "#fb7185";
        const entryPx = Number(p.entryPx ?? 0);

        const livePx = getLivePriceForCoin(coin);
        let markPx = Number.isFinite(livePx) ? livePx : undefined;

        const snapshotValue = Number(p.positionValue ?? 0);
        if ((markPx === undefined || Number.isNaN(markPx)) && szi !== 0 && !Number.isNaN(snapshotValue)) {
          markPx = Math.abs(snapshotValue) / Math.abs(szi);
        }

        let positionValue = snapshotValue;
        if (markPx !== undefined && !Number.isNaN(markPx) && szi !== 0) {
          positionValue = markPx * szi;
        }

        let upnl = Number(p.unrealizedPnl ?? 0);
        if (markPx !== undefined && !Number.isNaN(markPx) && !Number.isNaN(entryPx) && szi !== 0) {
          upnl = (markPx - entryPx) * szi;
        }

        const currentPriceDisplay =
          markPx !== undefined && !Number.isNaN(markPx) ? fmtPrice(markPx) : "â€“";
        const entryPriceDisplay =
          Number.isFinite(entryPx) && entryPx !== 0 ? fmtPrice(entryPx) : "â€“";

        if (!Number.isNaN(upnl)) lastComputedUpnlTotal += upnl;
        const notional = Math.abs(positionValue);
        if (!Number.isNaN(notional)) lastComputedTotalNotional += notional;

        const totals = walletTotals.get(wallet) || { upnlTotal: 0, notionalTotal: 0 };
        if (!Number.isNaN(upnl)) totals.upnlTotal += upnl;
        if (!Number.isNaN(notional)) totals.notionalTotal += notional;
        walletTotals.set(wallet, totals);

        const isPerp = item.marketType !== "spot";
        const leverageValue = p.leverage?.value ?? p.leverage ?? p.lever ?? p.leverageValue;
        const ageMs = computePositionAgeMs(coin, szi, wallet);
        const ageDisplay = Number.isFinite(ageMs) ? formatDuration(ageMs) : "â€“";
        const upnlFormatted = formatSignedDollarWithPlus(upnl);
        const entryNotional = Number.isFinite(entryPx) && szi !== 0 ? Math.abs(entryPx * szi) : null;
        const leverageNum = Number(leverageValue);
        const initialMargin =
          isPerp && Number.isFinite(entryNotional) && entryNotional !== 0 && Number.isFinite(leverageNum) && leverageNum > 0
            ? entryNotional / leverageNum
            : null;
        const upnlPercent = Number.isFinite(initialMargin) && initialMargin !== 0 ? upnl / initialMargin : null;
        const upnlPercentDisplay = upnlPercent === null ? "" : formatSignedPercent(upnlPercent, 2);
        const formattedValue = formatSignedDollar(positionValue);
        const leverageDisplay = isPerp ? formatLeverage(leverageValue) : "";
        const fundingValue =
          (p.cumFunding && typeof p.cumFunding === "object"
            ? p.cumFunding.sinceOpen ?? p.cumFunding.sinceChange ?? p.cumFunding.allTime
            : p.cumFunding) ??
          p.funding ??
          p.fundingPaid ??
          p.cumFundingUsd ??
          p.cumFundingUSDC;
        const liqValue = p.liqPx ?? p.liquidationPx ?? p.liquidationPrice ?? p.liqPrice;
        const fundingDisplay = isPerp ? formatFunding(fundingValue) : "â€“";
        const fundingClass = isPerp ? fundingToneClass(fundingValue) : "";
        const hasLiq = Number.isFinite(Number(liqValue)) && Number(liqValue) !== 0;
        const liqDistanceRaw = isPerp ? computeLiqDistanceRatio(entryPx, markPx, liqValue, szi) : null;
        const liqDistanceClamped = isPerp
          ? Number.isFinite(liqDistanceRaw)
            ? Math.max(0, Math.min(1, liqDistanceRaw))
            : 0
          : null;
        const liqDistanceDisplay =
          liqDistanceClamped === null ? null : Math.max(0, Math.min(1, 1 - liqDistanceClamped));
        const liqDistanceDisplaySafe = !hasLiq && isPerp ? 0 : liqDistanceDisplay;
        const liqDistanceClass =
          liqDistanceDisplaySafe === null
            ? ""
            : liqDistanceDisplaySafe <= 0.25
              ? "liq-danger"
              : liqDistanceDisplaySafe <= 0.5
                ? "liq-warn"
                : liqDistanceDisplaySafe >= 0.9
                  ? "liq-high"
                  : "liq-safe";
        const liqDistancePct = liqDistanceDisplaySafe === null ? "â€“" : formatPercent(liqDistanceDisplaySafe, 0);
        const liqDistanceWidth = liqDistanceDisplaySafe === null ? 0 : Math.round(liqDistanceDisplaySafe * 100);
        const liqHue = liqDistanceDisplaySafe === null ? 120 : Math.round((1 - liqDistanceDisplaySafe) * 120);
        const liqPriceDisplay = isPerp ? (hasLiq ? formatLiqPrice(liqValue, entryPx, markPx) : "$0") : "â€“";
        const liqHighFlag =
          liqDistanceDisplaySafe !== null && liqDistanceDisplaySafe >= 0.9 ? `<span class="liq-flag">HIGH</span>` : "";
        const liqDistanceHtml =
          isPerp
            ? `
              <div class="liq-distance ${liqDistanceClass}">
                <div class="liq-bar" role="img" aria-label="Distance to liquidation ${liqDistancePct}">
                  <span style="width:${liqDistanceWidth}%;background-color:hsl(${liqHue} 70% 55%);"></span>
                </div>
                <div class="liq-meta">
                  <span class="liq-pct">${liqDistancePct}${liqHighFlag}</span>
                  <span class="liq-price">${liqPriceDisplay}</span>
                </div>
              </div>
            `
            : "â€“";

        const positionKey = `${item.marketType || "perp"}:${wallet}:${coin}`;
        const isExpanded = expandedPositions.has(positionKey);
        let breakdownHtml = "";
        if (isExpanded) {
          const mark = getMarkPriceForCoin(coin);
          const breakdown = buildPositionFillDetails(coin, szi, mark, wallet);
          const rowsHtml = breakdown.rows
            .slice()
            .reverse()
            .map(
              (r) => `
              <tr>
                <td class="timestamp">${r.time}</td>
                <td><span class="pill ${sidePillClass(r.sideCode)}">${r.side}</span></td>
                <td class="money">${r.sizeSigned}</td>
                <td class="money">${r.price}</td>
                <td class="money">${r.value}</td>
                <td class="money ${r.upnlRaw >= 0 ? "upnl-pos" : "upnl-neg"}">${r.upnl}</td>
              </tr>
            `
            )
            .join("");

          breakdownHtml = `
            <tr class="position-details">
              <td colspan="${positionsColspan}">
                <div class="position-breakdown">
                  <table class="position-subtable">
                    <thead>
                      <tr>
                        <th>Execution Time</th>
                        <th>Side</th>
                        <th>Size</th>
                        <th>Price</th>
                        <th>Notional</th>
                        <th>Unrealized PnL</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${rowsHtml || `<tr><td colspan="6" class="muted">Finding fills for this asset...</td></tr>`}
                      <tr>
                        <td><strong>Net size</strong></td>
                        <td></td>
                        <td class="money"><strong>${fmtSignedSize(breakdown.netSize)}</strong></td>
                        <td></td>
                        <td></td>
                        <td class="money ${breakdown.totalUpnl >= 0 ? "upnl-pos" : "upnl-neg"}">
                          <strong>${Number.isFinite(breakdown.totalUpnl) ? formatSignedDollarWithPlus(breakdown.totalUpnl) : ""}</strong>
                        </td>
                      </tr>
                    </tbody>
                  </table>
                  ${
                    breakdown.matches
                      ? ""
                      : `<div class="position-breakdown-note">Net from listed fills (${fmtSignedSize(
                          breakdown.netSize
                        )}) differs from current exposure (${fmtSignedSize(szi)}); history may be truncated.</div>`
                  }
                </div>
              </td>
            </tr>
          `;
        }

        return `
        <tr class="position-row${isExpanded ? " expanded" : ""}" data-coin="${coin}" data-wallet="${wallet}" data-market="${item.marketType || "perp"}">
          <td>
            <div class="asset-cell">
              ${coinIconHtml(iconKeyForLogo, spotLabel)}
              <span>${spotLabel}</span>
              ${spotTagHtml}
              ${walletTagHtml(wallet)}
              ${coinDex ? `<span class="dex-tag">${coinDex}</span>` : ""}
              <span class="chevron" aria-hidden="true"></span>
            </div>
          </td>
          <td>
            <span class="pill" style="color:${dirColor};border-color:${dirColor}55;background:${dirColor}22;">
              ${dir}${leverageDisplay ? ` ${leverageDisplay}` : ""}
            </span>
          </td>
          <td class="money size-cell">
            <div class="price-stack size-stack">
              <span class="notional-sub">${formattedValue}</span>
              <span class="size-main">${fmtSize(szi)} <span class="size-ticker">${spotLabel}</span></span>
            </div>
          </td>
          <td class="money">
            <div class="price-stack">
              <span class="current-price">Live: ${currentPriceDisplay}</span>
              <span>Entry: ${entryPriceDisplay}</span>
            </div>
          </td>
          <td class="desktop-only">
            <span class="timestamp">${ageDisplay}</span>
          </td>
          <td class="money pnl-cell ${upnl >= 0 ? "upnl-pos" : "upnl-neg"}">
            <div class="price-stack">
              <span>${upnlFormatted}</span>
              <span class="notional-sub roe-sub">${upnlPercentDisplay || ""}</span>
            </div>
            <button class="pnl-share-btn centered" type="button" title="Share PnL" aria-label="Share PnL"
              data-wallet="${xmlEscape(wallet)}"
              data-asset="${xmlEscape(spotLabel)}"
              data-coin="${xmlEscape(coin)}"
              data-spot="${isSpot ? "true" : "false"}"
              data-direction="${dir}${leverageDisplay ? ` ${leverageDisplay}` : ""}"
              data-upnl="${upnlFormatted}"
              data-roe="${upnlPercentDisplay}"
              data-entry="${entryPriceDisplay}"
              data-current="${currentPriceDisplay}">
              <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" style="width:10px;height:10px;">
                <path d="M14 3h7v7" stroke="currentColor" stroke-width="1.7" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M10 14L21 3" stroke="currentColor" stroke-width="1.7" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M21 14v5a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5" stroke="currentColor" stroke-width="1.7" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </button>
          </td>
          <td class="desktop-only">${liqDistanceHtml}</td>
          <td class="money desktop-only ${fundingClass}">${fundingDisplay}</td>
        </tr>
        ${breakdownHtml}
      `;
      })
      .join("");

    recomputeAndRenderMarginSummary();
    refreshBreakdownIfOpen();
  }

  function computeSnapshotUpnlTotal(assetPositions) {
    if (!Array.isArray(assetPositions)) return 0;
    return assetPositions.reduce((sum, item) => {
      const p = item.position;
      const u = Number(p.unrealizedPnl ?? 0);
      return sum + (Number.isNaN(u) ? 0 : u);
    }, 0);
  }

  function setWalletPositions(marketType, wallet, positions) {
    const map = walletPositionsByType[marketType];
    if (!map) return;
    map.set(wallet, Array.isArray(positions) ? positions : []);
    if (marketType === currentMarketType || currentMarketType === "all") {
      renderPositions(getPositionsForMarketType(currentMarketType));
    }
  }

  async function refreshPositionsAndMargin(wallet) {
    try {
      const clearing = await infoClient.clearinghouseState({ user: wallet });
      const { marginSummary, withdrawable, assetPositions } = clearing;
      const mergedPositions = Array.isArray(assetPositions)
        ? assetPositions.map((pos) => ({ ...pos, wallet, marketType: "perp" }))
        : [];

      walletSnapshotsByType.perp.set(wallet, {
        summary: marginSummary || null,
        withdrawable,
        snapshotUpnlTotal: computeSnapshotUpnlTotal(mergedPositions),
      });

      setWalletPositions("perp", wallet, mergedPositions);

      // Fetch HIP-3/extra dex positions after main state
      fetchAdditionalDexPositions(wallet).then((extraPositions) => {
        if (!Array.isArray(extraPositions) || extraPositions.length === 0) return;
        const combined = [
          ...mergedPositions,
          ...extraPositions.map((pos) => ({ ...pos, wallet, marketType: "perp" })),
        ];
        walletSnapshotsByType.perp.set(wallet, {
          summary: marginSummary || null,
          withdrawable,
          snapshotUpnlTotal: computeSnapshotUpnlTotal(combined),
        });
        setWalletPositions("perp", wallet, combined);
      });
    } catch (err) {
      console.error("Refresh positions error", err);
      snapshotErrorEl.textContent = "Failed to refresh positions: " + (err?.message || err);
    }
  }

  async function refreshSpotPositionsAndSummary(wallet) {
    try {
      const spotState = await fetchSpotState(wallet);
      if (!spotState) {
        walletSnapshotsByType.spot.set(wallet, { summary: null, withdrawable: 0, snapshotUpnlTotal: 0 });
        setWalletPositions("spot", wallet, []);
        return;
      }
      const spotPositions = normalizeSpotBalances(spotState.balances, wallet);
      const summary = buildSpotSummary(spotPositions);
      walletSnapshotsByType.spot.set(wallet, {
        summary: {
          accountValue: summary.accountValue,
          totalNtlPos: summary.totalNtlPos,
          totalRawUsd: summary.totalRawUsd,
          totalMarginUsed: summary.totalMarginUsed,
        },
        withdrawable: summary.withdrawable,
        snapshotUpnlTotal: 0,
      });
      setWalletPositions("spot", wallet, spotPositions);
    } catch (err) {
      console.error("Spot refresh error", err);
      if (currentMarketType === "spot") {
        snapshotErrorEl.textContent = "Failed to refresh spot balances: " + (err?.message || err);
      }
    }
  }

  async function refreshSpotForWallets(wallets = currentWallets) {
    const walletList = Array.isArray(wallets) ? wallets : [wallets];
    if (!walletList.length) return;
    await Promise.all(walletList.map((wallet) => refreshSpotPositionsAndSummary(wallet)));
  }

  function renderOpenOrders() {
    const values = filterEntriesByMarketType(Array.from(openOrders.values()))
      .sort((a, b) => (b.timestamp ?? 0) - (a.timestamp ?? 0));
    openOrdersCountEl.textContent = values.length.toString();

    const MIN_ROWS = 4;

    // Build real rows
    const rows = values.map((order) => {
      const created = fmtDateTime(order.timestamp);
      const side = order.side ?? "?";
      const leverageDisplay =
        order.marketType !== "spot" ? getEntryLeverage(order) : "";
      const coin = resolveCoinName(order.coin, order.asset);
      const wallet = order.wallet || primaryWallet;
      const forceSpot = entryMatchesMarketType(order, "spot");
      const orderIdHtml = formatSpotIdHtml(order.oid);
      const orderType = getOrderTypeLabel(order);
      return `
        <tr>
          <td class="desktop-only">${orderIdHtml}</td>
          <td class="desktop-only"><span class="timestamp">${created}</span></td>
          <td class="asset-cell">${coinCellHtml(coin, wallet, forceSpot)}</td>
          <td><span class="pill ${sidePillClass(side)}">${sideLabel(side)}${leverageDisplay ? ` ${leverageDisplay}` : ""}</span></td>
          <td class="desktop-only">${orderType}</td>
          <td class="money">${fmtSize(order.sz)}</td>
          <td class="money">${fmtLimitPrice(order.limitPx) ?? ""}</td>
        </tr>
      `;
    });

    // If none, show 1 â€œNo open orders.â€ row, then pad to MIN_ROWS
    if (rows.length === 0) {
      rows.push(`<tr><td colspan="8" class="muted">No open orders.</td></tr>`);
    }

    // Pad with empty rows until we have MIN_ROWS visible rows
    while (rows.length < MIN_ROWS) {
      rows.push(`
        <tr class="placeholder-row">
          <td colspan="8">&nbsp;</td>
        </tr>
      `);
    }

    openOrdersBodyEl.innerHTML = rows.join("");
  }

  function renderCanceledOrders() {
    const filtered = filterEntriesByMarketType(canceledOrders);
    canceledCountEl.textContent = filtered.length.toString();

    if (filtered.length === 0) {
      canceledOrdersBodyEl.innerHTML = "<tr><td colspan='7' class='muted'>No canceled orders yet.</td></tr>";
      return;
    }

    canceledOrdersBodyEl.innerHTML = filtered
      .map((o) => {
      const created = fmtTimeOnly(o.timestamp);
      const canceledAtTime = fmtTimeOnly(o.statusTimestamp);
      const side = o.side ?? "?";
      const leverageDisplay =
        o.marketType !== "spot" ? getEntryLeverage(o) : "";
      const coin = resolveCoinName(o.coin, o.asset);
      const wallet = o.wallet || primaryWallet;
      const forceSpot = entryMatchesMarketType(o, "spot");
      const orderIdHtml = formatSpotIdHtml(o.oid);
      const orderType = getOrderTypeLabel(o);
      return `
        <tr class="flash-cancel">
          <td class="desktop-only">${orderIdHtml}</td>
          <td>
            <div class="price-stack">
              <span class="timestamp">Created: ${created}</span>
              <span class="timestamp">Canceled: ${canceledAtTime}</span>
            </div>
          </td>
          <td class="asset-cell">${coinCellHtml(coin, wallet, forceSpot)}</td>
          <td><span class="pill ${sidePillClass(side)}">${sideLabel(side)}${leverageDisplay ? ` ${leverageDisplay}` : ""}</span></td>  
          <td class="money">${fmtSize(o.sz)}</td>
          <td class="desktop-only">${orderType}</td>
          <td class="mobile-only money">${fmtLimitPrice(o.limitPx) ?? ""}</td>
        </tr>
      `;
      })
      .join("");
  }

  function renderFills() {
    const filtered = filterEntriesByMarketType(fills);
    if (filtered.length === 0) {
      fillsBodyEl.innerHTML = "<tr><td colspan='7' class='muted'>Waiting for fills...</td></tr>";
      if (fillsCountEl) fillsCountEl.textContent = "0";
      return;
    }

    fillsBodyEl.innerHTML = filtered
      .map((fill) => {
        const tTime = fmtTimeOnly(fill.time);
        const total = computeTotal(fill);
        const side = fill.side ?? "?";
        const leverageDisplay =
          fill.marketType !== "spot" ? getEntryLeverage(fill) : "";
        const orderIdHtml = formatSpotIdHtml(fill.oid);
        const coin = resolveCoinName(fill.coin, fill.asset ?? fill.symbol ?? fill.sym);
        const wallet = fill.wallet || primaryWallet;
        const forceSpot = entryMatchesMarketType(fill, "spot");
        const sizeAbs = Math.abs(Number(fill.sz ?? 0));
        const pxVal = Number(fill.px ?? 0);
        const notionalVal =
          Number.isFinite(sizeAbs) && Number.isFinite(pxVal) ? sizeAbs * pxVal : NaN;
        const signedNotional = side === "S" ? -notionalVal : notionalVal;
        const notionalDisplay = Number.isFinite(signedNotional) ? formatSignedDollar(signedNotional) : "";
        const orderType = getOrderTypeLabel(fill);
        return `
        <tr class="flash">
          <td class="desktop-only">${orderIdHtml}</td>
          <td>
            <span class="mobile-only timestamp">${tTime}</span>
            <span class="desktop-only timestamp">${tTime}</span>
          </td>
          <td class="asset-cell">${coinCellHtml(coin, wallet, forceSpot)}</td>
          <td><span class="pill ${sidePillClass(side)}">${sideLabel(side)}${leverageDisplay ? ` ${leverageDisplay}` : ""}</span></td>
          <td class="money size-cell">
            <div class="price-stack size-stack">
              <span class="notional-sub">${notionalDisplay}</span>
              <span class="size-main">${fmtSize(fill.sz)} <span class="size-ticker">${coin}</span></span>
            </div>
          </td>
          <td class="money">${fmtPrice(fill.px) ?? ""}</td>
          <td class="desktop-only">${orderType}</td>
        </tr>
      `;
      })
      .join("");

    if (fillsCountEl) fillsCountEl.textContent = `${filtered.length}`;
  }

  function renderHistoricalFills() {
    if (!historicalFillsBodyEl) return;

    const marketFiltered = filterEntriesByMarketType(historicalFills);
    if (marketFiltered.length === 0) {
      historicalFillsBodyEl.innerHTML = "<tr><td colspan='6' class='muted'>No historical fills found.</td></tr>";
      if (historicalFillsCountEl) historicalFillsCountEl.textContent = "0";
      return;
    }

    const filtered = marketFiltered.filter((fill) => {
      const sz = Number(fill.sz ?? fill.size ?? 0);
      const px = Number(fill.px ?? fill.price ?? 0);
      const val = sz * px;
      return !(Number.isFinite(val) && Math.abs(val) < 0.0000001);
    });

    let historicalFillsClosedPnl = null;
    if (!historicalFillsClosedPnl) {
      const closedPnlMap = new Map();
      const sortedForPnl = [...marketFiltered].sort(
        (a, b) => Number(a.time ?? a.timestamp ?? 0) - Number(b.time ?? b.timestamp ?? 0)
      );
      const positionByCoin = new Map();

      sortedForPnl.forEach((fill) => {
        const { sideSign, sizeAbs } = getFillSideAndSize(fill);
        const price = Number(fill.px ?? fill.price ?? 0);
        if (!sideSign || !Number.isFinite(sizeAbs) || sizeAbs <= 0 || !Number.isFinite(price)) return;
        const rawCoin = fill.coin ?? fill.asset ?? fill.symbol ?? fill.sym ?? "";
        const coin = resolveCoinName(rawCoin, fill.asset ?? fill.symbol ?? fill.sym) || rawCoin || "";
        if (!coin) return;

        const lots = positionByCoin.get(coin) || [];
        let remaining = sizeAbs;
        let realized = 0;

        while (remaining > 0 && lots.length > 0 && lots[0].sideSign !== sideSign) {
          const lot = lots[0];
          const matchSize = Math.min(remaining, lot.size);
          const pnl = (price - lot.price) * matchSize * lot.sideSign;
          realized += pnl;
          lot.size -= matchSize;
          remaining -= matchSize;
          if (lot.size <= 0) lots.shift();
        }

        if (remaining > 0) {
          lots.push({ sideSign, size: remaining, price });
        }

        positionByCoin.set(coin, lots);

        if (realized !== 0) {
          closedPnlMap.set(fill, realized);
        }
      });

      historicalFillsClosedPnl = closedPnlMap;
    }

    updateTableSortHeaders(historicalFillsHeaderEls, currentHistoricalFillsSort);
    const sorted = filtered.slice();
    if (currentHistoricalFillsSort?.key) {
      const sortKey = currentHistoricalFillsSort.key;
      const sortDir = currentHistoricalFillsSort.dir;
      sorted.sort((a, b) => {
        const aCoin = resolveCoinName(a.coin ?? "", a.asset ?? a.symbol ?? a.sym);
        const bCoin = resolveCoinName(b.coin ?? "", b.asset ?? b.symbol ?? b.sym);
        const aSide = a.side ?? (a.isBuy ? "B" : "S") ?? "";
        const bSide = b.side ?? (b.isBuy ? "B" : "S") ?? "";
        const aPnl = historicalFillsClosedPnl?.get(a);
        const bPnl = historicalFillsClosedPnl?.get(b);
        const aMetrics = {
          orderId: String(a.oid ?? ""),
          time: Number(a.time ?? a.timestamp ?? 0),
          side: aSide,
          asset: String(aCoin ?? "").toUpperCase(),
          size: Number(a.sz ?? a.size ?? 0),
          price: Number(a.px ?? a.price ?? 0),
          pnl: Number.isFinite(aPnl) ? aPnl : null,
        };
        const bMetrics = {
          orderId: String(b.oid ?? ""),
          time: Number(b.time ?? b.timestamp ?? 0),
          side: bSide,
          asset: String(bCoin ?? "").toUpperCase(),
          size: Number(b.sz ?? b.size ?? 0),
          price: Number(b.px ?? b.price ?? 0),
          pnl: Number.isFinite(bPnl) ? bPnl : null,
        };
        return comparePositionSort(aMetrics[sortKey], bMetrics[sortKey], sortDir);
      });
    }

    historicalFillsBodyEl.innerHTML = sorted
      .map((fill) => {
        const t = fmtDateTime(fill.time ?? fill.timestamp);
        const total = computeTotal(fill);
        const side = fill.side ?? (fill.isBuy ? "B" : "S") ?? "?";
        const orderIdHtml = formatSpotIdHtml(fill.oid ?? "");
        const coin = resolveCoinName(fill.coin ?? "", fill.asset ?? fill.symbol ?? fill.sym);
        const wallet = fill.wallet || primaryWallet;
        const forceSpot = entryMatchesMarketType(fill, "spot");
        const closedPnl = historicalFillsClosedPnl?.get(fill);
        const closedPnlDisplay = Number.isFinite(closedPnl) ? formatSignedDollarWithPlus(closedPnl) : "";
        return `
        <tr>
          <td class="desktop-only">${orderIdHtml}</td>
          <td><span class="timestamp">${t}</span></td>
          <td><span class="pill ${sidePillClass(side)}">${sideLabel(side)}</span></td>
          <td class="asset-cell">${coinCellHtml(coin, wallet, forceSpot)}</td>
          <td class="money">${fmtSize(fill.sz ?? fill.size)}</td>
          <td class="money">${fmtPrice(fill.px ?? fill.price) ?? ""}</td>
          <td class="money ${Number.isFinite(closedPnl) ? (closedPnl >= 0 ? "upnl-pos" : "upnl-neg") : ""}">
            ${closedPnlDisplay}
          </td>
        </tr>
      `;
      })
      .join("");

    if (historicalFillsCountEl) historicalFillsCountEl.textContent = `${filtered.length}`;
  }

  function pickOrderId(entry, order) {
    return (
      order?.oid ??
      order?.orderId ??
      order?.order_id ??
      order?.id ??
      entry?.oid ??
      entry?.orderId ??
      entry?.order_id ??
      entry?.id ??
      ""
    );
  }

  function normalizeHistoricalOrder(entry) {
    const o = entry?.order ?? entry ?? {};
    const status = entry?.status ?? o.status ?? "";
    const statusTimestamp = entry?.statusTimestamp ?? o.statusTimestamp ?? o.timestamp ?? null;

    return {
      wallet: entry?.wallet ?? o.wallet ?? "",
      oid: pickOrderId(entry, o),
      coin: o.coin,
      side: o.side,
      limitPx: o.limitPx ?? o.px,
      sz: o.origSz ?? o.sz,
      timestamp: o.timestamp,
      status,
      statusTimestamp,
      raw: entry,
    };
  }

  function buildLiveOrdersRowsForExport() {
    const values = filterEntriesByMarketType(Array.from(openOrders.values()));
    if (!values.length) return [];

    return values
      .sort((a, b) => (b.timestamp ?? 0) - (a.timestamp ?? 0))
      .map((order) => {
        const side = order.side ?? "?";
        return [
          order.wallet || "",
          order.oid ?? "",
          fmtDateTime(order.timestamp),
          sideLabel(side),
          order.coin ?? "",
          fmtSize(order.sz),
          fmtLimitPrice(order.limitPx) ?? "",
          computeTotal(order) ? `$${computeTotal(order)}` : "",
        ];
      });
  }

  function buildHistoricalOrdersRowsForExport() {
    if (!Array.isArray(historicalOrders) || historicalOrders.length === 0) return [];
    return historicalOrders.filter((entry) => entryMatchesMarketType(entry)).map((entry) => {
      const o = normalizeHistoricalOrder(entry);
      const side = o.side ?? (o.isBuy ? "B" : "S") ?? "?";
      return [
        o.wallet || "",
        o.oid ?? "",
        fmtDateTime(o.timestamp),
        sideLabel(side),
        o.coin ?? "",
        fmtSize(o.sz ?? o.size),
        fmtLimitPrice(o.limitPx) ?? "",
        computeTotal(o) ? `$${computeTotal(o)}` : "",
        o.status ?? "",
      ];
    });
  }

  function buildLiveFillsRowsForExport() {
    const filtered = filterEntriesByMarketType(fills);
    if (!filtered.length) return [];
    return filtered.map((fill) => {
      const side = fill.side ?? "?";
      return [
        fill.wallet || "",
        fill.oid ?? "",
        fmtDateTime(fill.time ?? fill.timestamp),
        sideLabel(side),
        fill.coin ?? "",
        fmtSize(fill.sz),
        fmtPrice(fill.px) ?? "",
        computeTotal(fill) ? `$${computeTotal(fill)}` : "",
      ];
    });
  }

  function buildHistoricalFillsRowsForExport() {
    const filtered = filterEntriesByMarketType(historicalFills);
    if (!filtered.length) return [];
    return filtered.map((fill) => {
      const side = fill.side ?? (fill.isBuy ? "B" : "S") ?? "?";
      return [
        fill.wallet || "",
        fill.oid ?? "",
        fmtDateTime(fill.time ?? fill.timestamp),
        sideLabel(side),
        fill.coin ?? "",
        fmtSize(fill.sz ?? fill.size),
        fmtPrice(fill.px ?? fill.price) ?? "",
        computeTotal(fill) ? `$${computeTotal(fill)}` : "",
      ];
    });
  }

  function buildPortfolioSummaryRows() {
    const snapshots = getActiveSnapshots();
    if (!snapshots.size) return [["Status", "Not loaded"]];

    const totals = {
      accountValue: 0,
      totalNtlPos: 0,
      totalRawUsd: 0,
      totalMarginUsed: 0,
      withdrawable: 0,
    };

    snapshots.forEach((snap) => {
      const summary = snap?.summary || {};
      totals.accountValue += Number(summary.accountValue ?? 0) || 0;
      totals.totalNtlPos += Number(summary.totalNtlPos ?? 0) || 0;
      totals.totalRawUsd += Number(summary.totalRawUsd ?? 0) || 0;
      totals.totalMarginUsed += Number(summary.totalMarginUsed ?? 0) || 0;
      totals.withdrawable += Number(snap?.withdrawable ?? 0) || 0;
    });

    return [
      ["Equity", fmtMoney(totals.accountValue)],
      ["Notional Exposure", fmtMoney(totals.totalNtlPos)],
      ["Collateral", fmtMoney(totals.totalRawUsd)],
      ["Margin Used", fmtMoney(totals.totalMarginUsed)],
      ["Withdrawable", fmtMoney(totals.withdrawable)],
    ];
  }

  async function ensureHistoricalDataLoaded() {
    if (!currentWallets.length) return;
    const tasks = [];
    if (!historicalOrdersLoaded) tasks.push(loadHistoricalOrders(currentWallets));
    if (!historicalFillsLoaded) tasks.push(loadHistoricalFills(currentWallets));
    if (tasks.length) await Promise.all(tasks);
  }

  function toColumnName(idx) {
    let n = idx + 1;
    let name = "";
    while (n > 0) {
      const rem = (n - 1) % 26;
      name = String.fromCharCode(65 + rem) + name;
      n = Math.floor((n - 1) / 26);
    }
    return name;
  }

  function buildSheetXml(rows) {
    const safeRows = (rows && rows.length ? rows : [["No data"]]).map((r) =>
      Array.isArray(r) ? r : [r]
    );

    const rowXml = safeRows
      .map((row, rowIdx) => {
        const cells = row
          .map((cell, colIdx) => {
            const r = `${toColumnName(colIdx)}${rowIdx + 1}`;
            return `<c r="${r}" t="inlineStr"><is><t>${xmlEscape(cell)}</t></is></c>`;
          })
          .join("");
        return `<row r="${rowIdx + 1}">${cells}</row>`;
      })
      .join("");

    return (
      `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>` +
      `<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">` +
      `<sheetData>${rowXml}</sheetData>` +
      `</worksheet>`
    );
  }

  function buildSheets() {
    const generatedAt = fmtDateTime(Date.now());
    const walletListLabel = currentWallets.length ? currentWallets.join(", ") : "";
    return [
      { name: "Metadata", rows: [["Wallets", "Generated At", "Source"], [walletListLabel, generatedAt, "https://hypermonitor.org/"]] },
      { name: "Portfolio Summary", rows: [["Metric", "Value"], ...buildPortfolioSummaryRows()] },
      {
        name: "Positions",
        rows: [
          ["Wallet", "Asset", "Side", "Size", "Avg Entry", "Notional", "Unrealized PnL"],
          ...buildPositionsRowsForExport(),
        ],
      },
      {
        name: "Live Orders",
        rows: [
          ["Wallet", "Order ID", "Date/Time", "Side", "Asset", "Size", "Limit Price", "Notional"],
          ...buildLiveOrdersRowsForExport(),
        ],
      },
      {
        name: "Historical Orders",
        rows: [
          ["Wallet", "Order ID", "Date/Time", "Side", "Asset", "Size", "Limit Price", "Notional", "Status"],
          ...buildHistoricalOrdersRowsForExport(),
        ],
      },
      {
        name: "Live Trades",
        rows: [
          ["Wallet", "Order ID", "Date/Time", "Side", "Asset", "Size", "Price", "Notional"],
          ...buildLiveFillsRowsForExport(),
        ],
      },
      {
        name: "Historical Trades",
        rows: [
          ["Wallet", "Order ID", "Date/Time", "Side", "Asset", "Size", "Price", "Notional"],
          ...buildHistoricalFillsRowsForExport(),
        ],
      },
    ];
  }

  function buildWorkbookXml(sheets) {
    const sheetsXml = sheets
      .map(
        (sheet, idx) =>
          `<sheet name="${xmlEscape(sheet.name)}" sheetId="${idx + 1}" r:id="rId${idx + 1}"/>`
      )
      .join("");

    return (
      `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>` +
      `<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" ` +
      `xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">` +
      `<sheets>${sheetsXml}</sheets>` +
      `</workbook>`
    );
  }

  function buildWorkbookRels(sheets) {
    const relsXml = sheets
      .map(
        (_sheet, idx) =>
          `<Relationship Id="rId${idx + 1}" ` +
          `Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" ` +
          `Target="worksheets/sheet${idx + 1}.xml"/>`
      )
      .join("");

    return (
      `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>` +
      `<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">` +
      relsXml +
      `</Relationships>`
    );
  }

  function buildRootRels() {
    return (
      `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>` +
      `<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">` +
      `<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>` +
      `</Relationships>`
    );
  }

  function buildContentTypes(sheets) {
    const sheetOverrides = sheets
      .map(
        (_sheet, idx) =>
          `<Override PartName="/xl/worksheets/sheet${idx + 1}.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/>`
      )
      .join("");

    return (
      `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>` +
      `<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">` +
      `<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>` +
      `<Default Extension="xml" ContentType="application/xml"/>` +
      `<Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>` +
      sheetOverrides +
      `</Types>`
    );
  }

  const CRC_TABLE = (() => {
    const table = new Uint32Array(256);
    for (let n = 0; n < 256; n++) {
      let c = n;
      for (let k = 0; k < 8; k++) {
        c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1;
      }
      table[n] = c >>> 0;
    }
    return table;
  })();

  function crc32Uint8(data) {
    let crc = 0xffffffff;
    for (let i = 0; i < data.length; i++) {
      crc = CRC_TABLE[(crc ^ data[i]) & 0xff] ^ (crc >>> 8);
    }
    return (crc ^ 0xffffffff) >>> 0;
  }

  function createZip(files) {
    const encoder = new TextEncoder();
    let offset = 0;
    const localChunks = [];
    const centralChunks = [];

    files.forEach((file) => {
      const nameBytes = encoder.encode(file.path);
      const dataBytes = typeof file.data === "string" ? encoder.encode(file.data) : file.data;
      const crc = crc32Uint8(dataBytes);

      const local = new Uint8Array(30 + nameBytes.length + dataBytes.length);
      const lv = new DataView(local.buffer);
      lv.setUint32(0, 0x04034b50, true);
      lv.setUint16(4, 20, true); // version needed to extract
      lv.setUint16(6, 0, true); // flags
      lv.setUint16(8, 0, true); // compression (0 = store)
      lv.setUint16(10, 0, true); // mod time
      lv.setUint16(12, 0, true); // mod date
      lv.setUint32(14, crc, true);
      lv.setUint32(18, dataBytes.length, true); // compressed size
      lv.setUint32(22, dataBytes.length, true); // uncompressed size
      lv.setUint16(26, nameBytes.length, true);
      lv.setUint16(28, 0, true); // extra length
      local.set(nameBytes, 30);
      local.set(dataBytes, 30 + nameBytes.length);
      localChunks.push(local);

      const central = new Uint8Array(46 + nameBytes.length);
      const cv = new DataView(central.buffer);
      cv.setUint32(0, 0x02014b50, true);
      cv.setUint16(4, 0x031e, true); // version made by
      cv.setUint16(6, 20, true); // version needed
      cv.setUint16(8, 0, true); // flags
      cv.setUint16(10, 0, true); // compression
      cv.setUint16(12, 0, true); // mod time
      cv.setUint16(14, 0, true); // mod date
      cv.setUint32(16, crc, true);
      cv.setUint32(20, dataBytes.length, true);
      cv.setUint32(24, dataBytes.length, true);
      cv.setUint16(28, nameBytes.length, true);
      cv.setUint16(30, 0, true); // extra length
      cv.setUint16(32, 0, true); // file comment length
      cv.setUint16(34, 0, true); // disk number start
      cv.setUint16(36, 0, true); // internal file attrs
      cv.setUint32(38, 0, true); // external file attrs
      cv.setUint32(42, offset, true); // relative offset
      central.set(nameBytes, 46);
      centralChunks.push(central);

      offset += local.length;
    });

    const centralSize = centralChunks.reduce((sum, chunk) => sum + chunk.length, 0);
    const end = new Uint8Array(22);
    const ev = new DataView(end.buffer);
    ev.setUint32(0, 0x06054b50, true);
    ev.setUint16(4, 0, true); // disk number
    ev.setUint16(6, 0, true); // central dir disk
    ev.setUint16(8, files.length, true); // entries this disk
    ev.setUint16(10, files.length, true); // total entries
    ev.setUint32(12, centralSize, true); // central size
    ev.setUint32(16, offset, true); // central offset
    ev.setUint16(20, 0, true); // comment length

    const totalSize = offset + centralSize + end.length;
    const out = new Uint8Array(totalSize);

    let pointer = 0;
    localChunks.forEach((chunk) => {
      out.set(chunk, pointer);
      pointer += chunk.length;
    });

    let centralPointer = offset;
    centralChunks.forEach((chunk) => {
      out.set(chunk, centralPointer);
      centralPointer += chunk.length;
    });

    out.set(end, centralPointer);
    return out;
  }

  function buildXlsxFile() {
    const sheets = buildSheets();
    const sheetFiles = sheets.map((sheet, idx) => ({
      path: `xl/worksheets/sheet${idx + 1}.xml`,
      data: buildSheetXml(sheet.rows),
    }));

    const files = [
      { path: "[Content_Types].xml", data: buildContentTypes(sheets) },
      { path: "_rels/.rels", data: buildRootRels() },
      { path: "xl/workbook.xml", data: buildWorkbookXml(sheets) },
      { path: "xl/_rels/workbook.xml.rels", data: buildWorkbookRels(sheets) },
      ...sheetFiles,
    ];

    return createZip(files);
  }

  async function triggerExcelDownload() {
    try {
      await ensureHistoricalDataLoaded();

      const archive = buildXlsxFile();
      const walletSlug = currentWallets.length === 1 ? currentWallets[0] : "multi-wallets";
      const filename = `hypermonitor-${walletSlug}.xlsx`;
      const blob = new Blob([archive], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      link.remove();
      URL.revokeObjectURL(url);
    } catch (err) {
      console.error("Export error", err);
      alert("Failed to export Excel. See console for details.");
    }
  }

  function renderHistoricalOrders() {
    if (!historicalOrdersBodyEl) return;

    const marketFiltered = historicalOrders.filter((entry) => entryMatchesMarketType(entry));
    const totalCount = marketFiltered.length;
    const sideFilter = historicalSideFilterEl?.value || "all";
    const statusFilter = (historicalStatusFilterEl?.value || "all").toLowerCase();
    const assetFilter = (historicalAssetFilterEl?.value || "").trim().toLowerCase();

    const filtered = marketFiltered
      .map(normalizeHistoricalOrder)
      .filter((o) => {
        const side = o.side ?? (o.isBuy ? "B" : "S");
        const status = (o.status ?? "").toLowerCase();
        const coin = (o.coin ?? "").toLowerCase();

        if (sideFilter !== "all" && side !== sideFilter) return false;
        if (statusFilter !== "all" && !status.includes(statusFilter)) return false;
        if (assetFilter && !coin.includes(assetFilter)) return false;

        return true;
      });

    if (historicalOrdersCountEl) {
      if (historicalOrdersLoaded) historicalOrdersCountEl.textContent = `${filtered.length} / ${totalCount}`;
      else historicalOrdersCountEl.textContent = "â€“";
    }

    if (filtered.length === 0) {
      historicalOrdersBodyEl.innerHTML = "<tr><td colspan='7' class='muted'>No orders match the current filters.</td></tr>";
      return;
    }

    updateTableSortHeaders(historicalOrdersHeaderEls, currentHistoricalOrdersSort);
    const sorted = filtered.slice();
    if (currentHistoricalOrdersSort?.key) {
      const sortKey = currentHistoricalOrdersSort.key;
      const sortDir = currentHistoricalOrdersSort.dir;
      sorted.sort((a, b) => {
        const aCoin = resolveCoinName(a.coin ?? "", a.asset ?? a.symbol ?? a.sym);
        const bCoin = resolveCoinName(b.coin ?? "", b.asset ?? b.symbol ?? b.sym);
        const aSide = a.side ?? (a.isBuy ? "B" : "S") ?? "";
        const bSide = b.side ?? (b.isBuy ? "B" : "S") ?? "";
        const aStatus = String(a.status ?? "").toUpperCase();
        const bStatus = String(b.status ?? "").toUpperCase();
        const aMetrics = {
          orderId: String(a.oid ?? ""),
          time: Number(a.timestamp ?? 0),
          side: aSide,
          asset: String(aCoin ?? "").toUpperCase(),
          size: Number(a.sz ?? a.size ?? 0),
          price: Number(a.limitPx ?? a.px ?? 0),
          status: aStatus,
        };
        const bMetrics = {
          orderId: String(b.oid ?? ""),
          time: Number(b.timestamp ?? 0),
          side: bSide,
          asset: String(bCoin ?? "").toUpperCase(),
          size: Number(b.sz ?? b.size ?? 0),
          price: Number(b.limitPx ?? b.px ?? 0),
          status: bStatus,
        };
        return comparePositionSort(aMetrics[sortKey], bMetrics[sortKey], sortDir);
      });
    }

    historicalOrdersBodyEl.innerHTML = sorted
      .map((o) => {
        const created = fmtDateTime(o.timestamp);
        const side = o.side ?? (o.isBuy ? "B" : "S");
        const status = o.status ?? "";
        const orderIdHtml = formatSpotIdHtml(o.oid ?? "");
        const coin = resolveCoinName(o.coin ?? "", o.asset ?? o.symbol ?? o.sym);
        const wallet = o.wallet || primaryWallet;
        const forceSpot = entryMatchesMarketType(o, "spot");

        return `
        <tr>
          <td>${orderIdHtml}</td>
          <td><span class="timestamp">${created}</span></td>
          <td><span class="pill ${sidePillClass(side)}">${sideLabel(side)}</span></td>
          <td class="asset-cell">${coinCellHtml(coin, wallet, forceSpot)}</td>
          <td class="money">${fmtSize(o.sz ?? o.size)}</td>
          <td class="money">${fmtLimitPrice(o.limitPx) ?? ""}</td>
          <td>${status}</td>
        </tr>
      `;
      })
      .join("");
  }

  async function loadHistoricalOrders(wallets = currentWallets) {
    if (!historicalOrdersBodyEl) return;
    const walletList = Array.isArray(wallets) ? wallets : [wallets];
    if (!walletList.length) return;

    historicalOrdersLoaded = false;
    if (historicalOrdersCountEl) historicalOrdersCountEl.textContent = "â€“";
    historicalOrdersBodyEl.innerHTML = "<tr><td colspan='7' class='muted'>Loading historical ordersâ€¦</td></tr>";

    try {
      const all = [];
      for (const wallet of walletList) {
        try {
          const body = { type: "historicalOrders", user: wallet };
          const res = await fetch(PORTFOLIO_API_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
          });

          if (!res.ok) throw new Error(`Historical orders error: ${res.status} ${res.statusText}`);

          const data = await res.json();
          if (Array.isArray(data)) {
            data.forEach((entry) => {
              if (entry && typeof entry === "object") {
                entry.wallet = wallet;
                const rawCoin = entry?.coin ?? entry?.order?.coin ?? entry?.order?.asset ?? entry?.order?.symbol ?? entry?.order?.sym ?? "";
                if (rawCoin) entry.marketType = getMarketTypeFromCoin(rawCoin);
              }
            });
            all.push(...data);
          }
        } catch (err) {
          console.error(`Historical orders error for ${wallet}`, err);
        }
      }

      historicalOrders.length = 0;
      if (all.length) {
        all.sort((a, b) => {
          const na = normalizeHistoricalOrder(a);
          const nb = normalizeHistoricalOrder(b);
          return (nb.timestamp ?? 0) - (na.timestamp ?? 0);
        });
        historicalOrders.push(...all);
      }

      historicalOrdersLoaded = true;
      renderHistoricalOrders();
      updatePerformanceMetrics(currentRangeKey);
    } catch (err) {
      console.error("Historical orders error", err);
      historicalOrdersBodyEl.innerHTML = "<tr><td colspan='7' class='muted'>Failed to load historical orders.</td></tr>";
    }
  }

  async function loadHistoricalFills(wallets = currentWallets) {
    if (!historicalFillsBodyEl) return;
    const walletList = Array.isArray(wallets) ? wallets : [wallets];
    if (!walletList.length) return;

    historicalFillsLoaded = false;
    if (historicalFillsCountEl) historicalFillsCountEl.textContent = "â€“";
    historicalFillsBodyEl.innerHTML = "<tr><td colspan='6' class='muted'>Loading historical fillsâ€¦</td></tr>";

    try {
      const all = [];
      for (const wallet of walletList) {
        try {
          const fillsData = await infoClient.userFills({ user: wallet, aggregateByTime: true });
          if (Array.isArray(fillsData)) {
            fillsData.forEach((f) => {
              if (f && typeof f === "object") {
                f.wallet = wallet;
                const rawCoin = f.coin ?? f.asset ?? f.symbol ?? f.sym ?? "";
                if (rawCoin) f.marketType = getMarketTypeFromCoin(rawCoin);
              }
            });
            all.push(...fillsData);
          }
        } catch (err) {
          console.error(`Historical fills error for ${wallet}`, err);
        }
      }

      historicalFills.length = 0;
      if (Array.isArray(all)) {
        all
          .sort((a, b) => (Number(b.time ?? b.timestamp ?? 0) - Number(a.time ?? a.timestamp ?? 0)))
          .forEach((f) => historicalFills.push(f));
      }

      historicalFillsLoaded = true;
      renderHistoricalFills();
      updatePerformanceMetrics(currentRangeKey);
    } catch (err) {
      console.error("Historical fills error", err);
      if (historicalFillsBodyEl) {
        historicalFillsBodyEl.innerHTML = "<tr><td colspan='6' class='muted'>Failed to load historical fills.</td></tr>";
      }
      if (fillsErrorEl) fillsErrorEl.textContent = "Failed to load historical fills: " + (err?.message || err);
    }
  }

  function resetState() {
    Object.values(walletSnapshotsByType).forEach((map) => map.clear());
    Object.values(walletTotalsByType).forEach((map) => map.clear());
    Object.values(walletPositionsByType).forEach((map) => map.clear());
    openOrders.clear();
    canceledOrders.length = 0;
    fills.length = 0;
    currentAssetPositions = [];
    expandedPositions.clear();
    liveMids.clear();
    lastComputedUpnlTotal = 0;
    lastComputedTotalNotional = 0;

    historicalOrders.length = 0;
    historicalOrdersLoaded = false;
    historicalFills.length = 0;
    historicalFillsLoaded = false;

    openOrdersCountEl.textContent = "â€“";
    canceledCountEl.textContent = "â€“";
    if (historicalOrdersCountEl) historicalOrdersCountEl.textContent = "â€“";
    if (historicalFillsCountEl) historicalFillsCountEl.textContent = "â€“";
    if (fillsCountEl) fillsCountEl.textContent = "â€“";

    ordersErrorEl.textContent = "";
    fillsErrorEl.textContent = "";
    snapshotErrorEl.textContent = "";

    openOrdersBodyEl.innerHTML = "<tr><td colspan='8' class='muted'>Loading open ordersâ€¦</td></tr>";
    canceledOrdersBodyEl.innerHTML = "<tr><td colspan='7' class='muted'>No canceled orders yet.</td></tr>";
    fillsBodyEl.innerHTML = "<tr><td colspan='7' class='muted'>Waiting for fillsâ€¦</td></tr>";

    if (historicalOrdersBodyEl) {
      historicalOrdersBodyEl.innerHTML = "<tr><td colspan='7' class='muted'>Loading historical ordersâ€¦</td></tr>";
    }
    if (historicalFillsBodyEl) {
      historicalFillsBodyEl.innerHTML = "<tr><td colspan='6' class='muted'>Loading historical fillsâ€¦</td></tr>";
    }

    const positionsColspan = getPositionsColspan();
    positionsBodyEl.innerHTML = `<tr class='loading-row'><td colspan='${positionsColspan}' class='muted'>Loadingâ€¦</td></tr>`;
    marginSummaryEl.innerHTML = "<span class='muted'>Loadingâ€¦</span>";

    refreshBreakdownIfOpen();
  }

  async function initClients() {
    if (!infoClient) infoClient = new hl.InfoClient({ transport: new hl.HttpTransport() });
    if (!subsClient) subsClient = new hl.SubscriptionClient({ transport: new hl.WebSocketTransport() });
  }

  async function ensurePriceStream() {
    if (!subsClient || allMidsSub) return;
    try {
      allMidsSub = await subsClient.allMids((event) => {
        let mids = event;
        if (event && typeof event === "object") {
          if ("data" in event && event.data) mids = event.data;
          if (mids && typeof mids === "object" && "mids" in mids) mids = mids.mids;
        }
        if (!mids || typeof mids !== "object") return;

        for (const [coin, midStr] of Object.entries(mids)) {
          const px = Number(midStr);
          if (!Number.isNaN(px)) liveMids.set(coin, px);
        }

        renderFooterPrices();

        if (currentAssetPositions.length) renderPositions(currentAssetPositions);
      });
    } catch (err) {
      console.error("allMids subscription error", err);
    }
  }

  async function initFooterStream() {
    await ensurePriceStream();
    applyFooterChangeVisibility();
    await refreshFooterChanges();
    ensureFooterChangeTimer();
    await sanitizeFooterCoins();
    await primeManualMidsForFooter();
    renderFooterPrices();
    updateFooterActionLabel();
  }

  async function loadSnapshot(wallet) {
    try {
      snapshotErrorEl.textContent = "";
      const clearing = await infoClient.clearinghouseState({ user: wallet });
      const { marginSummary, withdrawable, assetPositions } = clearing;
      const mergedPositions = Array.isArray(assetPositions)
        ? assetPositions.map((pos) => ({ ...pos, wallet, marketType: "perp" }))
        : [];

      walletSnapshotsByType.perp.set(wallet, {
        summary: marginSummary || null,
        withdrawable,
        snapshotUpnlTotal: computeSnapshotUpnlTotal(mergedPositions),
      });

      setWalletPositions("perp", wallet, mergedPositions);

      // Fetch HIP-3/extra dex positions after first paint
      fetchAdditionalDexPositions(wallet).then((extraPositions) => {
        if (!Array.isArray(extraPositions) || extraPositions.length === 0) return;
        const combined = [
          ...mergedPositions,
          ...extraPositions.map((pos) => ({ ...pos, wallet, marketType: "perp" })),
        ];
        walletSnapshotsByType.perp.set(wallet, {
          summary: marginSummary || null,
          withdrawable,
          snapshotUpnlTotal: computeSnapshotUpnlTotal(combined),
        });
        setWalletPositions("perp", wallet, combined);
      });

      const existingOpen = await infoClient.frontendOpenOrders({ user: wallet });
      existingOpen.forEach((order) => {
        const key = `${wallet}:${order.oid}`;
        const rawCoin = order.coin ?? order.asset ?? order.symbol ?? order.sym ?? "";
        openOrders.set(key, { ...order, wallet, marketType: getMarketTypeFromCoin(rawCoin) });
      });
      renderOpenOrders();
    } catch (err) {
      console.error("Snapshot error", err);
      snapshotErrorEl.textContent = "Failed to load initial snapshot: " + (err?.message || err);
    }
  }

  async function startStreams(wallets = currentWallets) {
    try {
      ordersErrorEl.textContent = "";
      fillsErrorEl.textContent = "";
      const walletList = Array.isArray(wallets) ? wallets : [wallets];

      for (const sub of orderUpdatesSubs.values()) {
        try { await sub.unsubscribe(); } catch (e) { console.warn("Error unsubscribing orderUpdates", e); }
      }
      for (const sub of userEventsSubs.values()) {
        try { await sub.unsubscribe(); } catch (e) { console.warn("Error unsubscribing userEvents", e); }
      }
      orderUpdatesSubs.clear();
      userEventsSubs.clear();

      await Promise.all(
        walletList.map(async (wallet) => {
          const orderSub = await subsClient.orderUpdates({ user: wallet }, (event) => {
            try {
              const updates = event?.data ?? event;
              if (!Array.isArray(updates)) return;

              updates.forEach((entry) => {
                const status = entry.status;
                const orderWrapper = entry.order;
                const statusTimestamp = entry.statusTimestamp;
                if (!orderWrapper) return;

                const rawCoin = orderWrapper?.coin ?? orderWrapper?.asset ?? orderWrapper?.symbol ?? orderWrapper?.sym ?? "";
                const order = { ...orderWrapper, status, statusTimestamp, wallet, marketType: getMarketTypeFromCoin(rawCoin) };
                const key = `${wallet}:${order.oid}`;

                if (status === "open") {
                  openOrders.set(key, order);
                  renderOpenOrders();
                } else if (status === "canceled") {
                  openOrders.delete(key);
                  renderOpenOrders();
                  canceledOrders.unshift(order);
                  renderCanceledOrders();
                } else if (status === "filled" || status === "closed" || status === "rejected") {
                  openOrders.delete(key);
                  renderOpenOrders();
                }
              });
            } catch (err) {
              console.error("orderUpdates handler error", err);
              ordersErrorEl.textContent = "Error processing order updates: " + (err?.message || err);
            }
          });
          orderUpdatesSubs.set(wallet, orderSub);

          const userSub = await subsClient.userEvents({ user: wallet }, (event) => {
            try {
              const data = event?.data ?? event;
              const fillsArr = Array.isArray(data?.fills) ? data.fills : [];
              if (fillsArr.length === 0) return;

              fillsArr.forEach((fill) => {
                const rawCoin = fill.coin ?? fill.asset ?? fill.symbol ?? fill.sym ?? "";
                const enriched = { ...fill, wallet, marketType: getMarketTypeFromCoin(rawCoin) };
                fills.unshift(enriched);
              });
              if (fills.length > MAX_FILL_ROWS) fills.length = MAX_FILL_ROWS;
              renderFills();
              updatePerformanceMetrics(currentRangeKey);

              refreshPositionsAndMargin(wallet);
              if (currentMarketType === "spot") {
                refreshSpotPositionsAndSummary(wallet);
              }
            } catch (err) {
              console.error("userEvents handler error", err);
              fillsErrorEl.textContent = "Error processing fills: " + (err?.message || err);
            }
          });
          userEventsSubs.set(wallet, userSub);
        })
      );

      setStatus("connected", "Connected to");
    } catch (err) {
      console.error("WebSocket setup error", err);
      setStatus("error", "WebSocket error");
      ordersErrorEl.textContent = "Failed to start real-time streams: " + (err?.message || err);
    }
  }

  function isValidAddress(addr) {
    return /^0x[a-fA-F0-9]{40}$/.test(addr);
  }

  function setPortfolioLoadingState(isLoading, message) {
    if (portfolioLoadingWrapEl) {
      portfolioLoadingWrapEl.classList.toggle("loading", Boolean(isLoading));
    }
    if (performanceToolbarEl) {
      performanceToolbarEl.classList.toggle("is-hidden", Boolean(isLoading));
    }
    if (performanceActionsEl) {
      performanceActionsEl.classList.toggle("is-hidden", Boolean(isLoading));
    }
    if (portfolioLoadingEl) {
      portfolioLoadingEl.textContent = message || "";
    }
    if (metricsCardEl) {
      metricsCardEl.classList.toggle("loading", Boolean(isLoading));
    }
  }

  function resetPortfolioSection() {
    portfolioDataByWallet.clear();
    portfolioErrorEl.textContent = "";
    setPortfolioLoadingState(true, "Loading performance graphsâ€¦");
    clearPerformanceMetrics();
    if (portfolioCharts.equity) {
      portfolioCharts.equity.destroy();
      portfolioCharts.pnl.destroy();
      portfolioCharts.deposits.destroy();
      portfolioCharts.equity = null;
      portfolioCharts.pnl = null;
      portfolioCharts.deposits = null;
    }
  }

  async function fetchPortfolio(wallet) {
    const body = { type: "portfolio", user: wallet };

    const res = await fetch(PORTFOLIO_API_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });

    if (!res.ok) throw new Error(`Portfolio API error: ${res.status} ${res.statusText}`);

    const raw = await res.json();

    if (Array.isArray(raw)) {
      const obj = {};
      for (const [key, value] of raw) obj[key] = value;
      return obj;
    }

    return raw;
  }

  function buildViewFromSection(section) {
    if (!section) return null;
    const equityHist = section.accountValueHistory || [];
    const pnlHist = section.pnlHistory || [];
    if (!equityHist.length || !pnlHist.length) return null;

    const times = equityHist.map(([t]) => new Date(Number(t)));
    const equity = equityHist.map(([, v]) => Number(v ?? 0));
    const pnl = pnlHist.map(([, v]) => Number(v ?? 0));

    const rawDeposits = equity.map((eq, i) => (eq - (pnl[i] ?? 0)));

    const base = Number.isFinite(rawDeposits[0]) ? rawDeposits[0] : 0;
    const deposits = rawDeposits.map((d) => Math.round((d - base) * 100) / 100);

    return { times, equity, pnl, deposits, rawDeposits };
  }

  function toPerpKey(rangeKey) {
    if (!rangeKey) return "";
    return "perp" + rangeKey.charAt(0).toUpperCase() + rangeKey.slice(1);
  }

  function deriveSpotHistory(allHist, perpHist) {
    if (!Array.isArray(allHist) || !Array.isArray(perpHist)) return [];
    const perpMap = new Map(
      perpHist
        .map(([t, v]) => [Number(t), Number(v ?? 0)])
        .filter(([t]) => Number.isFinite(t))
    );
    return allHist
      .map(([t, v]) => {
        const time = Number(t);
        const allVal = Number(v ?? 0);
        if (!Number.isFinite(time) || !Number.isFinite(allVal)) return null;
        const perpVal = perpMap.get(time) ?? 0;
        return [time, allVal - perpVal];
      })
      .filter(Boolean);
  }

  function deriveSpotSection(allSection, perpSection) {
    if (!allSection || !perpSection) return null;
    const accountValueHistory = deriveSpotHistory(
      allSection.accountValueHistory || [],
      perpSection.accountValueHistory || []
    );
    const pnlHistory = deriveSpotHistory(
      allSection.pnlHistory || [],
      perpSection.pnlHistory || []
    );
    if (!accountValueHistory.length || !pnlHistory.length) return null;
    return { accountValueHistory, pnlHistory };
  }

  function getPortfolioSection(data, rangeKey, marketType = currentMarketType) {
    if (!data) return null;
    const allKey = rangeKey;
    const perpKey = toPerpKey(rangeKey);
    const allSection = data?.[allKey] || data?.allTime || null;
    const perpSection = data?.[perpKey] || data?.perpAllTime || data?.perpAll || null;

    if (marketType === "all") return allSection || perpSection || null;
    if (marketType === "perp") return perpSection || allSection || null;
    if (marketType === "spot") return deriveSpotSection(allSection, perpSection);
    return allSection || null;
  }

  function getPortfolioView(rangeKey, wallet, marketType = currentMarketType) {
    if (!portfolioDataByWallet.size) return null;
    const data = portfolioDataByWallet.get(wallet);
    if (!data) return null;
    const primary = getPortfolioSection(data, rangeKey, marketType);
    const fallback = getPortfolioSection(data, "allTime", marketType);
    return buildViewFromSection(primary) || buildViewFromSection(fallback) || null;
  }

  function buildLabels(times, rangeKey) {
    const showTimeOnly = rangeKey === "day";
    return times.map((d) => {
      if (!(d instanceof Date) || isNaN(d.getTime())) return "";
      if (showTimeOnly) return d.toLocaleTimeString(undefined, { hour: "2-digit", minute: "2-digit" });
      return d.toLocaleDateString();
    });
  }

  function getChartGridColor() {
    return document.body.classList.contains("light")
      ? "rgba(31,41,55,0.2)"
      : "rgba(31,41,55,0.6)";
  }

  function getChartTextColor() {
    return document.body.classList.contains("light") ? "#0f172a" : "#e5e7eb";
  }

  function getWalletColor(wallet) {
    if (!walletColorMap.has(wallet)) {
      const color = WALLET_COLOR_PALETTE[walletColorMap.size % WALLET_COLOR_PALETTE.length];
      walletColorMap.set(wallet, color);
    }
    return walletColorMap.get(wallet);
  }

  function getNormalizedWeights(wallets) {
    if (!wallets.length) return [];
    const equal = 1 / wallets.length;
    return wallets.map(() => equal);
  }

  function buildPositionBreakdown() {
    if (!Array.isArray(currentAssetPositions) || currentAssetPositions.length === 0) return [];

    return currentAssetPositions
      .map((item) => {
        const p = item.position;
        const coin = p.coin;
        const { base: coinBase } = splitDexCoin(coin);
        const szi = Number(p.szi ?? 0);
        if (!coin || !Number.isFinite(szi) || szi === 0) return null;

        const entryPx = Number(p.entryPx ?? 0);
        const livePx = getLivePriceForCoin(coin);
        let markPx = Number.isFinite(livePx) ? livePx : undefined;

        const snapshotValue = Number(p.positionValue ?? 0);
        if ((markPx === undefined || Number.isNaN(markPx)) && !Number.isNaN(snapshotValue) && szi !== 0) {
          markPx = Math.abs(snapshotValue) / Math.abs(szi);
        }

        let positionValue = snapshotValue;
        if (markPx !== undefined && !Number.isNaN(markPx) && szi !== 0) {
          positionValue = markPx * szi;
        } else if (Number.isFinite(entryPx) && szi !== 0) {
          positionValue = entryPx * szi;
        }

        const valueAbs = Math.abs(positionValue);
        if (!Number.isFinite(valueAbs) || valueAbs === 0) return null;

        const dirLabel = szi > 0 ? "" : " (short)";
        const labelCoin = coinBase || coin;
        return { label: `${labelCoin}${dirLabel}`, value: valueAbs, coin: labelCoin };
      })
      .filter(Boolean);
  }

  function updatePortfolioBreakdownChart() {
    if (!portfolioDoughnutCanvas) return;

    const positions = buildPositionBreakdown();
    const positionsValue = positions.reduce((sum, p) => sum + (p?.value ?? 0), 0);
    const withdrawableValue = Math.max(0, getWithdrawableAmount());

    if (positionsValueStatEl) positionsValueStatEl.textContent = fmtMoney(positionsValue);
    if (withdrawableValueStatEl) withdrawableValueStatEl.textContent = fmtMoney(withdrawableValue);

    const rawSeries = [
      ...positions,
      { label: "Withdrawable", value: withdrawableValue },
    ].filter((item) => Number.isFinite(item.value));

    const dataValues = rawSeries.map((p) => Math.max(0, p.value));
    const labels = rawSeries.map((p) => p.label);
    const realValues = rawSeries.map((p) => p.value);

    const allZero = dataValues.every((v) => v === 0);
    const displayValues = allZero ? dataValues.map(() => 1) : dataValues;
    const totalReal = realValues.reduce((sum, v) => sum + (Number.isFinite(v) ? Math.max(0, v) : 0), 0);

    const coinColors = {
      BTC: "#f7931a",
      ETH: "#1c3f91",
      SOL: "#6f42c1",
      BNB: "#f0b90b",
      HYPE: "#0b5c2f",
      LINK: "#2a5ada",
    };
    const palette = ["#38bdf8", "#26d97f", "#a78bfa", "#f472b6", "#facc15", "#fb7185", "#22d3ee", "#f59e0b"];
    const colors = rawSeries.map((item, i) => {
      const coin = (item.coin || "").toUpperCase();
      if (coin && coinColors[coin]) return coinColors[coin];
      return palette[i % palette.length];
    });
    const textColor = getChartTextColor();
    const tooltipBg = "rgba(0,0,0,0.7)";

    if (!portfolioBreakdownChart.chart) {
      portfolioBreakdownChart.chart = new Chart(portfolioDoughnutCanvas.getContext("2d"), {
        type: "doughnut",
        data: {
          labels,
          datasets: [
            {
              data: displayValues,
              realValues: realValues,
              backgroundColor: colors,
              borderColor: colors.map((c) => c + "99"),
              borderWidth: 1,
              hoverOffset: 6,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          cutout: "62%",
          plugins: {
            legend: { position: "bottom", labels: { color: textColor } },
            tooltip: {
              backgroundColor: tooltipBg,
              borderColor: "rgba(148, 163, 184, 0.4)",
              borderWidth: 1,
              displayColors: false,
              callbacks: {
                label: (ctx) => {
                  const real = ctx.dataset.realValues?.[ctx.dataIndex];
                  const val = Number.isFinite(real) ? real : ctx.parsed;
                  const pct = totalReal > 0 ? (Math.max(0, val) / totalReal) * 100 : 0;
                  return `${ctx.label}: ${fmtMoney(val)} (${pct.toFixed(1)}%)`;
                },
              },
            },
          },
        },
      });
    } else {
      const chart = portfolioBreakdownChart.chart;
      chart.data.labels = labels;
      chart.data.datasets[0].data = displayValues;
      chart.data.datasets[0].realValues = realValues;
      chart.data.datasets[0].backgroundColor = colors;
      chart.data.datasets[0].borderColor = colors.map((c) => c + "99");
      chart.options.plugins.legend.labels.color = textColor;
      chart.options.plugins.tooltip.backgroundColor = tooltipBg;
      chart.update();
    }
  }

  function refreshBreakdownIfOpen() {
    if (portfolioModalEl && portfolioModalEl.classList.contains("open")) {
      updatePortfolioBreakdownChart();
    }
  }

  function updateBreakdownTheme() {
    if (!portfolioBreakdownChart.chart) return;
    const textColor = getChartTextColor();
    const tooltipBg = "rgba(0,0,0,0.7)";
    portfolioBreakdownChart.chart.options.plugins.legend.labels.color = textColor;
    portfolioBreakdownChart.chart.options.plugins.tooltip.backgroundColor = tooltipBg;
    portfolioBreakdownChart.chart.update();
  }

  function getWalletViews(rangeKey, marketType = currentMarketType) {
    return currentWallets
      .map((wallet) => {
        const view = getPortfolioView(rangeKey, wallet, marketType);
        return view ? { wallet, view } : null;
      })
      .filter(Boolean);
  }

  function buildWalletDatasets(views, labels, key, colorOverride) {
    return views.map(({ wallet, view }) => {
      const color = colorOverride || getWalletColor(wallet);
      const values = Array.isArray(view?.[key]) ? view[key] : [];
      return {
        label: formatWalletLabel(wallet),
        data: values.slice(0, labels.length),
        borderColor: color,
        backgroundColor: color + "2a",
        pointRadius: 0,
        borderWidth: 1.7,
        tension: 0.25,
      };
    });
  }

  function buildWeightedSeries(views, labels, key) {
    if (views.length < 2) return null;
    const weights = getNormalizedWeights(views.map((v) => v.wallet));
    const values = labels.map((_, idx) => {
      return views.reduce((sum, entry, entryIdx) => {
        const series = entry.view?.[key] || [];
        const val = Number(series[idx] ?? 0);
        return sum + (Number.isFinite(val) ? val * weights[entryIdx] : 0);
      }, 0);
    });
    return {
      label: "Weighted",
      data: values,
      borderColor: "#f8fafc",
      backgroundColor: "rgba(248, 250, 252, 0.08)",
      pointRadius: 0,
      borderWidth: 2.4,
      tension: 0.25,
    };
  }

  function detectOrderType(order) {
    const rawType = order?.orderType ?? order?.type ?? order?.order_type;
    if (typeof rawType === "string") {
      const lower = rawType.toLowerCase();
      if (lower.includes("market")) return "market";
      if (lower.includes("limit")) return "limit";
    }
    if (rawType && typeof rawType === "object") {
      const t = rawType.t ?? rawType.type ?? rawType.orderType;
      if (typeof t === "string") {
        const lower = t.toLowerCase();
        if (lower.includes("market")) return "market";
        if (lower.includes("limit")) return "limit";
      }
      if (rawType.isMarket === true) return "market";
    }
    const tif = order?.tif ?? order?.timeInForce;
    if (typeof tif === "string" && tif.toLowerCase().includes("ioc")) return "market";
    return "";
  }

  function normalizeFillForMetrics(fill) {
    if (!fill || typeof fill !== "object") return null;
    const time = normalizeTimestamp(fill.time ?? fill.timestamp);
    if (!time) return null;
    const sideRaw =
      fill.side ??
      (fill.isBuy !== undefined ? (fill.isBuy ? "B" : "S") : undefined) ??
      fill.dir ??
      fill.direction ??
      "";
    const sideUpper = String(sideRaw).toUpperCase();
    let side = "";
    if (sideUpper.startsWith("B") || sideUpper === "1" || sideUpper === "+1") side = "B";
    else if (sideUpper.startsWith("S") || sideUpper.startsWith("A") || sideUpper === "-1") side = "S";

    const sizeCandidates = [
      fill.szi,
      fill.sz,
      fill.size,
      fill.qty,
      fill.quantity,
      fill.baseSz,
      fill.baseSize,
    ];
    let size = 0;
    for (const cand of sizeCandidates) {
      const n = Number(cand);
      if (!Number.isNaN(n)) {
        size = n;
        break;
      }
    }

    if (!side) {
      if (size > 0) side = "B";
      if (size < 0) side = "S";
    }

    const price = Number(fill.px ?? fill.price ?? 0);
    const rawCoin = fill.coin ?? fill.asset ?? fill.symbol ?? fill.sym ?? "";
    const coin = resolveCoinName(rawCoin, fill.asset ?? fill.symbol ?? fill.sym);
    const wallet = fill.wallet || primaryWallet;
    const oid = fill.oid ?? fill.orderId ?? fill.order_id ?? "";

    return {
      time,
      side,
      size: Math.abs(size),
      price: Number.isFinite(price) ? price : null,
      coin,
      marketType: getMarketTypeFromCoin(rawCoin),
      wallet,
      oid,
    };
  }

  function normalizeOrderObject(order, overrides = {}) {
    if (!order || typeof order !== "object") return null;
    const timestamp = normalizeTimestamp(overrides.timestamp ?? order.timestamp);
    const status = String(overrides.status ?? order.status ?? "").toLowerCase();
    const side = order.side ?? (order.isBuy ? "B" : "S") ?? "";
    const rawCoin = order.coin ?? order.asset ?? order.symbol ?? order.sym ?? "";
    const coin = resolveCoinName(rawCoin, order.asset ?? order.symbol ?? order.sym);
    return {
      wallet: overrides.wallet ?? order.wallet ?? "",
      oid: pickOrderId(null, order) || "",
      timestamp,
      status,
      side,
      coin,
      marketType: getMarketTypeFromCoin(rawCoin),
      type: detectOrderType(order),
    };
  }

  function normalizeHistoricalOrderForMetrics(entry) {
    const normalized = normalizeHistoricalOrder(entry);
    const raw = normalized.raw?.order ?? normalized.raw ?? entry?.order ?? entry ?? {};
    return normalizeOrderObject(raw, {
      wallet: normalized.wallet ?? raw.wallet ?? "",
      status: normalized.status ?? raw.status ?? "",
      timestamp: normalized.timestamp ?? raw.timestamp,
    });
  }

  function getAllFillsForMetrics({ walletSet, startTime, endTime, marketType = currentMarketType } = {}) {
    const combined = [];
    const pushFrom = (arr) => {
      if (!Array.isArray(arr)) return;
      arr.forEach((fill) => {
        const normalized = normalizeFillForMetrics(fill);
        if (normalized) combined.push(normalized);
      });
    };
    pushFrom(historicalFills);
    pushFrom(fills);

    const seen = new Set();
    const unique = [];
    combined.forEach((f) => {
      if (marketType && marketType !== "all" && f.marketType && f.marketType !== marketType) return;
      if (walletSet && f.wallet && !walletSet.has(String(f.wallet).toLowerCase())) return;
      if (Number.isFinite(startTime) && f.time < startTime) return;
      if (Number.isFinite(endTime) && f.time > endTime) return;
      const key = [
        f.wallet || "",
        f.oid || "",
        f.time,
        f.side,
        f.size,
        f.price,
        f.coin || "",
      ].join("|");
      if (seen.has(key)) return;
      seen.add(key);
      unique.push(f);
    });

    return unique.sort((a, b) => a.time - b.time);
  }

  function getAllOrdersForMetrics({ walletSet, startTime, endTime, marketType = currentMarketType } = {}) {
    const combined = [];
    if (Array.isArray(historicalOrders)) {
      historicalOrders.forEach((entry) => {
        const normalized = normalizeHistoricalOrderForMetrics(entry);
        if (normalized) combined.push(normalized);
      });
    }

    openOrders.forEach((order) => {
      const normalized = normalizeOrderObject(order, {
        wallet: order.wallet ?? "",
        status: order.status ?? "open",
      });
      if (normalized) combined.push(normalized);
    });

    canceledOrders.forEach((order) => {
      const normalized = normalizeOrderObject(order, {
        wallet: order.wallet ?? "",
        status: order.status ?? "canceled",
        timestamp: order.statusTimestamp ?? order.timestamp,
      });
      if (normalized) combined.push(normalized);
    });

    const seen = new Set();
    const unique = [];
    combined.forEach((o) => {
      if (marketType && marketType !== "all" && o.marketType && o.marketType !== marketType) return;
      const walletKey = o.wallet ? String(o.wallet).toLowerCase() : "";
      if (walletSet && walletKey && !walletSet.has(walletKey)) return;
      if (Number.isFinite(startTime) && Number.isFinite(o.timestamp) && o.timestamp < startTime) return;
      if (Number.isFinite(endTime) && Number.isFinite(o.timestamp) && o.timestamp > endTime) return;
      const key = [
        o.wallet || "",
        o.oid || "",
        o.timestamp ?? "",
        o.status,
      ].join("|");
      if (seen.has(key)) return;
      seen.add(key);
      unique.push(o);
    });

    return unique.sort((a, b) => (a.timestamp ?? 0) - (b.timestamp ?? 0));
  }

  function computeObservedDays(times) {
    if (!Array.isArray(times) || times.length === 0) return 0;
    const valid = times.filter((t) => Number.isFinite(t));
    if (!valid.length) return 0;
    const min = Math.min(...valid);
    const max = Math.max(...valid);
    const diff = Math.max(0, max - min);
    return Math.max(1, Math.floor(diff / 86400000) + 1);
  }

  function computeMedian(values) {
    if (!Array.isArray(values) || values.length === 0) return null;
    const sorted = [...values].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    if (sorted.length % 2 === 0) return (sorted[mid - 1] + sorted[mid]) / 2;
    return sorted[mid];
  }

  function getFillSideAndSize(fill) {
    const sideRaw =
      fill.side ??
      (fill.isBuy !== undefined ? (fill.isBuy ? "B" : "S") : undefined) ??
      fill.dir ??
      fill.direction ??
      "?";
    const sideUpper = String(sideRaw).toUpperCase();
    let side = "?";
    if (sideUpper.startsWith("B") || sideUpper === "1" || sideUpper === "+1") side = "B";
    else if (
      sideUpper.startsWith("S") ||
      sideUpper.startsWith("A") ||
      sideUpper === "-1" ||
      sideUpper === "SELL" ||
      sideUpper === "SHORT"
    )
      side = "S";

    const sizeCandidates = [fill.szi, fill.sz, fill.size, fill.qty, fill.quantity, fill.baseSz, fill.baseSize];
    let sizeRaw = 0;
    for (const cand of sizeCandidates) {
      const n = Number(cand);
      if (!Number.isNaN(n)) {
        sizeRaw = n;
        break;
      }
    }

    if (side === "?") {
      if (sizeRaw > 0) side = "B";
      else if (sizeRaw < 0) side = "S";
    }

    const sizeAbs = Math.abs(sizeRaw);
    const sideSign = side === "B" ? 1 : side === "S" ? -1 : 0;
    return { side, sideSign, sizeAbs };
  }

  function computeHoldingStats(fillsForStats) {
    const lotsByCoin = new Map();
    const lifecyclePnlByCoin = new Map();
    const holdingTimes = [];
    let realizedPnl = 0;
    let wins = 0;
    let closedCount = 0;
    let sumPositive = 0;
    let sumNegative = 0;

    const sorted = [...fillsForStats].sort((a, b) => a.time - b.time);
    sorted.forEach((fill) => {
      const { sideSign, sizeAbs } = getFillSideAndSize(fill);
      const price = Number(fill.price ?? 0);
      if (!sideSign || !Number.isFinite(sizeAbs) || sizeAbs <= 0 || !Number.isFinite(price)) return;
      const coin = fill.coin || "";
      const time = Number(fill.time ?? 0);
      if (!Number.isFinite(time)) return;

      const key = coin || "__unknown__";
      const lots = lotsByCoin.get(key) || [];
      let remaining = sizeAbs;
      let matchedAny = false;
      let lifecyclePnl = lifecyclePnlByCoin.get(key) || 0;

      while (remaining > 0 && lots.length > 0 && lots[0].sideSign !== sideSign) {
        const lot = lots[0];
        const matchSize = Math.min(remaining, lot.size);
        const duration = Math.max(0, time - lot.time);
        holdingTimes.push(duration);
        const pnl = (price - lot.price) * matchSize * lot.sideSign;
        realizedPnl += pnl;
        lifecyclePnl += pnl;
        matchedAny = true;
        if (pnl > 0) {
          sumPositive += pnl;
        } else if (pnl < 0) {
          sumNegative += pnl;
        }

        lot.size -= matchSize;
        remaining -= matchSize;
        if (lot.size <= 0) lots.shift();
      }

      if (matchedAny && lots.length === 0) {
        if (lifecyclePnl > 0) {
          wins += 1;
          closedCount += 1;
        } else if (lifecyclePnl < 0) {
          closedCount += 1;
        }
        lifecyclePnl = 0;
      }

      if (remaining > 0) {
        lots.push({ sideSign, size: remaining, price, time });
      }

      lotsByCoin.set(key, lots);
      lifecyclePnlByCoin.set(key, lifecyclePnl);
    });

    const totalExposureTime = holdingTimes.reduce((sum, v) => sum + v, 0);
    const medianHoldingTime = computeMedian(holdingTimes);
    const winRate = closedCount ? wins / closedCount : null;
    const profitFactor =
      sumNegative < 0
        ? sumPositive / Math.abs(sumNegative)
        : sumPositive > 0
          ? Infinity
          : null;

    return {
      realizedPnl,
      winRate,
      profitFactor,
      totalExposureTime,
      medianHoldingTime,
      closedCount,
      wins,
    };
  }

  function computeTradeOrderMetrics({ startTime, endTime, walletSet, marketType = currentMarketType } = {}) {
    const fillsForStats = getAllFillsForMetrics({ walletSet, startTime, endTime, marketType });
    const ordersForStats = getAllOrdersForMetrics({ walletSet, startTime, endTime, marketType });

    if (!fillsForStats.length && !ordersForStats.length) return null;

    const tradeTimes = fillsForStats.map((f) => f.time).filter(Number.isFinite);
    const orderTimes = ordersForStats.map((o) => o.timestamp).filter(Number.isFinite);
    let observedDays = computeObservedDays(tradeTimes.length ? tradeTimes : orderTimes);
    if (Number.isFinite(startTime) && Number.isFinite(endTime) && endTime >= startTime) {
      observedDays = Math.max(1, Math.floor((endTime - startTime) / 86400000) + 1);
    }

    const tradeDays = new Set(tradeTimes.map(getLocalDayKey).filter(Boolean));
    const tradesPerDay = observedDays ? fillsForStats.length / observedDays : null;
    const ordersPerDay = observedDays ? ordersForStats.length / observedDays : null;
    const activeDaysCount = tradeDays.size;
    const activeDaysRatio = observedDays ? activeDaysCount / observedDays : null;

    const productNotional = new Map();
    const productSet = new Set();
    const notionals = [];
    let buyNotional = 0;
    let sellNotional = 0;

    fillsForStats.forEach((fill) => {
      const price = Number(fill.price ?? 0);
      const size = Number(fill.size ?? 0);
      if (!Number.isFinite(price) || !Number.isFinite(size) || size <= 0) return;
      const notional = Math.abs(price * size);
      if (!Number.isFinite(notional)) return;
      const coin = fill.coin || "";
      if (coin) productSet.add(coin);
      notionals.push(notional);
      if (coin) productNotional.set(coin, (productNotional.get(coin) || 0) + notional);
      if (fill.side === "B") buyNotional += notional;
      if (fill.side === "S") sellNotional += notional;
    });

    const totalNotional = notionals.reduce((sum, v) => sum + v, 0);
    let topProduct = null;
    let topProductShare = null;
    if (totalNotional > 0) {
      productNotional.forEach((value, coin) => {
        const share = value / totalNotional;
        if (topProductShare === null || share > topProductShare) {
          topProductShare = share;
          topProduct = coin;
        }
      });
    }

    let herfindahl = null;
    if (totalNotional > 0 && productNotional.size) {
      herfindahl = 0;
      productNotional.forEach((value) => {
        const share = value / totalNotional;
        herfindahl += share * share;
      });
    }

    const avgNotional = notionals.length ? totalNotional / notionals.length : null;
    let notionalCv = null;
    if (avgNotional && notionals.length) {
      const variance = notionals.reduce((sum, v) => sum + Math.pow(v - avgNotional, 2), 0) / notionals.length;
      const stddev = Math.sqrt(variance);
      notionalCv = avgNotional ? stddev / avgNotional : null;
    }

    const sideBiasTotal = buyNotional + sellNotional;
    const sideBias = sideBiasTotal > 0 ? (buyNotional - sellNotional) / sideBiasTotal : null;

    const canceledCount = ordersForStats.filter((o) => String(o.status || "").includes("cancel")).length;
    const totalOrders = ordersForStats.length;
    const cancelRatio = totalOrders ? canceledCount / totalOrders : null;

    const knownTypeOrders = ordersForStats.filter((o) => o.type);
    const marketOrders = knownTypeOrders.filter((o) => o.type === "market").length;
    const aggressiveness =
      knownTypeOrders.length > 0 ? marketOrders / totalOrders : null;

    const orderTimeIndex = new Map();
    ordersForStats.forEach((order) => {
      if (!order.oid || !Number.isFinite(order.timestamp)) return;
      const existing = orderTimeIndex.get(order.oid);
      if (!existing || order.timestamp < existing) orderTimeIndex.set(order.oid, order.timestamp);
    });

    const reactionTimes = [];
    fillsForStats.forEach((fill) => {
      if (!fill.oid) return;
      const submitTime = orderTimeIndex.get(fill.oid);
      if (!Number.isFinite(submitTime)) return;
      const delta = fill.time - submitTime;
      if (Number.isFinite(delta) && delta >= 0) reactionTimes.push(delta);
    });

    const reactionSpeed =
      reactionTimes.length > 0
        ? reactionTimes.reduce((sum, v) => sum + v, 0) / reactionTimes.length
        : null;

    const holdingStats = computeHoldingStats(fillsForStats);

    return {
      tradesPerDay,
      ordersPerDay,
      activeDaysCount,
      activeDaysRatio,
      productCount: productSet.size || null,
      topProductShare,
      topProduct,
      herfindahl,
      avgNotional,
      notionalCv,
      totalExposureTime: holdingStats.totalExposureTime,
      medianHoldingTime: holdingStats.medianHoldingTime,
      realizedPnl: holdingStats.realizedPnl,
      winRate: holdingStats.winRate,
      profitFactor: holdingStats.profitFactor,
      wins: holdingStats.wins,
      closedCount: holdingStats.closedCount,
      sideBias,
      aggressiveness,
      cancelRatio,
      reactionSpeed,
    };
  }

  function clearPerformanceMetrics() {
    const placeholders = [
      metricTotalPnlEl,
      metricReturnEl,
      metricMaxDrawdownEl,
      metricSharpeEl,
      metricVolatilityEl,
      metricBestIntervalEl,
      metricRealizedPnlEl,
      metricWinRateEl,
      metricProfitFactorEl,
      metricOrdersTradesPerDayEl,
      metricActiveDaysEl,
      metricActiveDaysCountEl,
      metricProductCountEl,
      metricHerfindahlEl,
      metricAvgNotionalEl,
      metricMedianHoldingEl,
      metricSideBiasEl,
      metricAggressivenessEl,
      metricCancelRatioEl,
      metricReactionSpeedEl,
      metricPnlStabilityEl,
      metricSkillPersistenceEl,
      metricExcessPnlEl,
      metricBetaAlphaEl,
    ];
    placeholders.forEach((el) => {
      if (!el) return;
      el.textContent = "-";
      el.classList.remove("positive", "negative");
      el.style.color = "";
    });
    if (metricsWalletLabelEl) metricsWalletLabelEl.textContent = "-";
  }

  function setPortfolioMetricsUnavailable() {
    setMetricValue(metricTotalPnlEl, "N/A", null);
    setMetricValue(metricReturnEl, "N/A", null);
    setMetricValue(metricMaxDrawdownEl, "N/A", null);
    setMetricValue(metricSharpeEl, "N/A", null);
    setMetricValue(metricVolatilityEl, "N/A", null);
    setMetricValue(metricBestIntervalEl, "N/A", null);
    setMetricValue(metricPnlStabilityEl, "N/A", null);
    setMetricValue(metricSkillPersistenceEl, "N/A", null);
    setMetricValue(metricExcessPnlEl, "N/A", null);
    setMetricValue(metricBetaAlphaEl, "N/A", null);
  }

  function getRangeLabel(rangeKey) {
    const labels = {
      day: "Day",
      week: "Week",
      month: "Month",
      allTime: "All Time",
    };
    return labels[rangeKey] || "All Time";
  }

  function setMetricValue(el, text, valueForTone) {
    if (!el) return;
    el.textContent = text || "-";
    el.classList.remove("positive", "negative");
    el.style.color = "";
    if (Number.isFinite(valueForTone)) {
      if (valueForTone > 0) el.classList.add("positive");
      if (valueForTone < 0) el.classList.add("negative");
    }
  }

  function setMetricScaledColor(el, value, min = 0, max = 1, invert = false) {
    if (!el) return;
    const clamped = Math.max(min, Math.min(max, value));
    const raw = max === min ? 0 : (clamped - min) / (max - min);
    const t = invert ? 1 - raw : raw;
    const red = Math.round(242 + (38 - 242) * t);
    const green = Math.round(95 + (217 - 95) * t);
    const blue = Math.round(92 + (127 - 92) * t);
    el.style.color = `rgb(${red}, ${green}, ${blue})`;
  }

  function getScaledColor(value, min = 0, max = 1, invert = false) {
    const n = Number(value);
    if (!Number.isFinite(n)) return "inherit";
    const clamped = Math.max(min, Math.min(max, n));
    const raw = max === min ? 0 : (clamped - min) / (max - min);
    const t = invert ? 1 - raw : raw;
    const red = Math.round(242 + (38 - 242) * t);
    const green = Math.round(95 + (217 - 95) * t);
    const blue = Math.round(92 + (127 - 92) * t);
    return `rgb(${red}, ${green}, ${blue})`;
  }

  function parseColorToRgb(color) {
    if (!color) return null;
    const raw = String(color).trim();
    const hexMatch = raw.match(/^#([a-f0-9]{6})$/i);
    if (hexMatch) {
      const hex = hexMatch[1];
      const r = parseInt(hex.slice(0, 2), 16);
      const g = parseInt(hex.slice(2, 4), 16);
      const b = parseInt(hex.slice(4, 6), 16);
      return { r, g, b };
    }
    const rgbMatch = raw.match(/rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i);
    if (rgbMatch) {
      return { r: Number(rgbMatch[1]), g: Number(rgbMatch[2]), b: Number(rgbMatch[3]) };
    }
    return null;
  }

  function isColorTooLight(color) {
    const rgb = parseColorToRgb(color);
    if (!rgb) return false;
    const { r, g, b } = rgb;
    const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
    return luminance > 0.82;
  }

  // Minimal QR generator adapted from qrcode-generator (MIT).
  function createQrCode(text) {
    const qr = qrcode(6, "L");
    qr.addData(text);
    qr.make();
    return qr;
  }

  function drawQrCode(ctx, text, x, y, size) {
    try {
      const qr = createQrCode(text);
      const count = qr.getModuleCount();
      const cell = Math.floor(size / count);
      const qrSize = cell * count;
      const offsetX = x + Math.floor((size - qrSize) / 2);
      const offsetY = y + Math.floor((size - qrSize) / 2);
      ctx.save();
      ctx.fillStyle = "rgba(245,245,255,0.7)";
      for (let row = 0; row < count; row += 1) {
        for (let col = 0; col < count; col += 1) {
          if (qr.isDark(row, col)) {
            ctx.fillRect(offsetX + col * cell, offsetY + row * cell, cell, cell);
          }
        }
      }
      ctx.restore();
    } catch (err) {
      console.error("QR render failed", err);
    }
  }

  // qrcode-generator (MIT) - minimal inlined build
  // https://github.com/kazuhikoarase/qrcode-generator
  function qrcode(typeNumber, errorCorrectLevel) {
    const PAD0 = 0xec;
    const PAD1 = 0x11;
    const _typeNumber = typeNumber;
    const _errorCorrectLevel = QRErrorCorrectLevel[errorCorrectLevel];
    const _modules = null;
    const _moduleCount = 0;
    const _dataCache = null;
    const _dataList = [];
    const qr = {};
    let modules = _modules;
    let moduleCount = _moduleCount;
    let dataCache = _dataCache;

    qr.addData = function (data) {
      const newData = new QR8bitByte(data);
      _dataList.push(newData);
      dataCache = null;
    };

    qr.isDark = function (row, col) {
      if (modules[row][col] != null) return modules[row][col];
      return false;
    };

    qr.getModuleCount = function () {
      return moduleCount;
    };

    qr.make = function () {
      if (_typeNumber < 1) {
        let typeNumber = 1;
        for (; typeNumber < 40; typeNumber++) {
          const rsBlocks = QRRSBlock.getRSBlocks(typeNumber, _errorCorrectLevel);
          const buffer = new QRBitBuffer();
          for (let i = 0; i < _dataList.length; i++) {
            const data = _dataList[i];
            buffer.put(data.mode, 4);
            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
            data.write(buffer);
          }
          let totalDataCount = 0;
          for (let i = 0; i < rsBlocks.length; i++) {
            totalDataCount += rsBlocks[i].dataCount;
          }
          if (buffer.getLengthInBits() <= totalDataCount * 8) break;
        }
        moduleCount = typeNumber * 4 + 17;
      } else {
        moduleCount = _typeNumber * 4 + 17;
      }
      modules = new Array(moduleCount);
      for (let row = 0; row < moduleCount; row++) {
        modules[row] = new Array(moduleCount);
        for (let col = 0; col < moduleCount; col++) {
          modules[row][col] = null;
        }
      }
      setupPositionProbePattern(0, 0);
      setupPositionProbePattern(moduleCount - 7, 0);
      setupPositionProbePattern(0, moduleCount - 7);
      setupPositionAdjustPattern();
      setupTimingPattern();
      setupTypeInfo(false, 0);
      if (_typeNumber >= 7) setupTypeNumber(false);
      if (dataCache == null) dataCache = createData(_typeNumber < 1 ? moduleCount : _typeNumber, _errorCorrectLevel, _dataList);
      mapData(dataCache, 0);
    };

    function setupPositionProbePattern(row, col) {
      for (let r = -1; r <= 7; r++) {
        if (row + r <= -1 || moduleCount <= row + r) continue;
        for (let c = -1; c <= 7; c++) {
          if (col + c <= -1 || moduleCount <= col + c) continue;
          if ((0 <= r && r <= 6 && (c === 0 || c === 6)) || (0 <= c && c <= 6 && (r === 0 || r === 6)) || (2 <= r && r <= 4 && 2 <= c && c <= 4)) {
            modules[row + r][col + c] = true;
          } else {
            modules[row + r][col + c] = false;
          }
        }
      }
    }

    function getBestMaskPattern() {
      let minLostPoint = 0;
      let pattern = 0;
      for (let i = 0; i < 8; i++) {
        setupTypeInfo(true, i);
        mapData(dataCache, i);
        const lostPoint = QRUtil.getLostPoint(qr);
        if (i === 0 || minLostPoint > lostPoint) {
          minLostPoint = lostPoint;
          pattern = i;
        }
      }
      return pattern;
    }

    function setupTimingPattern() {
      for (let r = 8; r < moduleCount - 8; r++) {
        if (modules[r][6] != null) continue;
        modules[r][6] = r % 2 === 0;
      }
      for (let c = 8; c < moduleCount - 8; c++) {
        if (modules[6][c] != null) continue;
        modules[6][c] = c % 2 === 0;
      }
    }

    function setupPositionAdjustPattern() {
      const pos = QRUtil.getPatternPosition(_typeNumber < 1 ? moduleCount : _typeNumber);
      for (let i = 0; i < pos.length; i++) {
        for (let j = 0; j < pos.length; j++) {
          const row = pos[i];
          const col = pos[j];
          if (modules[row][col] != null) continue;
          for (let r = -2; r <= 2; r++) {
            for (let c = -2; c <= 2; c++) {
              if (r === -2 || r === 2 || c === -2 || c === 2 || (r === 0 && c === 0)) {
                modules[row + r][col + c] = true;
              } else {
                modules[row + r][col + c] = false;
              }
            }
          }
        }
      }
    }

    function setupTypeNumber(test) {
      const bits = QRUtil.getBCHTypeNumber(_typeNumber);
      for (let i = 0; i < 18; i++) {
        const mod = !test && ((bits >> i) & 1) === 1;
        modules[Math.floor(i / 3)][(i % 3) + moduleCount - 8 - 3] = mod;
      }
      for (let i = 0; i < 18; i++) {
        const mod = !test && ((bits >> i) & 1) === 1;
        modules[(i % 3) + moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
      }
    }

    function setupTypeInfo(test, maskPattern) {
      const data = (_errorCorrectLevel << 3) | maskPattern;
      const bits = QRUtil.getBCHTypeInfo(data);
      for (let i = 0; i < 15; i++) {
        const mod = !test && ((bits >> i) & 1) === 1;
        if (i < 6) modules[i][8] = mod;
        else if (i < 8) modules[i + 1][8] = mod;
        else modules[moduleCount - 15 + i][8] = mod;
      }
      for (let i = 0; i < 15; i++) {
        const mod = !test && ((bits >> i) & 1) === 1;
        if (i < 8) modules[8][moduleCount - i - 1] = mod;
        else if (i < 9) modules[8][15 - i - 1 + 1] = mod;
        else modules[8][15 - i - 1] = mod;
      }
      modules[moduleCount - 8][8] = !test;
    }

    function mapData(data, maskPattern) {
      let inc = -1;
      let row = moduleCount - 1;
      let bitIndex = 7;
      let byteIndex = 0;
      for (let col = moduleCount - 1; col > 0; col -= 2) {
        if (col === 6) col--;
        while (true) {
          for (let c = 0; c < 2; c++) {
            if (modules[row][col - c] == null) {
              let dark = false;
              if (byteIndex < data.length) {
                dark = ((data[byteIndex] >>> bitIndex) & 1) === 1;
              }
              const mask = QRUtil.getMask(maskPattern, row, col - c);
              if (mask) dark = !dark;
              modules[row][col - c] = dark;
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || moduleCount <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }

    function createData(typeNumber, errorCorrectLevel, dataList) {
      const rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
      const buffer = new QRBitBuffer();
      for (let i = 0; i < dataList.length; i++) {
        const data = dataList[i];
        buffer.put(data.mode, 4);
        buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
        data.write(buffer);
      }
      let totalDataCount = 0;
      for (let i = 0; i < rsBlocks.length; i++) {
        totalDataCount += rsBlocks[i].dataCount;
      }
      if (buffer.getLengthInBits() > totalDataCount * 8) {
        throw new Error("code length overflow");
      }
      if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) buffer.put(0, 4);
      while (buffer.getLengthInBits() % 8 !== 0) buffer.putBit(false);
      while (true) {
        if (buffer.getLengthInBits() >= totalDataCount * 8) break;
        buffer.put(PAD0, 8);
        if (buffer.getLengthInBits() >= totalDataCount * 8) break;
        buffer.put(PAD1, 8);
      }
      return createBytes(buffer, rsBlocks);
    }

    function createBytes(buffer, rsBlocks) {
      let offset = 0;
      let maxDcCount = 0;
      let maxEcCount = 0;
      const dcdata = new Array(rsBlocks.length);
      const ecdata = new Array(rsBlocks.length);
      for (let r = 0; r < rsBlocks.length; r++) {
        const dcCount = rsBlocks[r].dataCount;
        const ecCount = rsBlocks[r].totalCount - dcCount;
        maxDcCount = Math.max(maxDcCount, dcCount);
        maxEcCount = Math.max(maxEcCount, ecCount);
        dcdata[r] = new Array(dcCount);
        for (let i = 0; i < dcdata[r].length; i++) {
          dcdata[r][i] = 0xff & buffer.buffer[i + offset];
        }
        offset += dcCount;
        const rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
        const rawPoly = new QRPolynomial(dcdata[r], rsPoly.getLength() - 1);
        const modPoly = rawPoly.mod(rsPoly);
        ecdata[r] = new Array(rsPoly.getLength() - 1);
        for (let i = 0; i < ecdata[r].length; i++) {
          const modIndex = i + modPoly.getLength() - ecdata[r].length;
          ecdata[r][i] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
        }
      }
      let totalCodeCount = 0;
      for (let r = 0; r < rsBlocks.length; r++) {
        totalCodeCount += rsBlocks[r].totalCount;
      }
      const data = new Array(totalCodeCount);
      let index = 0;
      for (let i = 0; i < maxDcCount; i++) {
        for (let r = 0; r < rsBlocks.length; r++) {
          if (i < dcdata[r].length) data[index++] = dcdata[r][i];
        }
      }
      for (let i = 0; i < maxEcCount; i++) {
        for (let r = 0; r < rsBlocks.length; r++) {
          if (i < ecdata[r].length) data[index++] = ecdata[r][i];
        }
      }
      return data;
    }

    return qr;
  }

  const QRMode = { MODE_8BIT_BYTE: 4 };
  const QRErrorCorrectLevel = { L: 1, M: 0, Q: 3, H: 2 };

  function QR8bitByte(data) {
    this.mode = QRMode.MODE_8BIT_BYTE;
    this.data = data;
  }
  QR8bitByte.prototype = {
    getLength: function () {
      return this.data.length;
    },
    write: function (buffer) {
      for (let i = 0; i < this.data.length; i++) {
        buffer.put(this.data.charCodeAt(i), 8);
      }
    },
  };

  function QRBitBuffer() {
    this.buffer = [];
    this.length = 0;
  }
  QRBitBuffer.prototype = {
    get: function (index) {
      const bufIndex = Math.floor(index / 8);
      return ((this.buffer[bufIndex] >>> (7 - (index % 8))) & 1) === 1;
    },
    put: function (num, length) {
      for (let i = 0; i < length; i++) {
        this.putBit(((num >>> (length - i - 1)) & 1) === 1);
      }
    },
    putBit: function (bit) {
      const bufIndex = Math.floor(this.length / 8);
      if (this.buffer.length <= bufIndex) this.buffer.push(0);
      if (bit) this.buffer[bufIndex] |= 0x80 >>> this.length % 8;
      this.length++;
    },
    getLengthInBits: function () {
      return this.length;
    },
  };

  function QRPolynomial(num, shift) {
    let offset = 0;
    while (offset < num.length && num[offset] === 0) offset++;
    this.num = new Array(num.length - offset + shift);
    for (let i = 0; i < num.length - offset; i++) this.num[i] = num[i + offset];
  }
  QRPolynomial.prototype = {
    get: function (index) {
      return this.num[index];
    },
    getLength: function () {
      return this.num.length;
    },
    multiply: function (e) {
      const num = new Array(this.getLength() + e.getLength() - 1);
      for (let i = 0; i < this.getLength(); i++) {
        for (let j = 0; j < e.getLength(); j++) {
          num[i + j] ^= QRMath.gexp(QRMath.glog(this.get(i)) + QRMath.glog(e.get(j)));
        }
      }
      return new QRPolynomial(num, 0);
    },
    mod: function (e) {
      if (this.getLength() - e.getLength() < 0) return this;
      const ratio = QRMath.glog(this.get(0)) - QRMath.glog(e.get(0));
      const num = this.num.slice();
      for (let i = 0; i < e.getLength(); i++) {
        num[i] ^= QRMath.gexp(QRMath.glog(e.get(i)) + ratio);
      }
      return new QRPolynomial(num, 0).mod(e);
    },
  };

  const QRMath = {
    glog: function (n) {
      if (n < 1) throw new Error("glog");
      return QRMath.LOG_TABLE[n];
    },
    gexp: function (n) {
      while (n < 0) n += 255;
      while (n >= 256) n -= 255;
      return QRMath.EXP_TABLE[n];
    },
    EXP_TABLE: new Array(256),
    LOG_TABLE: new Array(256),
  };
  for (let i = 0; i < 8; i++) QRMath.EXP_TABLE[i] = 1 << i;
  for (let i = 8; i < 256; i++) QRMath.EXP_TABLE[i] =
    QRMath.EXP_TABLE[i - 4] ^ QRMath.EXP_TABLE[i - 5] ^ QRMath.EXP_TABLE[i - 6] ^ QRMath.EXP_TABLE[i - 8];
  for (let i = 0; i < 255; i++) QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;

  const QRUtil = {
    PATTERN_POSITION_TABLE: [
      [],
      [6, 18],
      [6, 22],
      [6, 26],
      [6, 30],
      [6, 34],
      [6, 22, 38],
      [6, 24, 42],
      [6, 26, 46],
      [6, 28, 50],
      [6, 30, 54],
      [6, 32, 58],
      [6, 34, 62],
      [6, 26, 46, 66],
      [6, 26, 48, 70],
      [6, 26, 50, 74],
      [6, 30, 54, 78],
      [6, 30, 56, 82],
      [6, 30, 58, 86],
      [6, 34, 62, 90],
      [6, 28, 50, 72, 94],
      [6, 26, 50, 74, 98],
      [6, 30, 54, 78, 102],
      [6, 28, 54, 80, 106],
      [6, 32, 58, 84, 110],
      [6, 30, 58, 86, 114],
      [6, 34, 62, 90, 118],
      [6, 26, 50, 74, 98, 122],
      [6, 30, 54, 78, 102, 126],
      [6, 26, 52, 78, 104, 130],
      [6, 30, 56, 82, 108, 134],
      [6, 34, 60, 86, 112, 138],
      [6, 30, 58, 86, 114, 142],
      [6, 34, 62, 90, 118, 146],
      [6, 30, 54, 78, 102, 126, 150],
      [6, 24, 50, 76, 102, 128, 154],
      [6, 28, 54, 80, 106, 132, 158],
      [6, 32, 58, 84, 110, 136, 162],
      [6, 26, 54, 82, 110, 138, 166],
      [6, 30, 58, 86, 114, 142, 170],
    ],
    getBCHTypeInfo: function (data) {
      let d = data << 10;
      while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(0x537) >= 0) {
        d ^= 0x537 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(0x537));
      }
      return ((data << 10) | d) ^ 0x5412;
    },
    getBCHTypeNumber: function (data) {
      let d = data << 12;
      while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(0x1f25) >= 0) {
        d ^= 0x1f25 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(0x1f25));
      }
      return (data << 12) | d;
    },
    getBCHDigit: function (data) {
      let digit = 0;
      while (data !== 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    },
    getPatternPosition: function (typeNumber) {
      return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1] || [];
    },
    getMask: function (maskPattern, i, j) {
      switch (maskPattern) {
        case 0: return (i + j) % 2 === 0;
        case 1: return i % 2 === 0;
        case 2: return j % 3 === 0;
        case 3: return (i + j) % 3 === 0;
        case 4: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
        case 5: return ((i * j) % 2) + ((i * j) % 3) === 0;
        case 6: return (((i * j) % 2) + ((i * j) % 3)) % 2 === 0;
        case 7: return (((i + j) % 2) + ((i * j) % 3)) % 2 === 0;
        default: return false;
      }
    },
    getErrorCorrectPolynomial: function (errorCorrectLength) {
      let a = new QRPolynomial([1], 0);
      for (let i = 0; i < errorCorrectLength; i++) {
        a = a.multiply(new QRPolynomial([1, QRMath.gexp(i)], 0));
      }
      return a;
    },
    getLengthInBits: function (mode, type) {
      if (1 <= type && type < 10) return 8;
      if (type < 27) return 16;
      return 16;
    },
    getLostPoint: function (qrCode) {
      const moduleCount = qrCode.getModuleCount();
      let lostPoint = 0;
      for (let row = 0; row < moduleCount; row++) {
        for (let col = 0; col < moduleCount; col++) {
          let sameCount = 0;
          const dark = qrCode.isDark(row, col);
          for (let r = -1; r <= 1; r++) {
            if (row + r < 0 || moduleCount <= row + r) continue;
            for (let c = -1; c <= 1; c++) {
              if (col + c < 0 || moduleCount <= col + c) continue;
              if (r === 0 && c === 0) continue;
              if (dark === qrCode.isDark(row + r, col + c)) sameCount++;
            }
          }
          if (sameCount > 5) lostPoint += 3 + sameCount - 5;
        }
      }
      for (let row = 0; row < moduleCount - 1; row++) {
        for (let col = 0; col < moduleCount - 1; col++) {
          let count = 0;
          if (qrCode.isDark(row, col)) count++;
          if (qrCode.isDark(row + 1, col)) count++;
          if (qrCode.isDark(row, col + 1)) count++;
          if (qrCode.isDark(row + 1, col + 1)) count++;
          if (count === 0 || count === 4) lostPoint += 3;
        }
      }
      for (let row = 0; row < moduleCount; row++) {
        for (let col = 0; col < moduleCount - 6; col++) {
          if (
            qrCode.isDark(row, col) &&
            !qrCode.isDark(row, col + 1) &&
            qrCode.isDark(row, col + 2) &&
            qrCode.isDark(row, col + 3) &&
            qrCode.isDark(row, col + 4) &&
            !qrCode.isDark(row, col + 5) &&
            qrCode.isDark(row, col + 6)
          ) {
            lostPoint += 40;
          }
        }
      }
      for (let col = 0; col < moduleCount; col++) {
        for (let row = 0; row < moduleCount - 6; row++) {
          if (
            qrCode.isDark(row, col) &&
            !qrCode.isDark(row + 1, col) &&
            qrCode.isDark(row + 2, col) &&
            qrCode.isDark(row + 3, col) &&
            qrCode.isDark(row + 4, col) &&
            !qrCode.isDark(row + 5, col) &&
            qrCode.isDark(row + 6, col)
          ) {
            lostPoint += 40;
          }
        }
      }
      let darkCount = 0;
      for (let col = 0; col < moduleCount; col++) {
        for (let row = 0; row < moduleCount; row++) {
          if (qrCode.isDark(row, col)) darkCount++;
        }
      }
      const ratio = Math.abs((100 * darkCount) / moduleCount / moduleCount - 50) / 5;
      lostPoint += ratio * 10;
      return lostPoint;
    },
  };

  const QRRSBlock = {
    RS_BLOCK_TABLE: [
      [1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9],
      [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16],
      [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13],
      [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9],
      [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12],
      [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15],
      [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14],
      [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15],
    ],
    getRSBlocks: function (typeNumber, errorCorrectLevel) {
      const rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
      if (rsBlock == null) throw new Error("bad rs block");
      const length = rsBlock.length / 3;
      const list = [];
      for (let i = 0; i < length; i++) {
        const count = rsBlock[i * 3];
        const totalCount = rsBlock[i * 3 + 1];
        const dataCount = rsBlock[i * 3 + 2];
        for (let j = 0; j < count; j++) {
          list.push({ totalCount, dataCount });
        }
      }
      return list;
    },
    getRsBlockTable: function (typeNumber, errorCorrectLevel) {
      switch (errorCorrectLevel) {
        case QRErrorCorrectLevel.L: return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
        case QRErrorCorrectLevel.M: return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
        case QRErrorCorrectLevel.Q: return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
        case QRErrorCorrectLevel.H: return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
        default: return null;
      }
    },
  };

  function getMetricsSource(rangeKey) {
    const views = getWalletViews(rangeKey, currentMarketType);
    if (!views.length) return null;
    if (views.length === 1) {
      return { label: formatWalletLabel(views[0].wallet), view: views[0].view };
    }
    const labels = buildLabels(views[0].view.times, rangeKey);
    const weightedEquity = buildWeightedSeries(views, labels, "equity");
    const weightedPnl = buildWeightedSeries(views, labels, "pnl");
    return {
      label: "Weighted",
      view: {
        times: views[0].view.times,
        equity: weightedEquity?.data || views[0].view.equity,
        pnl: weightedPnl?.data || views[0].view.pnl,
      },
    };
  }

  function computeWeeklyPnlDeltas(times, pnl) {
    if (!Array.isArray(times) || !Array.isArray(pnl) || times.length !== pnl.length) return [];
    const buckets = new Map();
    for (let i = 0; i < times.length; i += 1) {
      const time = normalizeTimestamp(times[i]);
      const value = Number(pnl[i]);
      if (!Number.isFinite(time) || !Number.isFinite(value)) continue;
      const weekIndex = Math.floor(time / 604800000);
      const bucket = buckets.get(weekIndex) || { firstTime: time, lastTime: time, first: value, last: value };
      if (time < bucket.firstTime) {
        bucket.firstTime = time;
        bucket.first = value;
      }
      if (time > bucket.lastTime) {
        bucket.lastTime = time;
        bucket.last = value;
      }
      buckets.set(weekIndex, bucket);
    }
    return Array.from(buckets.entries())
      .sort((a, b) => a[0] - b[0])
      .map(([, bucket]) => bucket.last - bucket.first);
  }

  function computeCorrelation(seriesA, seriesB) {
    if (!Array.isArray(seriesA) || !Array.isArray(seriesB)) return null;
    if (seriesA.length !== seriesB.length || seriesA.length < 2) return null;
    const n = seriesA.length;
    const meanA = seriesA.reduce((sum, v) => sum + v, 0) / n;
    const meanB = seriesB.reduce((sum, v) => sum + v, 0) / n;
    let cov = 0;
    let varA = 0;
    let varB = 0;
    for (let i = 0; i < n; i += 1) {
      const da = seriesA[i] - meanA;
      const db = seriesB[i] - meanB;
      cov += da * db;
      varA += da * da;
      varB += db * db;
    }
    if (!varA || !varB) return null;
    return cov / Math.sqrt(varA * varB);
  }

  function computePerformanceMetrics(view) {
    const equity = Array.isArray(view?.equity) ? view.equity : [];
    const pnl = Array.isArray(view?.pnl) ? view.pnl : [];
    const rawDeposits = Array.isArray(view?.rawDeposits) ? view.rawDeposits : [];
    const times = Array.isArray(view?.times) ? view.times : [];
    if (equity.length < 2 || pnl.length < 2) return null;

    const pnlStart = Number(pnl[0]);
    const pnlEnd = Number(pnl[pnl.length - 1]);
    const totalPnl = pnlEnd - pnlStart;
    const depositsBase = Number.isFinite(rawDeposits[0]) ? rawDeposits[0] : 0;
    let totalDeposits = Number.isFinite(depositsBase) && depositsBase > 0 ? depositsBase : 0;
    for (let i = 1; i < rawDeposits.length; i += 1) {
      const prev = Number(rawDeposits[i - 1]);
      const curr = Number(rawDeposits[i]);
      if (!Number.isFinite(prev) || !Number.isFinite(curr)) continue;
      const delta = curr - prev;
      if (delta > 0) totalDeposits += delta;
    }

    const baseEquity = totalDeposits > 0 ? totalDeposits : Number(equity[0]);
    const baseDenom = baseEquity ? Math.abs(baseEquity) : null;
    const returnPct = baseDenom ? totalPnl / baseDenom : null;

    let peak = -Infinity;
    let maxDrawdownAbs = 0;
    pnl.forEach((val) => {
      const v = Number(val);
      if (!Number.isFinite(v)) return;
      const equityFromInitial = Number.isFinite(baseEquity) ? baseEquity + (v - pnlStart) : v;
      if (equityFromInitial > peak) peak = equityFromInitial;
      const drawdown = peak - equityFromInitial;
      if (drawdown > maxDrawdownAbs) maxDrawdownAbs = drawdown;
    });
    const maxDrawdown = baseDenom ? maxDrawdownAbs / baseDenom : null;

    const deltas = [];
    for (let i = 1; i < pnl.length; i += 1) {
      const prev = Number(pnl[i - 1]);
      const curr = Number(pnl[i]);
      if (!Number.isFinite(prev) || !Number.isFinite(curr)) continue;
      deltas.push(curr - prev);
    }
    if (!deltas.length) return null;

    const mean = deltas.reduce((sum, v) => sum + v, 0) / deltas.length;
    const variance = deltas.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / deltas.length;
    const volatility = Math.sqrt(variance);
    const sharpe = volatility ? mean / volatility : null;
    const bestInterval = Math.max(...deltas);

    const weeklyDeltas = computeWeeklyPnlDeltas(times, pnl);
    let pnlStability = null;
    if (weeklyDeltas.length) {
      const weeklyMean = weeklyDeltas.reduce((sum, v) => sum + v, 0) / weeklyDeltas.length;
      const weeklyVar = weeklyDeltas.reduce((sum, v) => sum + Math.pow(v - weeklyMean, 2), 0) / weeklyDeltas.length;
      const weeklyStd = Math.sqrt(weeklyVar);
      const denom = Math.abs(weeklyMean);
      pnlStability = denom ? weeklyStd / denom : null;
    }

    let skillPersistence = null;
    if (weeklyDeltas.length >= 2) {
      const a = weeklyDeltas.slice(0, -1);
      const b = weeklyDeltas.slice(1);
      skillPersistence = computeCorrelation(a, b);
    }

    return {
      totalPnl,
      returnPct,
      maxDrawdown,
      sharpe,
      volatility,
      bestInterval,
      pnlStability,
      skillPersistence,
      baseEquity,
      pnlStart,
    };
  }

  function getMetricsRangeWindow(view, rangeKey) {
    const times = Array.isArray(view?.times) ? view.times : [];
    if (!times.length) return { start: null, end: null };
    const msTimes = times
      .map((t) => (t instanceof Date ? t.getTime() : normalizeTimestamp(t)))
      .filter(Number.isFinite);
    if (!msTimes.length) return { start: null, end: null };
    const end = Date.now();
    if (rangeKey === "day") return { start: end - 86400000, end };
    if (rangeKey === "week") return { start: end - 7 * 86400000, end };
    if (rangeKey === "month") return { start: end - 30 * 86400000, end };
    return { start: Math.min(...msTimes), end };
  }

  function getRangeWindowForKey(rangeKey) {
    const end = Date.now();
    if (rangeKey === "day") return { start: end - 86400000, end };
    if (rangeKey === "week") return { start: end - 7 * 86400000, end };
    if (rangeKey === "month") return { start: end - 30 * 86400000, end };
    return { start: null, end };
  }

  function getRangeDays(rangeKey) {
    if (rangeKey === "day") return 1;
    if (rangeKey === "week") return 7;
    if (rangeKey === "month") return 30;
    return "max";
  }

  const benchmarkCache = new Map();
  let benchmarkRequestId = 0;

  async function fetchJsonWithTimeout(url, timeoutMs = 8000) {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeoutMs);
    try {
      const res = await fetch(url, { signal: controller.signal });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json();
    } finally {
      clearTimeout(id);
    }
  }

  function getBinanceInterval(rangeKey) {
    if (rangeKey === "day") return "1h";
    if (rangeKey === "week") return "4h";
    if (rangeKey === "month") return "1d";
    return "1d";
  }

  function getBinanceLimit(rangeKey) {
    if (rangeKey === "day") return 48;
    if (rangeKey === "week") return 200;
    if (rangeKey === "month") return 400;
    return 1000;
  }

  async function fetchBitcoinHistory(rangeKey, startTime, endTime) {
    const days = getRangeDays(rangeKey);
    const cacheKey = `${rangeKey}:${days}:${Number(startTime) || "na"}:${Number(endTime) || "na"}`;
    if (benchmarkCache.has(cacheKey)) return benchmarkCache.get(cacheKey);

    const sources = [
      {
        name: "binance",
        fetch: async () => {
          const interval = getBinanceInterval(rangeKey);
          const limit = getBinanceLimit(rangeKey);
          const fetchChunk = async (start, end) => {
            const params = new URLSearchParams({
              symbol: "BTCUSDT",
              interval,
              limit: String(limit),
            });
            if (Number.isFinite(start)) params.set("startTime", String(start));
            if (Number.isFinite(end)) params.set("endTime", String(end));
            const url = `https://api.binance.com/api/v3/klines?${params.toString()}`;
            const data = await fetchJsonWithTimeout(url);
            if (!Array.isArray(data)) return [];
            return data
              .map((row) => [Number(row?.[0]), Number(row?.[4])])
              .filter(([t, p]) => Number.isFinite(t) && Number.isFinite(p));
          };

          if (rangeKey !== "allTime") {
            return await fetchChunk();
          }

          const all = [];
          let fetchStart = Number.isFinite(startTime) ? startTime : null;
          const fetchEnd = Number.isFinite(endTime) ? endTime : null;
          let safety = 0;
          while (fetchStart !== null && fetchEnd !== null && fetchStart < fetchEnd && safety < 6) {
            // eslint-disable-next-line no-await-in-loop
            const chunk = await fetchChunk(fetchStart, fetchEnd);
            if (!chunk.length) break;
            all.push(...chunk);
            const lastTime = chunk[chunk.length - 1][0];
            if (!Number.isFinite(lastTime) || lastTime <= fetchStart) break;
            fetchStart = lastTime + 1;
            safety += 1;
          }
          return all.length ? all : await fetchChunk();
        },
      },
      {
        name: "coinbase",
        fetch: async () => {
          const granularity = rangeKey === "day" ? 3600 : rangeKey === "week" ? 14400 : 86400;
          const url = `https://api.exchange.coinbase.com/products/BTC-USD/candles?granularity=${granularity}`;
          const data = await fetchJsonWithTimeout(url);
          if (!Array.isArray(data)) return [];
          return data
            .map((row) => [Number(row?.[0]) * 1000, Number(row?.[4])])
            .filter(([t, p]) => Number.isFinite(t) && Number.isFinite(p));
        },
      },
    ];

    let lastError = null;
    for (const source of sources) {
      try {
        const result = await source.fetch();
        if (result && result.length) {
          benchmarkCache.set(cacheKey, result);
          return result;
        }
      } catch (err) {
        lastError = err;
        console.warn(`BTC benchmark source failed: ${source.name}`, err);
      }
    }

    if (lastError) throw lastError;
    return [];
  }

  function resolveBetaBaseEquity(view) {
    const baseEquity = Number(view?.baseEquity ?? 0);
    if (Number.isFinite(baseEquity) && baseEquity !== 0) return baseEquity;
    const equity = Array.isArray(view?.equity) ? view.equity : [];
    const fallback = equity.find((v) => Number.isFinite(v) && v !== 0);
    return Number.isFinite(fallback) ? Number(fallback) : null;
  }

  function buildWalletReturnSeries(view, baseEquityOverride) {
    const pnl = Array.isArray(view?.pnl) ? view.pnl : [];
    const times = Array.isArray(view?.times) ? view.times : [];
    if (!pnl.length || pnl.length !== times.length) return null;
    const overrideOk = Number.isFinite(baseEquityOverride) && baseEquityOverride !== 0;
    const baseEquity = overrideOk ? baseEquityOverride : resolveBetaBaseEquity(view);
    const denom = baseEquity ? Math.abs(baseEquity) : null;
    if (!denom) return null;

    const series = [];
    for (let i = 1; i < pnl.length; i += 1) {
      const prev = Number(pnl[i - 1]);
      const curr = Number(pnl[i]);
      const time = times[i] instanceof Date ? times[i].getTime() : normalizeTimestamp(times[i]);
      const prevTime = times[i - 1] instanceof Date ? times[i - 1].getTime() : normalizeTimestamp(times[i - 1]);
      if (!Number.isFinite(prev) || !Number.isFinite(curr) || !Number.isFinite(time) || !Number.isFinite(prevTime)) continue;
      series.push({ time, prevTime, value: (curr - prev) / denom });
    }
    return series;
  }

  function findNearestPrice(priceSeries, time) {
    if (!priceSeries.length) return null;
    let left = 0;
    let right = priceSeries.length - 1;
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      const midTime = priceSeries[mid][0];
      if (midTime === time) return priceSeries[mid][1];
      if (midTime < time) left = mid + 1;
      else right = mid - 1;
    }
    const leftItem = priceSeries[left];
    const rightItem = priceSeries[right];
    if (!leftItem) return rightItem ? rightItem[1] : null;
    if (!rightItem) return leftItem[1];
    return Math.abs(leftItem[0] - time) < Math.abs(rightItem[0] - time) ? leftItem[1] : rightItem[1];
  }

  function buildBenchmarkReturnSeries(priceSeries, walletSeries) {
    if (!walletSeries || !walletSeries.length) return null;
    const benchmark = [];
    for (let i = 0; i < walletSeries.length; i += 1) {
      const time = walletSeries[i].time;
      const prevTime = walletSeries[i].prevTime;
      const prevPrice = findNearestPrice(priceSeries, prevTime);
      const price = findNearestPrice(priceSeries, time);
      if (!Number.isFinite(prevPrice) || !Number.isFinite(price) || prevPrice === 0) continue;
      benchmark.push({ time, value: (price - prevPrice) / prevPrice });
    }
    return benchmark.length ? benchmark : null;
  }

  function computeBetaAlpha(walletSeries, benchmarkSeries) {
    if (!walletSeries || !benchmarkSeries) return null;
    const pairs = [];
    const benchByTime = new Map(benchmarkSeries.map((b) => [b.time, b.value]));
    walletSeries.forEach((w) => {
      const b = benchByTime.get(w.time);
      if (Number.isFinite(w.value) && Number.isFinite(b)) pairs.push([w.value, b]);
    });
    if (pairs.length < 2) return null;
    const walletVals = pairs.map((p) => p[0]);
    const benchVals = pairs.map((p) => p[1]);
    const meanWallet = walletVals.reduce((s, v) => s + v, 0) / walletVals.length;
    const meanBench = benchVals.reduce((s, v) => s + v, 0) / benchVals.length;
    let cov = 0;
    let varBench = 0;
    for (let i = 0; i < pairs.length; i += 1) {
      const dw = walletVals[i] - meanWallet;
      const db = benchVals[i] - meanBench;
      cov += dw * db;
      varBench += db * db;
    }
    if (!varBench) return null;
    const beta = cov / varBench;
    const alpha = meanWallet - beta * meanBench;
    return { beta, alpha, meanBench };
  }

  async function updateBenchmarkMetrics(rangeKey, view, totalPnl, baseEquity, rangeWindow) {
    const requestId = ++benchmarkRequestId;
    setMetricValue(metricExcessPnlEl, "Loading...", null);
    setMetricValue(metricBetaAlphaEl, "Loading...", null);

    try {
      const priceSeries = await fetchBitcoinHistory(rangeKey, rangeWindow?.start, rangeWindow?.end);
      if (requestId !== benchmarkRequestId) return;

      const walletSeries = buildWalletReturnSeries(view, baseEquity);
      if (!walletSeries || !walletSeries.length) {
        setMetricValue(metricExcessPnlEl, "N/A", null);
        setMetricValue(metricBetaAlphaEl, "N/A", null);
        return;
      }

      const benchmarkSeries = buildBenchmarkReturnSeries(priceSeries, walletSeries);
      const stats = computeBetaAlpha(walletSeries, benchmarkSeries);
      if (!stats) {
        setMetricValue(metricExcessPnlEl, "N/A", null);
        setMetricValue(metricBetaAlphaEl, "N/A", null);
        return;
      }

      const benchmarkSum = benchmarkSeries
        ? benchmarkSeries.reduce((sum, item) => sum + (Number.isFinite(item.value) ? item.value : 0), 0)
        : null;
      const benchmarkPnl = Number.isFinite(baseEquity) && Number.isFinite(benchmarkSum)
        ? baseEquity * benchmarkSum
        : null;
      const excessPnl = Number.isFinite(benchmarkPnl) ? totalPnl - benchmarkPnl : null;

      setMetricValue(metricExcessPnlEl, Number.isFinite(excessPnl) ? formatSignedDollarWithPlus(excessPnl) : "N/A", excessPnl);
      if (metricBetaAlphaEl) {
        metricBetaAlphaEl.classList.remove("positive", "negative");
        metricBetaAlphaEl.style.color = "";
        const betaSpan = `<span style="color:${getScaledColor(stats.beta, 0, 2)}">${formatRatio(stats.beta, 2)}</span>`;
        const alphaSpan = `<span style="color:${getScaledColor(stats.alpha, -1, 1)}">${formatRatio(stats.alpha, 2)}</span>`;
        metricBetaAlphaEl.innerHTML = `Î²: ${betaSpan}, Î±: ${alphaSpan}`;
      }
    } catch (err) {
      console.error("Benchmark metrics error", err);
      setMetricValue(metricExcessPnlEl, "N/A", null);
      setMetricValue(metricBetaAlphaEl, "N/A", null);
    }
  }

  function updatePerformanceMetrics(rangeKey) {
    if (metricsRangeLabelEl) metricsRangeLabelEl.textContent = getRangeLabel(rangeKey);

    const source = getMetricsSource(rangeKey);
    if (!source) {
      if (metricsWalletLabelEl) metricsWalletLabelEl.textContent = "-";
      const rangeWindow = getRangeWindowForKey(rangeKey);
      const walletSet = new Set(currentWallets.map((w) => String(w).toLowerCase()));
      const tradeMetrics = computeTradeOrderMetrics({
        startTime: rangeWindow.start,
        endTime: rangeWindow.end,
        walletSet,
        marketType: currentMarketType,
      });
      setPortfolioMetricsUnavailable();
      if (tradeMetrics) {
        setMetricValue(metricRealizedPnlEl, formatSignedDollarWithPlus(tradeMetrics.realizedPnl), tradeMetrics.realizedPnl);
        const winRatePct = formatPercent(tradeMetrics.winRate);
        const winRateSuffix =
          Number.isFinite(tradeMetrics.wins) && Number.isFinite(tradeMetrics.closedCount)
            ? ` (${tradeMetrics.wins}/${tradeMetrics.closedCount})`
            : "";
        setMetricValue(metricWinRateEl, `${winRatePct}${winRateSuffix}`, null);
        if (Number.isFinite(tradeMetrics.winRate)) {
          setMetricScaledColor(metricWinRateEl, tradeMetrics.winRate, 0, 1);
        }
        const profitFactorText =
          tradeMetrics.profitFactor === Infinity
            ? "Inf"
            : tradeMetrics.profitFactor !== null
              ? formatRatio(tradeMetrics.profitFactor, 2)
              : "-";
        setMetricValue(metricProfitFactorEl, profitFactorText, null);
        if (Number.isFinite(tradeMetrics.profitFactor)) {
          setMetricScaledColor(metricProfitFactorEl, tradeMetrics.profitFactor, 0, 3);
        }
        const ordersPerDayText = formatNumber(tradeMetrics.ordersPerDay, 2) || "-";
        const tradesPerDayText = formatNumber(tradeMetrics.tradesPerDay, 2) || "-";
        setMetricValue(metricOrdersTradesPerDayEl, `${ordersPerDayText} (${tradesPerDayText})`, null);
        setMetricValue(metricActiveDaysEl, formatPercent(tradeMetrics.activeDaysRatio), null);
        if (Number.isFinite(tradeMetrics.activeDaysRatio)) {
          setMetricScaledColor(metricActiveDaysEl, tradeMetrics.activeDaysRatio, 0, 1);
        }
        setMetricValue(metricActiveDaysCountEl, Number.isFinite(tradeMetrics.activeDaysCount) ? String(tradeMetrics.activeDaysCount) : "-", null);
        if (Number.isFinite(tradeMetrics.activeDaysCount)) {
          setMetricScaledColor(metricActiveDaysCountEl, tradeMetrics.activeDaysCount, 0, 200);
        }
        setMetricValue(metricProductCountEl, tradeMetrics.productCount !== null ? String(tradeMetrics.productCount) : "-", null);
        setMetricValue(metricHerfindahlEl, tradeMetrics.herfindahl !== null ? formatRatio(tradeMetrics.herfindahl, 3) : "-", null);
        if (Number.isFinite(tradeMetrics.herfindahl)) {
          setMetricScaledColor(metricHerfindahlEl, tradeMetrics.herfindahl, 0, 1, true);
        }
        setMetricValue(metricAvgNotionalEl, tradeMetrics.avgNotional !== null ? fmtMoney(tradeMetrics.avgNotional, 2) : "-", null);
        setMetricValue(metricMedianHoldingEl, formatDuration(tradeMetrics.medianHoldingTime), null);
        setMetricValue(metricSideBiasEl, formatSignedPercent(tradeMetrics.sideBias), null);
        setMetricValue(metricAggressivenessEl, formatPercent(tradeMetrics.aggressiveness), null);
        setMetricValue(metricCancelRatioEl, formatPercent(tradeMetrics.cancelRatio), null);
        if (Number.isFinite(tradeMetrics.cancelRatio)) {
          setMetricScaledColor(metricCancelRatioEl, tradeMetrics.cancelRatio, 0, 1, true);
        }
        setMetricValue(metricReactionSpeedEl, formatDuration(tradeMetrics.reactionSpeed), null);
      } else {
        setMetricValue(metricRealizedPnlEl, "-", null);
        setMetricValue(metricWinRateEl, "-", null);
        setMetricValue(metricProfitFactorEl, "-", null);
        setMetricValue(metricOrdersTradesPerDayEl, "-", null);
        setMetricValue(metricActiveDaysEl, "-", null);
        setMetricValue(metricProductCountEl, "-", null);
        setMetricValue(metricHerfindahlEl, "-", null);
        setMetricValue(metricAvgNotionalEl, "-", null);
        setMetricValue(metricActiveDaysCountEl, "-", null);
        setMetricValue(metricMedianHoldingEl, "-", null);
        setMetricValue(metricSideBiasEl, "-", null);
        setMetricValue(metricAggressivenessEl, "-", null);
        setMetricValue(metricCancelRatioEl, "-", null);
        setMetricValue(metricReactionSpeedEl, "-", null);
      }
      return;
    }
    if (metricsWalletLabelEl) metricsWalletLabelEl.textContent = source?.label || "-";
    updateTotalPnlSubLabel(rangeKey);

    const metrics = computePerformanceMetrics(source.view);
    const rangeWindow = getMetricsRangeWindow(source.view, rangeKey);
    const walletSet = new Set(currentWallets.map((w) => String(w).toLowerCase()));
    const tradeMetrics = computeTradeOrderMetrics({
      startTime: rangeWindow.start,
      endTime: rangeWindow.end,
      walletSet,
      marketType: currentMarketType,
    });
    if (metrics) {
      latestBaseEquityValue = Number.isFinite(metrics.baseEquity) ? metrics.baseEquity : null;
      const livePnl = Number.isFinite(latestLivePnlValue) ? latestLivePnlValue : null;
      const totalPnlValue = livePnl !== null ? livePnl : metrics.totalPnl;
      setMetricValue(metricTotalPnlEl, formatSignedDollarWithPlus(totalPnlValue), totalPnlValue);
      setMetricValue(metricReturnEl, formatSignedPercent(metrics.returnPct), metrics.returnPct);
      setMetricValue(metricMaxDrawdownEl, formatPercent(metrics.maxDrawdown), null);
      setMetricValue(metricSharpeEl, metrics.sharpe !== null ? formatRatio(metrics.sharpe, 2) : "-", metrics.sharpe);
      setMetricValue(metricVolatilityEl, fmtMoney(metrics.volatility, 2), null);
      setMetricValue(metricBestIntervalEl, formatSignedDollarWithPlus(metrics.bestInterval), metrics.bestInterval);
      setMetricValue(metricPnlStabilityEl, metrics.pnlStability !== null ? formatRatio(metrics.pnlStability, 2) : "-", null);
      setMetricValue(metricSkillPersistenceEl, metrics.skillPersistence !== null ? formatRatio(metrics.skillPersistence, 2) : "-", null);

      if (Number.isFinite(metrics.maxDrawdown)) {
        setMetricScaledColor(metricMaxDrawdownEl, metrics.maxDrawdown, 0, 2);
      }
      if (Number.isFinite(metrics.sharpe)) {
        setMetricScaledColor(metricSharpeEl, metrics.sharpe, -1, 2);
      }
      if (Number.isFinite(metrics.pnlStability)) {
        setMetricScaledColor(metricPnlStabilityEl, metrics.pnlStability, 0, 2, true);
      }
      if (Number.isFinite(metrics.skillPersistence)) {
        setMetricScaledColor(metricSkillPersistenceEl, metrics.skillPersistence, -1, 1);
      }
    }

    if (tradeMetrics) {
      setMetricValue(metricRealizedPnlEl, formatSignedDollarWithPlus(tradeMetrics.realizedPnl), tradeMetrics.realizedPnl);
      const winRatePct = formatPercent(tradeMetrics.winRate);
      const winRateSuffix =
        Number.isFinite(tradeMetrics.wins) && Number.isFinite(tradeMetrics.closedCount)
          ? ` (${tradeMetrics.wins}/${tradeMetrics.closedCount})`
          : "";
      setMetricValue(metricWinRateEl, `${winRatePct}${winRateSuffix}`, null);
      if (Number.isFinite(tradeMetrics.winRate)) {
        setMetricScaledColor(metricWinRateEl, tradeMetrics.winRate, 0, 1);
      }
      const profitFactorText =
        tradeMetrics.profitFactor === Infinity
          ? "Inf"
          : tradeMetrics.profitFactor !== null
            ? formatRatio(tradeMetrics.profitFactor, 2)
            : "-";
      setMetricValue(metricProfitFactorEl, profitFactorText, null);
      if (Number.isFinite(tradeMetrics.profitFactor)) {
        setMetricScaledColor(metricProfitFactorEl, tradeMetrics.profitFactor, 0, 3);
      }
      const ordersPerDayText = formatNumber(tradeMetrics.ordersPerDay, 2) || "-";
      const tradesPerDayText = formatNumber(tradeMetrics.tradesPerDay, 2) || "-";
      setMetricValue(metricOrdersTradesPerDayEl, `${ordersPerDayText} (${tradesPerDayText})`, null);
      setMetricValue(metricActiveDaysEl, formatPercent(tradeMetrics.activeDaysRatio), null);
      if (Number.isFinite(tradeMetrics.activeDaysRatio)) {
        setMetricScaledColor(metricActiveDaysEl, tradeMetrics.activeDaysRatio, 0, 1);
      }
      setMetricValue(metricActiveDaysCountEl, Number.isFinite(tradeMetrics.activeDaysCount) ? String(tradeMetrics.activeDaysCount) : "-", null);
      if (Number.isFinite(tradeMetrics.activeDaysCount)) {
        setMetricScaledColor(metricActiveDaysCountEl, tradeMetrics.activeDaysCount, 0, 200);
      }
      setMetricValue(metricProductCountEl, tradeMetrics.productCount !== null ? String(tradeMetrics.productCount) : "-", null);
      setMetricValue(metricHerfindahlEl, tradeMetrics.herfindahl !== null ? formatRatio(tradeMetrics.herfindahl, 3) : "-", null);
      if (Number.isFinite(tradeMetrics.herfindahl)) {
        setMetricScaledColor(metricHerfindahlEl, tradeMetrics.herfindahl, 0, 1, true);
      }
      setMetricValue(metricAvgNotionalEl, tradeMetrics.avgNotional !== null ? fmtMoney(tradeMetrics.avgNotional, 2) : "-", null);
      setMetricValue(metricMedianHoldingEl, formatDuration(tradeMetrics.medianHoldingTime), null);
      setMetricValue(metricSideBiasEl, formatSignedPercent(tradeMetrics.sideBias), null);
      setMetricValue(metricAggressivenessEl, formatPercent(tradeMetrics.aggressiveness), null);
      setMetricValue(metricCancelRatioEl, formatPercent(tradeMetrics.cancelRatio), null);
      if (Number.isFinite(tradeMetrics.cancelRatio)) {
        setMetricScaledColor(metricCancelRatioEl, tradeMetrics.cancelRatio, 0, 1, true);
      }
      setMetricValue(metricReactionSpeedEl, formatDuration(tradeMetrics.reactionSpeed), null);
    } else {
      setMetricValue(metricRealizedPnlEl, "-", null);
      setMetricValue(metricWinRateEl, "-", null);
      setMetricValue(metricProfitFactorEl, "-", null);
      setMetricValue(metricOrdersTradesPerDayEl, "-", null);
      setMetricValue(metricActiveDaysEl, "-", null);
      setMetricValue(metricProductCountEl, "-", null);
      setMetricValue(metricHerfindahlEl, "-", null);
      setMetricValue(metricAvgNotionalEl, "-", null);
      setMetricValue(metricActiveDaysCountEl, "-", null);
      setMetricValue(metricMedianHoldingEl, "-", null);
      setMetricValue(metricSideBiasEl, "-", null);
      setMetricValue(metricAggressivenessEl, "-", null);
      setMetricValue(metricCancelRatioEl, "-", null);
      setMetricValue(metricReactionSpeedEl, "-", null);
    }

    if (metrics && source) {
      updateBenchmarkMetrics(rangeKey, {
        ...source.view,
        baseEquity: metrics.baseEquity,
      }, metrics.totalPnl, metrics.baseEquity, rangeWindow);
    }
  }

  function openPortfolioModal() {
    if (!portfolioModalEl) return;
    portfolioModalEl.classList.add("open");
    updatePortfolioBreakdownChart();
  }

  function closePortfolioModal() {
    if (!portfolioModalEl) return;
    portfolioModalEl.classList.remove("open");
  }

  function createLineChart(ctx, labels, datasets) {
    const hoverLinePlugin = {
      id: "hoverLine",
      afterDatasetsDraw(chart) {
        const active = chart.getActiveElements();
        if (!active || !active.length) return;
        const { ctx, chartArea, scales } = chart;
        const x = active[0].element?.x;
        if (!Number.isFinite(x)) return;
        ctx.save();
        ctx.setLineDash([4, 4]);
        ctx.lineWidth = 1;
        ctx.strokeStyle = "rgba(255,255,255,0.18)";
        const y = active[0].element?.y;
        const startY = Number.isFinite(y) ? y : chartArea.top;
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, chartArea.bottom);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(chartArea.left, startY);
        ctx.lineTo(x, startY);
        ctx.stroke();
        ctx.restore();
      },
    };

    return new Chart(ctx, {
      type: "line",
      data: {
        labels,
        datasets,
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: "index", intersect: false },
        plugins: {
          legend: { display: datasets.length > 1, labels: { color: getChartTextColor() } },
          tooltip: {
            backgroundColor: "rgba(0, 0, 0, 0.7)",
            borderColor: "rgba(148,163,184,0.5)",
            borderWidth: 1,
            titleColor: "#e5e7eb",
            bodyColor: "#e5e7eb",
            displayColors: false,
            padding: 8,
            cornerRadius: 6,
            callbacks: {
              title: (items) => (items && items.length ? (items[0].label || "") : ""),
              label: (ctx) => {
                const v = Number(ctx.parsed.y ?? 0);
                const abs = Math.abs(v).toLocaleString(undefined, { maximumFractionDigits: 2 });
                return v < 0 ? `-$${abs}` : `$${abs}`;
              },
            },
          },
        },
        scales: {
          x: {
            ticks: { maxTicksLimit: 6, minRotation: 25, maxRotation: 25 },
            grid: { display: false },
          },
          y: {
            ticks: {
              // âœ… -$1000 not $-1000
              callback: (value) => {
                const n = Number(value);
                if (!Number.isFinite(n)) return "";
                const abs = Math.abs(n).toLocaleString(undefined, { maximumFractionDigits: 0 });
                return n < 0 ? `-$${abs}` : `$${abs}`;
              },
              maxTicksLimit: 6,
            },
            grid: { color: getChartGridColor() },
          },
        },
      },
      plugins: [hoverLinePlugin],
    });
  }

  function initPortfolioCharts(rangeKey) {
    const views = getWalletViews(rangeKey, currentMarketType);
    if (!views.length) {
      setPortfolioLoadingState(false, "");
      portfolioErrorEl.textContent = "No performance data available for the selected wallets.";
      if (currentMarketType === "perp") clearPerformanceMetrics();
      chartLastValues.equity = null;
      chartLastValues.pnl = null;
      chartLastValues.deposits = null;
      updateChartTitleValues(latestLiveEquityValue);
      return;
    }

    setPortfolioLoadingState(false, "");
    const labels = buildLabels(views[0].view.times, rangeKey);
    const singleWallet = views.length === 1;
    const singleColors = { equity: "#8b5cf6", pnl: "#f59e0b", deposits: "#14b8a6" };

    const weightedEquity = buildWeightedSeries(views, labels, "equity");
    const weightedPnl = buildWeightedSeries(views, labels, "pnl");
    const weightedDeposits = buildWeightedSeries(views, labels, "deposits");

    const equityDatasets = [
      ...(weightedEquity ? [weightedEquity] : []),
      ...buildWalletDatasets(views, labels, "equity", singleWallet ? singleColors.equity : null),
    ];
    const pnlDatasets = [
      ...(weightedPnl ? [weightedPnl] : []),
      ...buildWalletDatasets(views, labels, "pnl", singleWallet ? singleColors.pnl : null),
    ];
    const depositsDatasets = [
      ...(weightedDeposits ? [weightedDeposits] : []),
      ...buildWalletDatasets(views, labels, "deposits", singleWallet ? singleColors.deposits : null),
    ];

    portfolioCharts.equity = createLineChart(
      equityCanvas.getContext("2d"),
      labels,
      equityDatasets
    );
    applyEquityTooltipStyling(portfolioCharts.equity);

    portfolioCharts.pnl = createLineChart(
      pnlCanvas.getContext("2d"),
      labels,
      pnlDatasets
    );
    applyPnlTooltipStyling(portfolioCharts.pnl);

    portfolioCharts.deposits = createLineChart(
      depositsCanvas.getContext("2d"),
      labels,
      depositsDatasets
    );
    applyDepositsTooltipStyling(portfolioCharts.deposits);

    chartLastValues.equity = getLastFiniteFromDatasets(equityDatasets);
    chartLastValues.pnl = getLastFiniteFromDatasets(pnlDatasets);
    chartLastValues.deposits = getLastFiniteFromDatasets(depositsDatasets);
    updateChartTitleValues(latestLiveEquityValue);
    updatePerformanceMetrics(rangeKey);
  }

  function updatePortfolioCharts(rangeKey) {
    const views = getWalletViews(rangeKey, currentMarketType);
    if (!views.length) {
      portfolioErrorEl.textContent = "No performance data available for the selected range.";
      if (currentMarketType === "perp") clearPerformanceMetrics();
      chartLastValues.equity = null;
      chartLastValues.pnl = null;
      chartLastValues.deposits = null;
      updateChartTitleValues(latestLiveEquityValue);
      return;
    }
    portfolioErrorEl.textContent = "";

    const labels = buildLabels(views[0].view.times, rangeKey);
    const singleWallet = views.length === 1;
    const singleColors = { equity: "#8b5cf6", pnl: "#f59e0b", deposits: "#14b8a6" };
    const weightedEquity = buildWeightedSeries(views, labels, "equity");
    const weightedPnl = buildWeightedSeries(views, labels, "pnl");
    const weightedDeposits = buildWeightedSeries(views, labels, "deposits");
    const equityDatasets = [
      ...(weightedEquity ? [weightedEquity] : []),
      ...buildWalletDatasets(views, labels, "equity", singleWallet ? singleColors.equity : null),
    ];
    const pnlDatasets = [
      ...(weightedPnl ? [weightedPnl] : []),
      ...buildWalletDatasets(views, labels, "pnl", singleWallet ? singleColors.pnl : null),
    ];
    const depositsDatasets = [
      ...(weightedDeposits ? [weightedDeposits] : []),
      ...buildWalletDatasets(views, labels, "deposits", singleWallet ? singleColors.deposits : null),
    ];

    const { equity: equityChart, pnl: pnlChart, deposits: depositsChart } = portfolioCharts;
    if (!equityChart || !pnlChart || !depositsChart) {
      initPortfolioCharts(rangeKey);
      return;
    }

    equityChart.data.labels = labels;
    equityChart.data.datasets = equityDatasets;
    if (equityChart.options.plugins?.legend) {
      equityChart.options.plugins.legend.display = equityDatasets.length > 1;
    }
    applyEquityTooltipStyling(equityChart);
    equityChart.update();

    pnlChart.data.labels = labels;
    pnlChart.data.datasets = pnlDatasets;
    if (pnlChart.options.plugins?.legend) {
      pnlChart.options.plugins.legend.display = pnlDatasets.length > 1;
    }
    applyPnlTooltipStyling(pnlChart);
    pnlChart.update();

    depositsChart.data.labels = labels;
    depositsChart.data.datasets = depositsDatasets;
    if (depositsChart.options.plugins?.legend) {
      depositsChart.options.plugins.legend.display = depositsDatasets.length > 1;
    }
    applyDepositsTooltipStyling(depositsChart);
    depositsChart.update();
    chartLastValues.equity = getLastFiniteFromDatasets(equityDatasets);
    chartLastValues.pnl = getLastFiniteFromDatasets(pnlDatasets);
    chartLastValues.deposits = getLastFiniteFromDatasets(depositsDatasets);
    updateChartTitleValues(latestLiveEquityValue);
    updatePerformanceMetrics(rangeKey);
  }

  async function loadPortfolio(wallets = currentWallets) {
    try {
      portfolioErrorEl.textContent = "";
      setPortfolioLoadingState(true, "Loading performance graphsâ€¦");
      portfolioDataByWallet.clear();
      const walletList = Array.isArray(wallets) ? wallets : [wallets];

      await Promise.all(
        walletList.map(async (wallet) => {
          try {
            const data = await fetchPortfolio(wallet);
            portfolioDataByWallet.set(wallet, data);
          } catch (err) {
            console.error(`Portfolio error for ${wallet}`, err);
          }
        })
      );

      initPortfolioCharts(currentRangeKey);
    } catch (err) {
      console.error("Portfolio error", err);
      setPortfolioLoadingState(false, "");
      portfolioErrorEl.textContent = "Failed to load performance data: " + (err?.message || err);
    }
  }

  function updateChartTheme() {
    const gridColor = getChartGridColor();
    const textColor = getChartTextColor();
    Object.values(portfolioCharts).forEach((chart) => {
      if (!chart) return;
      chart.options.scales.y.grid.color = gridColor;
      if (chart.options.plugins?.legend?.labels) {
        chart.options.plugins.legend.labels.color = textColor;
      }
      chart.update();
    });
  }

  function applyTheme(theme) {
    const bodyEl = document.body;
    if (theme === "light") {
      bodyEl.classList.add("light");
      themeToggleBtn.textContent = "â˜€ï¸";
    } else {
      bodyEl.classList.remove("light");
      themeToggleBtn.textContent = "ðŸŒ™";
    }
    try { localStorage.setItem("hypermonitor-theme", theme); } catch (e) {}
    updateSpinnerForTheme(theme);
    updateChartTheme();
    updateBreakdownTheme();
  }

  function initTheme() {
    let initial = "dark";
    try {
      const saved = localStorage.getItem("hypermonitor-theme");
      if (saved === "light" || saved === "dark") initial = saved;
    } catch (e) {}
    applyTheme(initial);
  }

  // âœ… add optional options so boot can "replace" instead of "push"
  async function trackWallets(config, { replaceUrl = false } = {}) {
    const wallets = config?.wallets || [];
    const walletList = uniqueWallets((wallets || []).map(normalizeWalletInput)).filter(isValidAddress);
    if (!walletList.length) {
      snapshotErrorEl.textContent = "Please enter at least one valid 0x wallet address (40 hex chars).";
      return;
    }

    // âœ… persist both URL + localStorage
    setWalletsInUrl(walletList, { replace: replaceUrl });
    saveLastWallets(walletList);

    currentWallets = walletList;
    primaryWallet = walletList[0];
    updateFavoriteToggle();
    startedAtEl.textContent = "Started: " + new Date().toLocaleString();
    setStatus("connecting", "Connectingâ€¦");

    resetState();
    resetPortfolioSection();

    trackBtnEl.disabled = true;
    try {
      const spotMetaTask = ensureSpotMeta();
      await initClients();
      await spotMetaTask;
      const spotLoadTask = refreshSpotForWallets(walletList);
      await Promise.all([
        Promise.all(walletList.map((wallet) => loadSnapshot(wallet))),
        loadPortfolio(walletList),
        startStreams(walletList),
        ensureHistoricalDataLoaded(),
      ]);
      await initFooterStream();

      if (historyLayoutEl && !historyLayoutEl.classList.contains("hidden") && ordersHistoryPanelEl && !ordersHistoryPanelEl.classList.contains("hidden")) {
        await loadHistoricalOrders(walletList);
      }
      if (historyLayoutEl && !historyLayoutEl.classList.contains("hidden") && fillsHistoryPanelEl && !fillsHistoryPanelEl.classList.contains("hidden")) {
        await loadHistoricalFills(walletList);
      }
      if (currentMarketType === "spot") {
        await spotLoadTask;
      }
    } finally {
      trackBtnEl.disabled = false;
    }
  }

  (async function boot() {
    initTheme();
    updateMarketLabels();
    updateMarketToggleButtons();
    updatePerformanceVisibility();
    loadFooterCoins();
    loadFavoriteWallets();
    loadFooterChangePrefs();
    loadCoinNameCache();
    loadCoinColorCache();

    // âœ… Prefer: URL wallet > last saved wallet > default
    const urlWallets = uniqueWallets((getWalletsFromUrl() || []).filter(isValidAddress));
    const savedWallets = uniqueWallets((getLastWallets() || []).filter(isValidAddress));

    const initialWallets =
      (urlWallets.length && urlWallets) ||
      (savedWallets.length && savedWallets) ||
      [DEFAULT_WALLET];

    // âœ… show them in the inputs immediately
    setWalletInputs(initialWallets);

    startedAtEl.textContent = "Started: " + new Date().toLocaleString();
    setStatus("connecting", "Connectingâ€¦");
    updateFavoriteToggle();

    await initClients();

    // âœ… Replace URL on first load (so / becomes /?wallet=... without extra history)
    await trackWallets({ wallets: initialWallets }, { replaceUrl: true });
    await initFooterStream();
    updateMarketToggleIndicator();
    updateRangeToggleIndicator();
    updateTabSwitchIndicator(modeTabsEl);
    updateTabSwitchIndicator(modeTabsHistoryEl);
    updateTabSwitchIndicator(historyTabsEl);
  })();

  trackBtnEl.addEventListener("click", () => {
    const config = getWalletConfigFromInputs();
    if (config) trackWallets(config);
  });

  marketToggleButtons.forEach((btn) => {
    btn.addEventListener("click", async () => {
      const next = btn.dataset.market;
      await setMarketType(next);
      updateMarketToggleIndicator();
    });
  });

  window.addEventListener("resize", () => {
    updateMarketToggleIndicator();
    updateRangeToggleIndicator();
    updateTabSwitchIndicator(modeTabsEl);
    updateTabSwitchIndicator(modeTabsHistoryEl);
  });

  if (walletInputsEl) {
    walletInputsEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && e.target.classList.contains("wallet-input")) {
        const config = getWalletConfigFromInputs();
        if (config) trackWallets(config);
      }
    });

    walletInputsEl.addEventListener("click", (e) => {
      const removeBtn = e.target.closest(".wallet-remove-btn");
      if (removeBtn) {
        const row = removeBtn.closest(".wallet-input-row");
        if (row) row.remove();
      }
      const favBtn = e.target.closest(".wallet-fav-btn");
      if (favBtn) {
        const row = favBtn.closest(".wallet-input-row");
        const input = row?.querySelector(".wallet-input");
        const value = input?.value || "";
        if (!isValidAddress(value)) return;
        if (isFavoriteWallet(value)) removeFavoriteWallet(value);
        else addFavoriteWallet(value);
        syncWalletInputStars();
        renderFavoritesList();
      }
    });

    walletInputsEl.addEventListener("input", (e) => {
      if (e.target.classList.contains("wallet-input")) {
        syncWalletInputStars();
      }
    });
  }

  if (priceAddBtnEl) {
    priceAddBtnEl.addEventListener("click", async () => {
      const value = priceAddInputEl?.value || "";
      await toggleFooterCoin(value);
      if (priceAddInputEl) priceAddInputEl.value = "";
      updateFooterActionLabel();
    });
  }

  if (priceAddInputEl) {
    priceAddInputEl.addEventListener("keydown", async (e) => {
      if (e.key === "Enter") {
        await toggleFooterCoin(priceAddInputEl.value);
        priceAddInputEl.value = "";
        updateFooterActionLabel();
      }
    });

    priceAddInputEl.addEventListener("input", updateFooterActionLabel);
  }

  if (priceListEl) {
    let draggingCoin = null;
    let draggingEl = null;
    let lastDragOrder = null;

    const commitFooterOrder = (order) => {
      const ordered = Array.isArray(order)
        ? order
        : Array.from(priceListEl.querySelectorAll(".price-item"))
            .map((el) => el.dataset.coin)
            .filter(Boolean);
      if (!ordered.length) return;
      trackedFooterCoins = ordered;
      saveFooterCoins();
      renderFooterPrices();
    };

    const commitFooterOrderFromDom = () => {
      const ordered = Array.from(priceListEl.querySelectorAll(".price-item"))
        .map((el) => el.dataset.coin)
        .filter(Boolean);
      commitFooterOrder(ordered);
    };

    const getDragAfterElement = (container, x) => {
      const items = Array.from(container.querySelectorAll(".price-item:not(.dragging)"));
      let closest = null;
      let closestOffset = Number.NEGATIVE_INFINITY;
      items.forEach((item) => {
        const rect = item.getBoundingClientRect();
        const offset = x - rect.left - rect.width / 2;
        if (offset < 0 && offset > closestOffset) {
          closestOffset = offset;
          closest = item;
        }
      });
      return closest;
    };

    priceListEl.addEventListener("dragstart", (e) => {
      const item = e.target.closest(".price-item");
      if (!item) return;
      draggingCoin = item.dataset.coin;
      draggingEl = item;
      lastDragOrder = null;
      item.classList.add("dragging");
      e.dataTransfer.effectAllowed = "move";
      try { e.dataTransfer.setData("text/plain", draggingCoin); } catch (err) {}
    });

    priceListEl.addEventListener("dragend", (e) => {
      const item = e.target.closest(".price-item");
      if (item) item.classList.remove("dragging");
      commitFooterOrder(lastDragOrder);
      draggingCoin = null;
      draggingEl = null;
      lastDragOrder = null;
    });

    priceListEl.addEventListener("dragover", (e) => {
      if (!draggingEl) return;
      e.preventDefault();
      e.dataTransfer.dropEffect = "move";
      const after = getDragAfterElement(priceListEl, e.clientX);
      if (after === draggingEl) return;
      if (after == null) {
        priceListEl.appendChild(draggingEl);
      } else {
        priceListEl.insertBefore(draggingEl, after);
      }
      lastDragOrder = Array.from(priceListEl.querySelectorAll(".price-item"))
        .map((el) => el.dataset.coin)
        .filter(Boolean);
    });

    priceListEl.addEventListener("drop", (e) => {
      const item = e.target.closest(".price-item");
      if (!item || !draggingCoin) return;
      e.preventDefault();
      commitFooterOrderFromDom();
    });
  }

  if (positionsHeaderEls.length) {
    positionsHeaderEls.forEach((th) => {
      th.addEventListener("click", () => {
        const key = th.dataset.sort;
        if (!key) return;
        if (currentPositionsSort?.key === key) {
          currentPositionsSort.dir = currentPositionsSort.dir === "asc" ? "desc" : "asc";
        } else {
          currentPositionsSort = { key, dir: getPositionsSortDefaultDir(key) };
        }
        updatePositionsSortHeaders();
        renderPositions(currentAssetPositions);
      });
    });
    updatePositionsSortHeaders();
  }

  if (historicalOrdersHeaderEls.length) {
    historicalOrdersHeaderEls.forEach((th) => {
      th.addEventListener("click", () => {
        const key = th.dataset.sort;
        if (!key) return;
        if (currentHistoricalOrdersSort?.key === key) {
          currentHistoricalOrdersSort.dir = currentHistoricalOrdersSort.dir === "asc" ? "desc" : "asc";
        } else {
          currentHistoricalOrdersSort = { key, dir: getGenericSortDefaultDir(key) };
        }
        updateTableSortHeaders(historicalOrdersHeaderEls, currentHistoricalOrdersSort);
        renderHistoricalOrders();
      });
    });
    updateTableSortHeaders(historicalOrdersHeaderEls, currentHistoricalOrdersSort);
  }

  if (historicalFillsHeaderEls.length) {
    historicalFillsHeaderEls.forEach((th) => {
      th.addEventListener("click", () => {
        const key = th.dataset.sort;
        if (!key) return;
        if (currentHistoricalFillsSort?.key === key) {
          currentHistoricalFillsSort.dir = currentHistoricalFillsSort.dir === "asc" ? "desc" : "asc";
        } else {
          currentHistoricalFillsSort = { key, dir: getGenericSortDefaultDir(key) };
        }
        updateTableSortHeaders(historicalFillsHeaderEls, currentHistoricalFillsSort);
        renderHistoricalFills();
      });
    });
    updateTableSortHeaders(historicalFillsHeaderEls, currentHistoricalFillsSort);
  }

  if (priceFooterWrapEl) {
    priceFooterWrapEl.addEventListener("contextmenu", (e) => {
      if (
        e.target.closest(".price-controls") ||
        e.target.closest(".price-input") ||
        e.target.closest(".price-add-btn") ||
        e.target.closest(".price-logo")
      ) {
        return;
      }
      const item = e.target.closest(".price-item");
      e.preventDefault();
      showPriceContextMenu(e.clientX, e.clientY, item ? item.dataset.coin : null);
    });
  }

  if (priceContextMenuEl) {
    priceContextMenuEl.addEventListener("click", (e) => {
      const btn = e.target.closest("[data-action]");
      if (!btn) return;
      const action = btn.dataset.action;
      if (action === "remove" && priceContextCoin) {
        removeFooterCoin(priceContextCoin);
      } else if (action === "pin" && priceContextCoin) {
        const next = trackedFooterCoins.filter((c) => c !== priceContextCoin);
        next.unshift(priceContextCoin);
        trackedFooterCoins = next;
        saveFooterCoins();
        renderFooterPrices();
      } else if (action === "reset") {
        if (window.confirm("Reset the bottom bar to the default coins?")) {
          resetFooterCoins();
        }
      } else if (action === "toggle-change") {
        footerChangeEnabled = !footerChangeEnabled;
        saveFooterChangePrefs();
        applyFooterChangeVisibility();
        updateFooterChangeMenu();
        refreshFooterChanges();
      } else if (action === "change-range") {
        const range = btn.dataset.range;
        if (range && FOOTER_CHANGE_RANGES[range]) {
          footerChangeRange = range;
          saveFooterChangePrefs();
          updateFooterChangeMenu();
          refreshFooterChanges();
        }
      }
      hidePriceContextMenu();
    });
  }

  if (favoritesBtnEl) {
    favoritesBtnEl.addEventListener("click", () => {
      if (primaryWallet && isValidAddress(primaryWallet)) {
        if (isFavoriteWallet(primaryWallet)) removeFavoriteWallet(primaryWallet);
        else addFavoriteWallet(primaryWallet);
      }
      renderFavoritesList();
      toggleFavoritesPanel(true);
    });
  }

  if (favoritesPanelBtnEl) {
    favoritesPanelBtnEl.addEventListener("click", () => {
      toggleFavoritesPanel();
    });
  }

  if (favoritesCloseBtnEl) {
    favoritesCloseBtnEl.addEventListener("click", () => toggleFavoritesPanel(false));
    favoritesCloseBtnEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        toggleFavoritesPanel(false);
      }
    });
  }

  if (favoritesPanelEl) {
    favoritesPanelEl.addEventListener("click", (e) => {
      if (e.target === favoritesPanelEl) toggleFavoritesPanel(false);
    });
  }

  if (favoritesAddBtnEl) {
    favoritesAddBtnEl.addEventListener("click", () => {
      const value = favoritesInputEl?.value || "";
      if (!value) return;
      if (addFavoriteWallet(value)) {
        if (favoritesInputEl) favoritesInputEl.value = "";
        renderFavoritesList();
      }
    });
  }

  if (favoritesListEl) {
    favoritesListEl.addEventListener("click", async (e) => {
      const btn = e.target.closest("[data-action]");
      if (!btn) return;
      const action = btn.dataset.action;
      const wallet = btn.dataset.wallet;
      if (!wallet) return;
      if (action === "copy") {
        e.stopPropagation();
        const toast = btn.parentElement?.querySelector(".favorites-copy-toast");
        try {
          await navigator.clipboard.writeText(wallet);
          if (toast) {
            toast.classList.add("show");
            clearTimeout(toast._hideTimer);
            toast._hideTimer = setTimeout(() => {
              toast.classList.remove("show");
            }, 1200);
          }
        } catch (err) {
          console.warn("Copy failed", err);
        }
        return;
      }
      if (action === "remove") {
        removeFavoriteWallet(wallet);
        renderFavoritesList();
        return;
      }
      if (action === "open") {
        toggleFavoritesPanel(false);
        await trackWallets({ wallets: [wallet] });
        setWalletInputs([wallet]);
      }
    });

    favoritesListEl.addEventListener("click", async (e) => {
      const actionBtn = e.target.closest("[data-action]");
      if (actionBtn) return;
      const item = e.target.closest(".favorites-item");
      if (!item) return;
      const wallet = item.dataset.wallet;
      if (!wallet) return;
      toggleFavoritesPanel(false);
      await trackWallets({ wallets: [wallet] });
      setWalletInputs([wallet]);
    });
  }

  document.addEventListener("click", (e) => {
    if (!priceContextMenuEl || !priceContextMenuEl.classList.contains("show")) return;
    if (e.target.closest("#priceContextMenu")) return;
    hidePriceContextMenu();
  });

  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape") hidePriceContextMenu();
  });

  window.addEventListener("resize", hidePriceContextMenu);
  window.addEventListener("scroll", hidePriceContextMenu, true);

  window.addEventListener("resize", () => {
    updatePriceTickerRolling();
  });

  if (addWalletBtnEl) {
    addWalletBtnEl.addEventListener("click", () => {
      addWalletInputRow("");
      const inputs = getWalletInputEls();
      const last = inputs[inputs.length - 1];
      if (last) last.focus();
    });
  }

  rangeButtons.forEach((btn) => {
    btn.addEventListener("click", () => {
      const range = btn.dataset.range;
      currentRangeKey = range;

      rangeButtons.forEach((b) => b.classList.remove("active"));
      btn.classList.add("active");
      updateRangeToggleIndicator();
      updateTotalPnlSubLabel(currentRangeKey);

      if (portfolioDataByWallet.size) {
        updatePortfolioCharts(currentRangeKey);
      } else {
        updatePerformanceMetrics(currentRangeKey);
      }
    });
  });

  let lastHistoryFocus = "orders";
  function setHistoryMode(enabled, focus = lastHistoryFocus) {
    if (liveLayoutEl) liveLayoutEl.classList.toggle("hidden", enabled);
    if (historyLayoutEl) historyLayoutEl.classList.toggle("hidden", !enabled);
    if (!enabled) {
      ordersLivePanelEl?.classList.remove("hidden");
      fillsLivePanelEl?.classList.remove("hidden");
      modeTabButtons.forEach((b) => b.classList.toggle("active", b.dataset.tab === "live"));
      updateTabSwitchIndicator(modeTabsEl);
      updateTabSwitchIndicator(modeTabsHistoryEl);
      return;
    }

    const isOrders = focus === "orders";
    lastHistoryFocus = isOrders ? "orders" : "fills";
    if (ordersHistoryPanelEl) ordersHistoryPanelEl.classList.toggle("hidden", !isOrders);
    if (fillsHistoryPanelEl) fillsHistoryPanelEl.classList.toggle("hidden", isOrders);
    historyTabButtons.forEach((b) => b.classList.toggle("active", b.dataset.tab === (isOrders ? "orders-history" : "fills-history")));
    updateTabSwitchIndicator(historyTabsEl);
    modeTabButtons.forEach((b) => b.classList.toggle("active", b.dataset.tab === "history"));
    updateTabSwitchIndicator(modeTabsEl);
    updateTabSwitchIndicator(modeTabsHistoryEl);
  }

  if (metricsToggleEl && metricsCardEl) {
    metricsToggleEl.addEventListener("click", () => {
      const isCollapsed = metricsCardEl.classList.toggle("collapsed");
      const icon = metricsToggleEl.querySelector("[aria-hidden='true']");
      if (icon) icon.textContent = isCollapsed ? "â–¾" : "â–´";
      metricsToggleEl.setAttribute("aria-expanded", String(!isCollapsed));
      if (metricsGridEl) {
        const maxScroll = metricsGridEl.scrollWidth - metricsGridEl.clientWidth;
        const leftOk = metricsGridEl.scrollLeft > 2;
        const rightOk = metricsGridEl.scrollLeft < maxScroll - 2;
        metricsCardEl.classList.toggle("show-left", isCollapsed && leftOk);
        metricsCardEl.classList.toggle("show-right", isCollapsed && rightOk);
      }
    });
  }

  if (metricsGridEl) {
    let isDragging = false;
    let dragStartX = 0;
    let dragScrollLeft = 0;

    const updateMetricsScrollArrows = () => {
      if (!metricsCardEl) return;
      if (!metricsCardEl.classList.contains("collapsed")) {
        metricsCardEl.classList.remove("show-left", "show-right");
        return;
      }
      const maxScroll = metricsGridEl.scrollWidth - metricsGridEl.clientWidth;
      const leftOk = metricsGridEl.scrollLeft > 2;
      const rightOk = metricsGridEl.scrollLeft < maxScroll - 2;
      metricsCardEl.classList.toggle("show-left", leftOk);
      metricsCardEl.classList.toggle("show-right", rightOk);
    };

    const scrollMetricsBy = (dir = 1, multiplier = 1) => {
      const base = Math.max(metricsGridEl.clientWidth * 0.6, 180);
      metricsGridEl.scrollBy({ left: base * dir * multiplier, behavior: "smooth" });
    };
    const scrollMetricsStep = (dir = 1) => scrollMetricsBy(dir, 0.25);

    const leftArrow = metricsCardEl?.querySelector(".metrics-scroll-arrow.left");
    const rightArrow = metricsCardEl?.querySelector(".metrics-scroll-arrow.right");
    let metricsHoldTimer = null;
    const clearMetricsHold = () => {
      if (metricsHoldTimer) {
        clearInterval(metricsHoldTimer);
        metricsHoldTimer = null;
      }
    };

    if (leftArrow) {
      leftArrow.addEventListener("click", (e) => {
        e.preventDefault();
        scrollMetricsBy(-1);
      });
      leftArrow.addEventListener("mousedown", (e) => {
        e.preventDefault();
        clearMetricsHold();
        metricsHoldTimer = setInterval(() => scrollMetricsStep(-1), 120);
      });
      leftArrow.addEventListener("mouseup", clearMetricsHold);
      leftArrow.addEventListener("mouseleave", clearMetricsHold);
      leftArrow.addEventListener("touchstart", (e) => {
        e.preventDefault();
        clearMetricsHold();
        metricsHoldTimer = setInterval(() => scrollMetricsStep(-1), 120);
      }, { passive: false });
      leftArrow.addEventListener("touchend", clearMetricsHold);
    }
    if (rightArrow) {
      rightArrow.addEventListener("click", (e) => {
        e.preventDefault();
        scrollMetricsBy(1);
      });
      rightArrow.addEventListener("mousedown", (e) => {
        e.preventDefault();
        clearMetricsHold();
        metricsHoldTimer = setInterval(() => scrollMetricsStep(1), 120);
      });
      rightArrow.addEventListener("mouseup", clearMetricsHold);
      rightArrow.addEventListener("mouseleave", clearMetricsHold);
      rightArrow.addEventListener("touchstart", (e) => {
        e.preventDefault();
        clearMetricsHold();
        metricsHoldTimer = setInterval(() => scrollMetricsStep(1), 120);
      }, { passive: false });
      rightArrow.addEventListener("touchend", clearMetricsHold);
    }

    metricsGridEl.addEventListener("mousedown", (e) => {
      if (!metricsCardEl?.classList.contains("collapsed")) return;
      isDragging = true;
      dragStartX = e.pageX - metricsGridEl.offsetLeft;
      dragScrollLeft = metricsGridEl.scrollLeft;
    });

    metricsGridEl.addEventListener("mouseleave", () => {
      isDragging = false;
    });

    metricsGridEl.addEventListener("mouseup", () => {
      isDragging = false;
    });

    metricsGridEl.addEventListener("mousemove", (e) => {
      if (!isDragging) return;
      e.preventDefault();
      const x = e.pageX - metricsGridEl.offsetLeft;
      const walk = x - dragStartX;
      metricsGridEl.scrollLeft = dragScrollLeft - walk;
    });

    metricsGridEl.addEventListener("scroll", updateMetricsScrollArrows);
    window.addEventListener("resize", updateMetricsScrollArrows);
    updateMetricsScrollArrows();
  }

  const metricTooltipEl = document.getElementById("metricTooltip");
  let activeMetricTooltip = null;

  function hideMetricTooltip() {
    if (!metricTooltipEl) return;
    metricTooltipEl.classList.remove("show");
    metricTooltipEl.setAttribute("aria-hidden", "true");
    activeMetricTooltip = null;
  }

  function showMetricTooltip(metric) {
    if (!metricTooltipEl) return;
    const label = metric.querySelector(".metric-label[data-tooltip]");
    const text = label?.dataset?.tooltip || label?.getAttribute("title");
    if (!text) return;
    metricTooltipEl.textContent = text;
    metricTooltipEl.classList.add("show");
    metricTooltipEl.setAttribute("aria-hidden", "false");
    metricTooltipEl.style.visibility = "hidden";
    metricTooltipEl.style.left = "0px";
    metricTooltipEl.style.top = "0px";

    const rect = metric.getBoundingClientRect();
    const tooltipRect = metricTooltipEl.getBoundingClientRect();
    const padding = 8;
    let placement = "top";
    let top = rect.top - tooltipRect.height - 10;
    if (top < padding) {
      top = rect.bottom + 10;
      placement = "bottom";
    }
    let left = rect.left + rect.width / 2 - tooltipRect.width / 2;
    left = Math.max(padding, Math.min(left, window.innerWidth - tooltipRect.width - padding));

    metricTooltipEl.dataset.placement = placement;
    metricTooltipEl.style.left = `${Math.round(left)}px`;
    metricTooltipEl.style.top = `${Math.round(top)}px`;
    metricTooltipEl.style.visibility = "visible";
    activeMetricTooltip = metric;
  }

  if (metricsCardEl) {
    metricsCardEl.addEventListener("mouseover", (event) => {
      const metric = event.target.closest(".metric");
      if (!metric || !metricsCardEl.contains(metric)) return;
      if (activeMetricTooltip !== metric) showMetricTooltip(metric);
    });

    metricsCardEl.addEventListener("mouseout", (event) => {
      const metric = event.target.closest(".metric");
      if (!metric) return;
      const related = event.relatedTarget;
      if (metric.contains(related)) return;
      hideMetricTooltip();
    });
  }

  document.addEventListener("click", (event) => {
    if (metricsCardEl && metricsCardEl.contains(event.target)) return;
    if (metricTooltipEl && metricTooltipEl.contains(event.target)) return;
    hideMetricTooltip();
  });

  window.addEventListener("scroll", () => {
    if (activeMetricTooltip) hideMetricTooltip();
  });

  themeToggleBtn.addEventListener("click", () => {
    const isLight = document.body.classList.contains("light");
    applyTheme(isLight ? "dark" : "light");
  });

  if (exportExcelBtn) {
    exportExcelBtn.addEventListener("click", async () => {
      exportExcelBtn.disabled = true;
      await triggerExcelDownload();
      exportExcelBtn.disabled = false;
    });
  }

  if (positionsChartBtn) {
    positionsChartBtn.addEventListener("click", () => {
      openPortfolioModal();
    });
  }

  if (portfolioModalCloseEl) {
    portfolioModalCloseEl.addEventListener("click", closePortfolioModal);
  }

  if (portfolioModalEl) {
    portfolioModalEl.addEventListener("click", (e) => {
      if (e.target === portfolioModalEl) closePortfolioModal();
    });
  }

  async function handlePnlShareClick(shareBtn) {
    const payload = {
      wallet: shareBtn.dataset.wallet || "",
      asset: shareBtn.dataset.asset || "",
      coin: shareBtn.dataset.coin || "",
      spot: shareBtn.dataset.spot || "false",
      direction: shareBtn.dataset.direction || "",
      upnl: shareBtn.dataset.upnl || "",
      roe: shareBtn.dataset.roe || "",
      entry: shareBtn.dataset.entry || "",
      current: shareBtn.dataset.current || "",
    };
    const dataUrl = await buildPnlShareImage(payload);
    if (dataUrl) {
      openPnlShareModal(dataUrl, {
        modalTitle: "Share Asset Performance",
        filename: "hypermonitor-pnl.png",
        title: "Hypermonitor PnL",
        text: "Discover Hypermonitor",
      });
    } else {
      console.error("Share image generation failed");
    }
  }

  async function handlePerformanceShareClick() {
    const result = await buildPerformanceShareImage();
    if (!result || !result.dataUrl) {
      console.error("Performance share image generation failed");
      return;
    }
    const rangeLabel = getRangeLabel(currentRangeKey);
    const rangeSlug = result.rangeSlug || slugifyLabel(rangeLabel) || "all-time";
    openPnlShareModal(result.dataUrl, {
      modalTitle: `Share Performance (${rangeLabel})`,
      filename: `hypermonitor-performance-${rangeSlug}.png`,
      title: "Hypermonitor Performance",
      text: `Hypermonitor performance Â· ${rangeLabel}`,
    });
  }

  if (performanceShareBtnEl) {
    performanceShareBtnEl.addEventListener("click", async () => {
      performanceShareBtnEl.disabled = true;
      try {
        await handlePerformanceShareClick();
      } finally {
        performanceShareBtnEl.disabled = false;
      }
    });
  }

  document.addEventListener("click", async (e) => {
    const shareBtn = e.target.closest(".pnl-share-btn");
    if (!shareBtn) return;
    e.stopPropagation();
    await handlePnlShareClick(shareBtn);
  });

  if (positionsBodyEl) {
    positionsBodyEl.addEventListener("click", async (e) => {
      const shareBtn = e.target.closest(".pnl-share-btn");
      if (shareBtn) return;
      const row = e.target.closest(".position-row");
      if (!row) return;
      row.classList.add("loading");
      const coin = row.dataset.coin;
      const wallet = row.dataset.wallet || primaryWallet;
      const market = row.dataset.market || currentMarketType;
      if (!coin) return;
      if (!historicalFillsLoaded) await ensureHistoricalDataLoaded();
      const positionKey = `${market}:${wallet}:${coin}`;
      if (expandedPositions.has(positionKey)) expandedPositions.delete(positionKey);
      else expandedPositions.add(positionKey);
      renderPositions(currentAssetPositions);
      requestAnimationFrame(() => row.classList.remove("loading"));
    });
  }

  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && portfolioModalEl?.classList.contains("open")) {
      closePortfolioModal();
    }
    if (e.key === "Escape" && pnlShareModalEl?.classList.contains("open")) {
      closePnlShareModal();
    }
  });

  if (shareModalCloseEl) {
    shareModalCloseEl.addEventListener("click", () => closePnlShareModal());
  }

  if (pnlShareModalEl) {
    pnlShareModalEl.addEventListener("click", (e) => {
      if (e.target === pnlShareModalEl) closePnlShareModal();
    });
  }

  if (shareSaveBtnEl) {
    shareSaveBtnEl.addEventListener("click", () => {
      if (!sharePreviewImgEl?.src) return;
      const link = document.createElement("a");
      link.href = sharePreviewImgEl.src;
      link.download = activeShareMeta.filename || "hypermonitor-pnl.png";
      document.body.appendChild(link);
      link.click();
      link.remove();
    });
  }


  if (shareNativeBtnEl) {
    shareNativeBtnEl.addEventListener("click", async () => {
      if (!sharePreviewImgEl?.src) return;
      try {
        const res = await fetch(sharePreviewImgEl.src);
        const blob = await res.blob();
        const file = new File([blob], activeShareMeta.filename || "hypermonitor-pnl.png", { type: "image/png" });
        if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
          await navigator.share({
            files: [file],
            text: activeShareMeta.text || "Discover Hypermonitor",
            title: activeShareMeta.title || "Hypermonitor PnL",
          });
        } else {
          const link = document.createElement("a");
          link.href = sharePreviewImgEl.src;
          link.download = activeShareMeta.filename || "hypermonitor-pnl.png";
          document.body.appendChild(link);
          link.click();
          link.remove();
        }
      } catch (err) {
        console.error("Share failed", err);
      }
    });
  }

  modeTabButtons.forEach((btn) => {
    btn.addEventListener("click", () => {
      const tab = btn.dataset.tab;
      modeTabButtons.forEach((b) => b.classList.remove("active"));
      btn.classList.add("active");
      updateTabSwitchIndicator(btn.closest(".orders-tabs"));

      if (tab === "history") {
        setHistoryMode(true, lastHistoryFocus);
        if (lastHistoryFocus === "orders") {
          if (currentWallets.length) loadHistoricalOrders(currentWallets);
        } else {
          if (currentWallets.length) loadHistoricalFills(currentWallets);
        }
      } else {
        setHistoryMode(false);
      }
    });
  });

  historyTabButtons.forEach((btn) => {
    btn.addEventListener("click", () => {
      const tab = btn.dataset.tab;
      const isOrders = tab === "orders-history";
      setHistoryMode(true, isOrders ? "orders" : "fills");
      if (isOrders) {
        if (currentWallets.length) loadHistoricalOrders(currentWallets);
      } else {
        if (currentWallets.length) loadHistoricalFills(currentWallets);
      }
    });
  });

  if (historicalSideFilterEl) {
    historicalSideFilterEl.addEventListener("change", () => {
      if (historicalOrdersLoaded) renderHistoricalOrders();
    });
  }

  if (historicalStatusFilterEl) {
    historicalStatusFilterEl.addEventListener("change", () => {
      if (historicalOrdersLoaded) renderHistoricalOrders();
    });
  }

  if (historicalAssetFilterEl) {
    historicalAssetFilterEl.addEventListener("input", () => {
      if (historicalOrdersLoaded) renderHistoricalOrders();
    });
  }

  // âœ… Back/Forward support (donâ€™t push a new history entry)
  window.addEventListener("popstate", () => {
    const wallets = uniqueWallets((getWalletsFromUrl() || []).filter(isValidAddress));
    if (wallets.length && wallets.join("|") !== currentWallets.join("|")) {
      setWalletInputs(wallets);
      trackWallets({ wallets }, { replaceUrl: true });
    }
  });
</script>
</body>
</html>
