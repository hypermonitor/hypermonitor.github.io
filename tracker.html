<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hypermonitor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Hyperliquid wallet tracker" />

  <meta property="og:title" content="Hyperliquid wallet tracker" />
  <meta property="og:description" content="Track any Hyperliquid wallet: positions, orders, fills, and performance." />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Hypermonitor" />
  <meta property="og:image" content="https://cdnstatic.tencentcs.com/edgeone/pages/assets/1765821358918-2Psz.png" />
  <meta property="og:image:width" content="1200" />
  <meta property="og:image:height" content="630" />
  <meta property="og:url" content="https://www.hypermonitor.org/" />
  <link rel="canonical" href="https://www.hypermonitor.org/" />

  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Hyperliquid wallet tracker" />
  <meta name="twitter:description" content="Track any Hyperliquid wallet: positions, orders, fills, and performance." />
  <meta name="twitter:image" content="https://cdnstatic.tencentcs.com/edgeone/pages/assets/1765821358918-2Psz.png" />

  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,
  <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'>
    <defs>
      <linearGradient id='g' x1='0' y1='0' x2='1' y2='1'>
        <stop offset='0%25' stop-color='%2326d97f'/>
        <stop offset='100%25' stop-color='%2338bdf8'/>
      </linearGradient>
    </defs>
    <circle cx='32' cy='32' r='22' fill='url(%23g)'/>
  </svg>"/>

  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color-scheme: dark;
      --bg: #101014;
      --card-bg: #17181f;
      --accent: #26d97f;
      --accent-soft: rgba(38, 217, 127, 0.18);
      --danger: #f25f5c;
      --muted: #a1a1b5;
      --border: #262637;
      --text-main: #f5f5ff;
    }

    * { box-sizing: border-box; }

    body { margin: 0; padding: 0; background: var(--bg); color: var(--text-main); }
    #app { max-width: 1200px; margin: 0 auto; padding: 1.5rem; }

    header {
      display: flex; flex-wrap: wrap; justify-content: space-between;
      gap: 1rem; align-items: center; margin-bottom: 1.5rem;
    }

    header h1 {
      font-size: 1.8rem; margin: 0 0 .4rem;
      display: flex; align-items: center; gap: .55rem;
      font-family: Arial, "Helvetica Neue", sans-serif;
      font-weight: 400; letter-spacing: 0.01em;
    }
    header h1 span.logo-dot {
      width: .7rem; height: .7rem; border-radius: 999px;
      background: linear-gradient(135deg, #26d97f, #38bdf8);
      box-shadow: 0 0 6px rgba(56, 189, 248, 0.7);
      flex-shrink: 0;
    }
    header h1 .logo-word { display: inline-block; }
    header h1 .logo-word-regular { font-style: normal; }
    header h1 .logo-word-italic { font-style: italic; }

    .wallet-controls { display: flex; flex-direction: column; gap: .35rem; max-width: 680px; width: 100%; }
    .tagline { font-size: 0.8rem; color: var(--muted); margin-bottom: 0.5rem; }

    .wallet-input-row {
      display: flex; align-items: center; gap: .4rem; width: 100%; flex-wrap: wrap;
    }
    .wallet-input-row label { font-size: .8rem; color: var(--muted); white-space: nowrap; }
    .wallet-input-row input {
      flex: 1 1 340px;
      padding: 0.35rem 0.6rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #17181f;
      color: var(--text-main);
      font-size: 0.8rem;
      outline: none;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    .wallet-input-row input:focus {
      border-color: #97fde5;
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.4);
    }
    .wallet-input-row button {
      padding: 0.35rem 0.9rem;
      border-radius: 999px;
      border: 1px solid #1fa766;
      background: #26d97f;
      color: #050810;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      white-space: nowrap;
      flex: 0 0 auto;
    }
    .wallet-input-row button:hover:not(:disabled) { filter: brightness(1.05); }
    .wallet-input-row button:disabled { opacity: 0.5; cursor: default; }

    @media (max-width: 600px) {
      .wallet-input-row { flex-direction: column; align-items: stretch; }
      .wallet-input-row input { flex: 1 1 auto; width: 100%; }
      .wallet-input-row button { width: 100%; }
      .header-right { width: 100%; align-items: flex-end; }
      .header-right-top { width: 100%; justify-content: flex-end; }
    }

    .header-right { display: flex; flex-direction: column; align-items: flex-end; gap: 0.25rem; }
    .header-right-top { display: flex; align-items: center; gap: 0.5rem; }

    .theme-toggle-btn {
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #17181f;
      color: var(--text-main);
      font-size: 0.75rem;
      padding: 0.25rem 0.7rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }
    .theme-toggle-btn:hover { filter: brightness(1.07); }

    .status-pill {
      display: inline-flex; align-items: center; gap: 0.4rem;
      padding: 0.25rem 0.6rem; border-radius: 9999px;
      font-size: 0.75rem; border: 1px solid var(--border);
      background: #17181f; color: var(--text-main);
    }
    .status-dot {
      width: 0.55rem; height: 0.55rem; border-radius: 999px;
      background: #fbbf24; box-shadow: 0 0 4px rgba(251, 191, 36, 0.6);
    }
    .status-dot.connected { background: var(--accent); box-shadow: 0 0 6px rgba(34, 197, 94, 0.7); }
    .status-dot.error { background: var(--danger); box-shadow: 0 0 6px rgba(248, 113, 113, 0.7); }

    .status-spinner {
      width: 18px; height: 18px; border-radius: 999px;
      object-fit: contain; display: none; margin-left: 0.15rem;
    }

    .status-logo { display: inline-flex; align-items: center; margin-left: 0.25rem; }
    .status-logo.hidden { display: none; }
    .status-logo svg { height: 12px; width: auto; }
    body:not(.light) .status-logo { color: #97fde5; }
    body.light .status-logo { color: #072722; }
    .status-logo-link { display: inline-flex; align-items: center; text-decoration: none; color: inherit; cursor: pointer; }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .card {
      background: var(--card-bg);
      border-radius: 0.85rem;
      border: 1px solid var(--border);
      padding: 1rem;
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.7);
      position: relative;
      overflow: hidden;
    }

    .card h2 {
      margin: 0 0 0.75rem;
      font-size: 1rem;
      display: flex;
      align-items: center;
      gap: .4rem;
    }

    .card h2 span.badge {
      font-size: .65rem;
      padding: 0.05rem 0.35rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
    }

    .kv-list {
      font-size: 0.85rem;
      display: grid;
      grid-template-columns: 1.1fr 1.3fr;
      gap: .25rem .5rem;
    }
    .kv-label { color: var(--muted); }
    .kv-value { text-align: right; }

    table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
    thead { background: #17181f; position: sticky; top: 0; z-index: 1; }
    th, td {
      padding: 0.35rem 0.45rem;
      text-align: left;
      border-bottom: 1px solid var(--border);
      white-space: nowrap;
    }
    tbody tr:nth-child(even) { background: #14141c; }

    .pill {
      display: inline-flex;
      padding: 0.15rem 0.45rem;
      border-radius: 9999px;
      font-size: 0.7rem;
      border: 1px solid rgba(148, 163, 184, 0.4);
    }
    .pill-buy { color: #4ade80; border-color: rgba(34, 197, 94, 0.6); background: rgba(22, 163, 74, 0.12); }
    .pill-sell { color: #f97373; border-color: rgba(248, 113, 113, 0.6); background: rgba(220, 38, 38, 0.12); }

    .muted { color: var(--muted); }
    .money { font-variant-numeric: tabular-nums; }
    .error { margin-top: .5rem; font-size: .75rem; color: #fecaca; }
    .timestamp { font-size: 0.75rem; color: var(--muted); }

    .layout-two {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 0.9fr);
      gap: 1rem;
      margin-bottom: 1.5rem;
    }
    @media (max-width: 900px) { .layout-two { grid-template-columns: 1fr; } }

    /* Performance charts */
    .chart-toolbar { display: flex; flex-wrap: wrap; gap: 0.4rem; margin-bottom: 0.5rem; font-size: 0.8rem; }
    .chart-range-btn {
      border-radius: 999px; border: 1px solid var(--border);
      background: #17181f; color: var(--muted);
      padding: 0.2rem 0.8rem; cursor: pointer;
      transition: background 0.15s ease, border-color 0.15s ease, color 0.15s ease, box-shadow 0.15s ease;
    }
    .chart-range-btn:hover { border-color: rgba(148, 163, 184, 0.8); }
    .chart-range-btn.active { border-color: #1fa766; color: #1fa766; background: #101018; }

    .chart-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 0.75rem; margin-top: 0.5rem; }
    .chart-card {
      background: #17181f; border-radius: 0.75rem; border: 1px solid var(--border);
      padding: 0.6rem 0.75rem 0.75rem;
      position: relative; overflow: hidden;
      display: flex; flex-direction: column; min-height: 220px;
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.7);
    }
    .chart-card h3 { margin: 0 0 0.25rem; font-size: 0.85rem; display: flex; align-items: center; gap: 0.35rem; }
    .chart-card h3 span.spark-label { font-size: 0.7rem; color: var(--muted); font-weight: 400; }
    .chart-canvas-wrap { position: relative; flex: 1 1 auto; min-height: 170px; }
    .chart-canvas-wrap canvas { width: 100% !important; height: 100% !important; }
    .chart-loading { font-size: 0.8rem; color: var(--muted); margin-top: 0.3rem; }

    /* Orders tabs */
    .orders-tabs { display: flex; gap: 0.4rem; margin: 0.25rem 0 0.75rem; font-size: 0.8rem; }
    .orders-tab-btn {
      padding: 0.2rem 0.8rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #17181f;
      color: var(--muted);
      cursor: pointer;
      white-space: nowrap;
      font-size: 0.75rem;
      transition: background 0.15s ease, border-color 0.15s ease, color 0.15s ease, box-shadow 0.15s ease;
    }
    .orders-tab-btn:hover { border-color: rgba(148, 163, 184, 0.8); }
    .orders-tab-btn.active { border-color: #1fa766; color: #1fa766; background: #101018; }
    .tab-panel.hidden { display: none; }

    .orders-filter-bar { display: flex; flex-wrap: wrap; gap: 0.4rem; margin: 0.25rem 0 0.75rem; font-size: 0.8rem; }
    .orders-filter-group { display: flex; align-items: center; gap: 0.25rem; }
    .orders-filter-label { color: var(--muted); font-size: 0.75rem; white-space: nowrap; }
    .orders-filter-input, .orders-filter-select {
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #17181f;
      color: var(--text-main);
      font-size: 0.75rem;
      padding: 0.2rem 0.6rem;
      min-width: 80px;
      max-width: 140px;
      outline: none;
    }
    .orders-filter-input::placeholder { color: var(--muted); opacity: 0.7; }

    /* Light theme */
    body.light { background: #ffffff; color: #0f172a; color-scheme: light; }
    body.light #app { color: #0f172a; }
    body.light .theme-toggle-btn { background: #ffffff; color: #0f172a; border-color: #d1d5db; }
    body.light .wallet-input-row input { background: #ffffff; color: #0f172a; border-color: #d1d5db; }
    body.light .wallet-input-row input:focus { border-color: #38bdf8; box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.4); }
    body.light .status-pill { background: #ffffff; border-color: #e5e7eb; color: #0f172a; }
    body.light .card { background: #ffffff; border: 1px solid #e5e7eb; box-shadow: 0 16px 30px rgba(15, 23, 42, 0.06); }
    body.light .card h2 span.badge { border-color: #e5e7eb; color: #6b7280; }
    body.light .kv-label, body.light .muted, body.light .timestamp { color: #6b7280; }
    body.light table { color: #0f172a; }
    body.light thead { background: #f9fafb; }
    body.light th, body.light td { border-bottom: 1px solid #e5e7eb; }
    body.light tbody tr:nth-child(even) { background: #f9fafb; }
    body.light .chart-range-btn { background: #ffffff; color: #6b7280; border-color: #e5e7eb; }
    body.light .chart-range-btn:hover { border-color: #d1d5db; }
    body.light .chart-range-btn.active { border-color: #1fa766; color: #1fa766; }
    body.light .chart-card { background: #ffffff; border: 1px solid #e5e7eb; box-shadow: 0 10px 24px rgba(15, 23, 42, 0.04); }
    body.light .orders-tab-btn { background: #ffffff; border-color: #e5e7eb; color: #6b7280; }
    body.light .orders-tab-btn:hover { border-color: #d1d5db; }
    body.light .orders-tab-btn.active { border-color: #1fa766; color: #1fa766; background: #f9fafb; }
    body.light .orders-filter-input, body.light .orders-filter-select { background: #ffffff; border-color: #e5e7eb; color: #0f172a; }

    /* ===== Positions expandable chart UI ===== */
    tr.pos-row { cursor: pointer; }
    tr.pos-row:hover { filter: brightness(1.05); }
    tr.pos-row.active { outline: 1px solid rgba(38,217,127,0.35); outline-offset: -1px; }

    tr.pos-expand-row td { padding: 0.55rem 0.55rem 0.75rem; background: rgba(23,24,31,0.55); }
    body.light tr.pos-expand-row td { background: rgba(249,250,251,0.9); }

    .pos-expand-wrap {
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      overflow: hidden;
      background: rgba(0,0,0,0); /* let the page bg show through */
    }
    body.light .pos-expand-wrap { background: rgba(0,0,0,0); border-color: #e5e7eb; }

    .pos-expand-topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      padding: 0.45rem 0.6rem;
      border-bottom: 1px solid var(--border);
      background: rgba(23,24,31,0.7);
    }
    body.light .pos-expand-topbar { background: #f9fafb; border-color: #e5e7eb; }

    .pos-expand-title {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.85rem;
      color: var(--text-main);
    }
    body.light .pos-expand-title { color: #0f172a; }

    .pos-ivl {
      display: inline-flex;
      gap: 0.35rem;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .pos-ivl-btn {
      border-radius: 999px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--muted);
      padding: 0.18rem 0.6rem;
      cursor: pointer;
      font-size: 0.75rem;
      transition: border-color 0.15s ease, color 0.15s ease, background 0.15s ease;
    }
    .pos-ivl-btn:hover { border-color: rgba(148,163,184,0.8); }
    .pos-ivl-btn.active { border-color: #1fa766; color: #1fa766; background: rgba(31,167,102,0.08); }
    body.light .pos-ivl-btn { border-color: #e5e7eb; color: #6b7280; }
    body.light .pos-ivl-btn:hover { border-color: #d1d5db; }
    body.light .pos-ivl-btn.active { border-color: #1fa766; color: #1fa766; background: rgba(31,167,102,0.08); }

    .pos-chart {
      height: 340px;
      width: 100%;
      position: relative; /* for overlay canvas */
    }

    /* overlay canvas for HL-style markers */
    canvas.pos-marker-overlay {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
    }

    .pos-chart-status {
      padding: 0.5rem 0.6rem;
      font-size: 0.8rem;
      color: var(--muted);
    }
  </style>
</head>

<body>
<div id="app">
  <header>
    <div class="wallet-controls">
      <h1>
        <span class="logo-dot"></span>
        <span class="logo-word logo-word-regular">Hyper<span class="logo-word logo-word-italic">monitor</span></span>
      </h1>
      <div class="tagline">Track any Hyperliquid wallet: positions, orders, fills, and performance.</div>
      <div class="wallet-input-row">
        <label for="walletInput">Wallet address:</label>
        <input id="walletInput" type="text" placeholder="0x..." autocomplete="off" />
        <button id="trackBtn">Track</button>
      </div>
    </div>

    <div class="header-right">
      <div class="header-right-top">
        <button id="themeToggle" class="theme-toggle-btn">☀️ Light</button>
        <div class="status-pill">
          <span id="statusDot" class="status-dot"></span>
          <span id="statusText"></span>
          <img id="statusSpinner" class="status-spinner" alt="Connecting to Hyperliquid" />
          <span class="status-logo hidden" aria-hidden="true">
            <a href="https://hyperfoundation.org/" target="_blank" rel="noopener noreferrer" class="status-logo-link">
              <!-- Hyperliquid logo -->
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 179 28">
                <g clip-path="url(#clip0_975_1209)" fill="currentColor">
                  <path d="M31.8056 11.727C31.8346 14.3384 31.2881 16.8337 30.2146 19.2178C28.6816 22.6126 25.0063 25.3885 21.6501 22.4337C18.913 20.0254 18.4052 15.1363 14.3044 14.4206C8.87845 13.7629 8.74788 20.0544 5.20315 20.7653C1.2522 21.5681 -0.0583338 14.9235 -0.000302664 11.9059C0.0577284 8.88828 0.860492 4.64717 4.294 4.64717C8.24495 4.64717 8.51092 10.6292 13.5258 10.3052C18.4923 9.96669 18.5793 3.74285 21.8242 1.07826C24.6242 -1.22364 27.9175 0.464096 29.5665 3.23508C31.0947 5.79812 31.7669 8.80606 31.8007 11.727H31.8056Z"/>
                  <path d="M46.7054 21.8777V1.68286H48.6204V10.4165H60.4297V1.68286H62.3157V21.8777H60.4297V12.0414H48.6204V21.8777H46.7054Z"/>
                  <path d="M67.316 27.9999L69.9274 21.5004L64.2694 7.92114H66.2425L69.9565 17.1191C70.1692 17.68 70.4691 18.4248 70.8559 19.3533C70.914 19.2179 70.972 19.0679 71.03 18.9035C71.0881 18.7391 71.1461 18.5892 71.2041 18.4538C71.3202 18.2023 71.4217 17.9654 71.5088 17.7429C71.5958 17.5205 71.6781 17.3028 71.7554 17.0901L75.2373 7.92114H77.1233L69.2021 27.9999H67.316Z"/>
                  <path d="M121.367 21.491L121.285 21.8827H115.593L115.675 21.491C117.247 21.3217 117.89 20.872 118.142 19.6969L121.338 4.63295C121.677 3.09029 121.198 2.83883 119.573 3.17251L119.655 2.7808L123.132 1.60083H123.524L119.679 19.692C119.428 20.872 119.849 21.3169 121.362 21.4861L121.367 21.491Z"/>
                </g>
                <defs>
                  <clipPath id="clip0_975_1209"><rect width="178.832" height="28" fill="white"/></clipPath>
                </defs>
              </svg>
            </a>
          </span>
        </div>
      </div>
      <div class="timestamp" id="startedAt"></div>
    </div>
  </header>

  <div class="grid">
    <section class="card">
      <h2>Wallet Snapshot <span class="badge">clearinghouseState</span></h2>
      <div id="marginSummary" class="kv-list"></div>
      <div class="error" id="snapshotError"></div>
    </section>

    <section class="card" style="overflow: auto;">
      <h2>Positions <span class="badge">assetPositions</span></h2>
      <table>
        <thead>
        <tr>
          <th>Asset</th>
          <th>Size</th>
          <th>Direction</th>
          <th>Entry Price</th>
          <th>Value</th>
          <th>Unrealized PnL</th>
        </tr>
        </thead>
        <tbody id="positionsBody">
        <tr><td colspan="6" class="muted">Loading…</td></tr>
        </tbody>
      </table>
    </section>
  </div>

  <section class="card">
    <h2>Performance <span class="badge">portfolio</span></h2>

    <div class="chart-toolbar">
      <button class="chart-range-btn" data-range="day">Day</button>
      <button class="chart-range-btn" data-range="week">Week</button>
      <button class="chart-range-btn" data-range="month">Month</button>
      <button class="chart-range-btn active" data-range="allTime">All</button>
    </div>

    <div class="chart-grid">
      <div class="chart-card">
        <h3>Equity <span class="spark-label">Account value ($)</span></h3>
        <div class="chart-canvas-wrap"><canvas id="equityChart"></canvas></div>
      </div>

      <div class="chart-card">
        <h3>PnL <span class="spark-label">Net profit ($)</span></h3>
        <div class="chart-canvas-wrap"><canvas id="pnlChart"></canvas></div>
      </div>

      <div class="chart-card">
        <h3>Deposits <span class="spark-label">Net deposits ($)</span></h3>
        <div class="chart-canvas-wrap"><canvas id="depositsChart"></canvas></div>
      </div>
    </div>

    <div class="chart-loading" id="portfolioLoading">Loading performance data…</div>
    <div class="error" id="portfolioError"></div>
  </section>

  <p></p>

  <div class="layout-two">
    <section class="card">
      <h2>Orders <span class="badge">orderUpdates</span></h2>

      <div class="orders-tabs">
        <button class="orders-tab-btn active" data-tab="live">Live</button>
        <button class="orders-tab-btn" data-tab="history">History</button>
      </div>

      <div id="ordersLivePanel" class="tab-panel">
        <div class="section-title"><span>Open</span><small id="openOrdersCount">–</small></div>
        <div style="max-height: 220px; overflow: auto; margin-bottom: .75rem;">
          <table>
            <thead>
            <tr>
              <th>Order ID</th><th>Time</th><th>Side</th><th>Asset</th><th>Size</th><th>Limit Price</th><th>Total</th>
            </tr>
            </thead>
            <tbody id="openOrdersBody">
            <tr><td colspan="7" class="muted">No open orders.</td></tr>
            </tbody>
          </table>
        </div>

        <div class="section-title"><span>Canceled</span><small id="canceledCount">–</small></div>
        <div style="max-height: 160px; overflow: auto;">
          <table>
            <thead>
            <tr>
              <th>Order ID</th><th>Created</th><th>Canceled</th><th>Side</th><th>Asset</th><th>Size</th>
            </tr>
            </thead>
            <tbody id="canceledOrdersBody">
            <tr><td colspan="6" class="muted">No canceled orders yet.</td></tr>
            </tbody>
          </table>
        </div>

        <div class="error" id="ordersError"></div>
      </div>

      <div id="ordersHistoryPanel" class="tab-panel hidden">
        <div class="section-title"><span>Historical (last 2000)</span><small id="historicalOrdersCount">–</small></div>

        <div class="orders-filter-bar">
          <div class="orders-filter-group">
            <span class="orders-filter-label">Asset</span>
            <input id="historicalAssetFilter" class="orders-filter-input" type="text" placeholder="e.g. ETH" autocomplete="off" />
          </div>

          <div class="orders-filter-group">
            <span class="orders-filter-label">Side</span>
            <select id="historicalSideFilter" class="orders-filter-select">
              <option value="all">All</option>
              <option value="B">Buy</option>
              <option value="S">Sell</option>
            </select>
          </div>

          <div class="orders-filter-group">
            <span class="orders-filter-label">Status</span>
            <select id="historicalStatusFilter" class="orders-filter-select">
              <option value="all">All</option>
              <option value="open">Open</option>
              <option value="filled">Filled</option>
              <option value="canceled">Canceled</option>
              <option value="resting">Resting</option>
            </select>
          </div>
        </div>

        <div style="max-height: 380px; overflow: auto;">
          <table>
            <thead>
            <tr>
              <th>Order ID</th><th>Time</th><th>Side</th><th>Asset</th><th>Size</th><th>Limit Price</th><th>Status</th>
            </tr>
            </thead>
            <tbody id="historicalOrdersBody">
            <tr><td colspan="7" class="muted">Loading historical orders…</td></tr>
            </tbody>
          </table>
        </div>
      </div>
    </section>

    <section class="card">
      <h2>Trades Stream <span class="badge">userEvents</span></h2>
      <div style="max-height: 360px; overflow: auto;">
        <table>
          <thead>
          <tr>
            <th>Order ID</th><th>Time</th><th>Side</th><th>Asset</th><th>Size</th><th>Price</th><th>Total</th>
          </tr>
          </thead>
          <tbody id="fillsBody">
          <tr><td colspan="7" class="muted">Waiting for fills…</td></tr>
          </tbody>
        </table>
      </div>
      <div class="error" id="fillsError"></div>
    </section>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>

<script type="module">
  import * as hl from "https://esm.sh/jsr/@nktkas/hyperliquid";

  const DEFAULT_WALLET = "0x0b1ace05eb9ef1c3a1951b763700ecad24f27741";
  const LAST_WALLET_KEY = "hypermonitor-last-wallet";

  const MAX_FILL_ROWS = 100;
  const PORTFOLIO_API_URL = "https://api.hyperliquid.xyz/info";

  // ===== Positions chart config =====
  const DEFAULT_POS_INTERVAL = "15m";
  const POS_INTERVALS = [
    { label: "1m",  ivl: "1m"  },
    { label: "5m",  ivl: "5m"  },
    { label: "15m", ivl: "15m" },
    { label: "1h",  ivl: "1h"  },
    { label: "4h",  ivl: "4h"  },
    { label: "1d",  ivl: "1d"  },
  ];

  // initial window + backfill when panning left
  const POS_INIT_CANDLES = 240;       // "natural" zoom by default
  const POS_BACKFILL_CANDLES = 400;   // how many older candles to load per backfill
  const POS_MAX_CANDLES = 2500;       // cap to keep it snappy

  // HL-style marker look (match your pills)
  const BUY_COLOR = "#4ade80";
  const SELL_COLOR = "#f97373";
  const MARKER_TEXT = "#ffffff";

  // === DOM ===
  const walletInputEl = document.getElementById("walletInput");
  const trackBtnEl = document.getElementById("trackBtn");

  const statusDotEl = document.getElementById("statusDot");
  const statusTextEl = document.getElementById("statusText");
  const statusSpinnerEl = document.getElementById("statusSpinner");
  const statusLogoEl = document.querySelector(".status-logo");
  const startedAtEl = document.getElementById("startedAt");

  const marginSummaryEl = document.getElementById("marginSummary");
  const snapshotErrorEl = document.getElementById("snapshotError");

  const positionsBodyEl = document.getElementById("positionsBody");

  const openOrdersBodyEl = document.getElementById("openOrdersBody");
  const openOrdersCountEl = document.getElementById("openOrdersCount");
  const canceledOrdersBodyEl = document.getElementById("canceledOrdersBody");
  const canceledCountEl = document.getElementById("canceledCount");
  const ordersErrorEl = document.getElementById("ordersError");

  const historicalOrdersBodyEl = document.getElementById("historicalOrdersBody");
  const historicalOrdersCountEl = document.getElementById("historicalOrdersCount");

  const ordersTabButtons = document.querySelectorAll(".orders-tab-btn");
  const ordersLivePanelEl = document.getElementById("ordersLivePanel");
  const ordersHistoryPanelEl = document.getElementById("ordersHistoryPanel");

  const historicalSideFilterEl = document.getElementById("historicalSideFilter");
  const historicalStatusFilterEl = document.getElementById("historicalStatusFilter");
  const historicalAssetFilterEl = document.getElementById("historicalAssetFilter");

  const fillsBodyEl = document.getElementById("fillsBody");
  const fillsErrorEl = document.getElementById("fillsError");

  // Performance section DOM
  const portfolioErrorEl = document.getElementById("portfolioError");
  const portfolioLoadingEl = document.getElementById("portfolioLoading");
  const rangeButtons = document.querySelectorAll(".chart-range-btn");

  const equityCanvas = /** @type {HTMLCanvasElement} */ (document.getElementById("equityChart"));
  const pnlCanvas = /** @type {HTMLCanvasElement} */ (document.getElementById("pnlChart"));
  const depositsCanvas = /** @type {HTMLCanvasElement} */ (document.getElementById("depositsChart"));

  const themeToggleBtn = document.getElementById("themeToggle");

  // === URL helpers ===
  function setWalletInUrl(wallet) {
    try {
      const url = new URL(window.location.href);
      url.searchParams.set("wallet", wallet);
      history.replaceState({ wallet }, "", url.toString());
    } catch (e) {}
  }
  function getWalletFromUrl() {
    try {
      const url = new URL(window.location.href);
      return (url.searchParams.get("wallet") || "").trim();
    } catch (e) { return ""; }
  }
  function setLastWallet(wallet) {
    try { localStorage.setItem(LAST_WALLET_KEY, wallet); } catch (e) {}
  }
  function getLastWallet() {
    try { return (localStorage.getItem(LAST_WALLET_KEY) || "").trim(); } catch (e) { return ""; }
  }

  // === STATE ===
  let currentWallet = DEFAULT_WALLET;

  const openOrders = new Map();
  const canceledOrders = [];
  const fills = [];

  const historicalOrders = [];
  let historicalOrdersLoaded = false;

  let infoClient = null;
  let subsClient = null;
  let orderUpdatesSub = null;
  let userEventsSub = null;

  // Positions + live mids
  let currentAssetPositions = [];
  const liveMids = new Map();
  let allMidsSub = null;

  // Margin snapshot + live totals
  let snapshotMarginSummary = null;
  let snapshotWithdrawable = null;
  let snapshotUpnlTotal = 0;
  let lastComputedUpnlTotal = 0;
  let lastComputedTotalNotional = 0;

  // Portfolio state
  let portfolioData = null;
  let currentRangeKey = "allTime";
  const portfolioCharts = { equity: null, pnl: null, deposits: null };

  // ===== Expandable positions chart state =====
  let expandedCoin = null;
  let preservedExpandRowEl = null; // preserve DOM (prevents flicker)

  const posCharts = {
    chart: null,
    series: null,
    resizeObserver: null,

    coin: null,
    interval: DEFAULT_POS_INTERVAL,

    // candle cache
    candles: [],
    msPer: 0,
    oldestMs: null,
    newestMs: null,
    isLoadingOlder: false,

    // live update
    lastCandleTime: null,

    // overlay marker canvas
    overlayCanvas: null,
    overlayCtx: null,
    overlayDpr: 1,

    // marker points (time sec + price)
    markerPoints: [],

    // subscriptions (for redraw/backfill)
    unsubscribers: [],
  };

  function updateSpinnerForTheme(theme) {
    if (!statusSpinnerEl) return;
    statusSpinnerEl.src =
      theme === "light"
        ? "https://hyperfoundation.org/landing/blob-dark.gif"
        : "https://hyperfoundation.org/landing/blob_green.gif";
  }

  function setStatus(status, message) {
    statusDotEl.classList.remove("connected", "error");
    if (status === "connected") {
      statusDotEl.classList.add("connected");
      statusTextEl.textContent = message ?? "Connected to";
      if (statusSpinnerEl) statusSpinnerEl.style.display = "none";
      if (statusLogoEl) statusLogoEl.classList.remove("hidden");
    } else if (status === "error") {
      statusDotEl.classList.add("error");
      statusTextEl.textContent = message ?? "Error";
      if (statusSpinnerEl) statusSpinnerEl.style.display = "none";
      if (statusLogoEl) statusLogoEl.classList.add("hidden");
    } else {
      statusTextEl.textContent = "";
      if (statusSpinnerEl) statusSpinnerEl.style.display = "inline-block";
      if (statusLogoEl) statusLogoEl.classList.add("hidden");
    }
  }

  function fmtTime(ms) {
    if (!ms && ms !== 0) return "";
    const d = new Date(Number(ms));
    if (Number.isNaN(d.getTime())) return "";
    return d.toLocaleString();
  }

  function fmtMoney(v, decimals = 2) {
    const n = Number(v);
    if (Number.isNaN(n)) return "";
    return `$${n.toFixed(decimals)}`;
  }

  function formatSignedDollar(v, decimals = 2) {
    const n = Number(v);
    if (Number.isNaN(n)) return "";
    const abs = Math.abs(n).toFixed(decimals);
    return n < 0 ? "-$" + abs : "$" + abs;
  }

  function computeTotal(order) {
    const sz = Number(order.sz ?? order.szi ?? 0);
    const pxStr = order.px ?? order.limitPx;
    const px = Number(pxStr ?? 0);
    if (Number.isNaN(sz) || Number.isNaN(px)) return "";
    return (sz * px).toFixed(2);
  }

  function sideLabel(side) { return side === "B" ? "BUY" : "SELL"; }
  function sidePillClass(side) { return side === "B" ? "pill-buy" : "pill-sell"; }

  function renderMarginSummary(summary, withdrawable) {
    if (!summary) {
      marginSummaryEl.innerHTML = "<span class='muted'>No margin summary.</span>";
      return;
    }
    const rows = [
      ["Account Value", fmtMoney(summary.accountValue)],
      ["Total Notional", fmtMoney(summary.totalNtlPos)],
      ["Total Raw USD", fmtMoney(summary.totalRawUsd)],
      ["Margin Used", fmtMoney(summary.totalMarginUsed)],
      ["Withdrawable", fmtMoney(withdrawable)],
    ];
    marginSummaryEl.innerHTML = rows.map(([label, value]) => `
      <div class="kv-label">${label}</div>
      <div class="kv-value money">${value}</div>
    `).join("");
  }

  function recomputeAndRenderMarginSummary() {
    if (!snapshotMarginSummary) {
      renderMarginSummary(null, snapshotWithdrawable);
      return;
    }
    const base = snapshotMarginSummary;
    const snapshotAV = Number(base.accountValue ?? 0);
    const deltaUpnl = lastComputedUpnlTotal - snapshotUpnlTotal;
    const liveAccountValue = snapshotAV + (Number.isNaN(deltaUpnl) ? 0 : deltaUpnl);
    const summaryLive = {
      ...base,
      accountValue: liveAccountValue,
      totalNtlPos: lastComputedTotalNotional || base.totalNtlPos,
    };
    renderMarginSummary(summaryLive, snapshotWithdrawable);
  }

  // ========= Expand/collapse helpers =========
  function buildExpandRowHtml(coin) {
    const btns = POS_INTERVALS.map(({label, ivl}) => {
      const active = ivl === (posCharts.interval || DEFAULT_POS_INTERVAL) ? "active" : "";
      return `<button class="pos-ivl-btn ${active}" data-coin="${coin}" data-ivl="${ivl}" type="button">${label}</button>`;
    }).join("");

    const cid = `posChart_${coin}_${Math.random().toString(16).slice(2)}`;
    return `
      <tr class="pos-expand-row" data-coin="${coin}">
        <td colspan="6">
          <div class="pos-expand-wrap">
            <div class="pos-expand-topbar">
              <div class="pos-expand-title">
                <span class="money">${coin}</span>
                <span class="muted">candles + HL markers</span>
              </div>
              <div class="pos-ivl">${btns}</div>
            </div>
            <div class="pos-chart" id="${cid}"></div>
            <div class="pos-chart-status" id="${cid}_status">Loading chart…</div>
          </div>
        </td>
      </tr>
    `;
  }

  function attachExpandRowEvents(coin) {
    const btns = document.querySelectorAll(`.pos-ivl-btn[data-coin="${coin}"]`);
    btns.forEach((b) => {
      b.addEventListener("click", (e) => {
        e.stopPropagation();
        const ivl = b.dataset.ivl || DEFAULT_POS_INTERVAL;

        btns.forEach((x) => x.classList.remove("active"));
        b.classList.add("active");

        renderPosChartForCoin(coin, ivl, { forceReset: true });
      });
    });
  }

  function destroyPosChart() {
    try { if (posCharts.resizeObserver) posCharts.resizeObserver.disconnect(); } catch(e) {}
    posCharts.resizeObserver = null;

    posCharts.unsubscribers.forEach((fn) => { try { fn(); } catch(e) {} });
    posCharts.unsubscribers = [];

    try { if (posCharts.chart) posCharts.chart.remove(); } catch (e) {}
    posCharts.chart = null;
    posCharts.series = null;

    // overlay
    try {
      if (posCharts.overlayCanvas && posCharts.overlayCanvas.parentElement) {
        posCharts.overlayCanvas.parentElement.removeChild(posCharts.overlayCanvas);
      }
    } catch(e) {}
    posCharts.overlayCanvas = null;
    posCharts.overlayCtx = null;

    // cache
    posCharts.candles = [];
    posCharts.msPer = 0;
    posCharts.oldestMs = null;
    posCharts.newestMs = null;
    posCharts.isLoadingOlder = false;

    posCharts.markerPoints = [];
    posCharts.lastCandleTime = null;

    posCharts.coin = null;
  }

  function collapseExpandedRow() {
    if (!expandedCoin) return;

    const activeRow = positionsBodyEl.querySelector(`tr.pos-row[data-coin="${expandedCoin}"]`);
    if (activeRow) activeRow.classList.remove("active");

    const exp = positionsBodyEl.querySelector(`tr.pos-expand-row[data-coin="${expandedCoin}"]`);
    if (exp) exp.remove();

    expandedCoin = null;
    preservedExpandRowEl = null;
    destroyPosChart();
  }

  function toggleExpandForCoin(anchorRow, coin) {
    if (expandedCoin === coin) {
      collapseExpandedRow();
      return;
    }

    collapseExpandedRow();

    expandedCoin = coin;
    anchorRow.classList.add("active");

    anchorRow.insertAdjacentHTML("afterend", buildExpandRowHtml(coin));
    preservedExpandRowEl = positionsBodyEl.querySelector(`tr.pos-expand-row[data-coin="${coin}"]`) || null;
    attachExpandRowEvents(coin);

    const activeBtn = document.querySelector(`.pos-ivl-btn.active[data-coin="${coin}"]`);
    const ivl = activeBtn?.dataset?.ivl || DEFAULT_POS_INTERVAL;

    renderPosChartForCoin(coin, ivl, { forceReset: true });
  }

  // ========= Hyperliquid candles + markers =========
  function intervalToMs(ivl) {
    const map = {
      "1m": 60_000,
      "3m": 180_000,
      "5m": 300_000,
      "15m": 900_000,
      "30m": 1_800_000,
      "1h": 3_600_000,
      "2h": 7_200_000,
      "4h": 14_400_000,
      "8h": 28_800_000,
      "12h": 43_200_000,
      "1d": 86_400_000,
      "3d": 259_200_000,
      "1w": 604_800_000,
      "1M": 2_592_000_000,
    };
    return map[ivl] || 900_000;
  }

  async function fetchCandlesWindow(coin, interval, startMs, endMs) {
    const body = { type: "candleSnapshot", req: { coin, interval, startTime: startMs, endTime: endMs } };
    const res = await fetch(PORTFOLIO_API_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    if (!res.ok) throw new Error(`candleSnapshot error: ${res.status} ${res.statusText}`);
    const data = await res.json();

    return (Array.isArray(data) ? data : [])
      .map((c) => ({
        time: Math.floor(Number(c.t) / 1000),
        open: Number(c.o),
        high: Number(c.h),
        low: Number(c.l),
        close: Number(c.c),
      }))
      .filter((x) => Number.isFinite(x.time) && Number.isFinite(x.open) && Number.isFinite(x.high) && Number.isFinite(x.low) && Number.isFinite(x.close))
      .sort((a,b) => a.time - b.time);
  }

  async function fetchLatestCandles(coin, interval, limit) {
    const msPer = intervalToMs(interval);
    const endMs = Date.now();
    const startMs = endMs - msPer * limit;
    return fetchCandlesWindow(coin, interval, startMs, endMs);
  }

  async function fetchOlderCandles(coin, interval, endMsExclusive, limit) {
    const msPer = intervalToMs(interval);
    const endMs = endMsExclusive;
    const startMs = endMs - msPer * limit;
    return fetchCandlesWindow(coin, interval, startMs, endMs);
  }

  function normalizeHistoricalOrder(entry) {
    const o = entry?.order ?? entry ?? {};
    const status = entry?.status ?? o.status ?? "";
    const statusTimestamp = entry?.statusTimestamp ?? o.statusTimestamp ?? o.timestamp ?? null;
    return {
      oid: o.oid,
      coin: o.coin,
      side: o.side,
      limitPx: o.limitPx ?? o.px,
      sz: o.origSz ?? o.sz,
      timestamp: o.timestamp,
      status,
      statusTimestamp,
      raw: entry,
    };
  }

  function buildHLMarkerPoints(coin, candles, interval) {
    // Place at candle bucket + price (prefer limitPx; fallback to candle close)
    const msPer = intervalToMs(interval);
    if (!candles?.length) return [];

    const candleByTime = new Map(candles.map(c => [c.time, c]));
    const points = [];

    const orders = historicalOrders
      .map(normalizeHistoricalOrder)
      .filter((o) => (o.coin || "").toUpperCase() === coin.toUpperCase())
      .filter((o) => ((o.status || "").toLowerCase().includes("filled")))
      .filter((o) => Number(o.timestamp));

    for (const o of orders) {
      const ts = Number(o.timestamp);
      const bucketOpenMs = Math.floor(ts / msPer) * msPer;
      const t = Math.floor(bucketOpenMs / 1000);
      const candle = candleByTime.get(t);
      if (!candle) continue;

      const px = Number(o.limitPx);
      const price = Number.isFinite(px) ? px : candle.close;
      const side = (o.side === "B") ? "B" : "S";

      points.push({ time: t, price, side });
    }

    return points;
  }

  // ========= HL-style markers drawn "in the candles" via overlay canvas =========
  function ensureOverlay(chartDiv) {
    if (posCharts.overlayCanvas && posCharts.overlayCanvas.isConnected) return;

    const canvas = document.createElement("canvas");
    canvas.className = "pos-marker-overlay";
    chartDiv.appendChild(canvas);

    const ctx = canvas.getContext("2d");
    posCharts.overlayCanvas = canvas;
    posCharts.overlayCtx = ctx;

    resizeOverlay(chartDiv);
  }

  function resizeOverlay(chartDiv) {
    if (!posCharts.overlayCanvas || !posCharts.overlayCtx) return;

    const dpr = window.devicePixelRatio || 1;
    posCharts.overlayDpr = dpr;

    const rect = chartDiv.getBoundingClientRect();
    const w = Math.max(1, Math.floor(rect.width));
    const h = Math.max(1, Math.floor(rect.height));

    posCharts.overlayCanvas.width = Math.floor(w * dpr);
    posCharts.overlayCanvas.height = Math.floor(h * dpr);
    posCharts.overlayCanvas.style.width = w + "px";
    posCharts.overlayCanvas.style.height = h + "px";

    posCharts.overlayCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function clearOverlay(chartDiv) {
    if (!posCharts.overlayCtx) return;
    const rect = chartDiv.getBoundingClientRect();
    posCharts.overlayCtx.clearRect(0, 0, rect.width, rect.height);
  }

  function drawHLMarkers(chartDiv) {
    if (!posCharts.chart || !posCharts.series) return;
    if (!posCharts.overlayCtx) return;

    clearOverlay(chartDiv);

    const ctx = posCharts.overlayCtx;

    // HL-ish sizing
    const r = 12;
    ctx.font = "700 12px system-ui, -apple-system, Segoe UI, sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    for (const m of posCharts.markerPoints) {
      const x = posCharts.chart.timeScale().timeToCoordinate(m.time);
      const y = posCharts.series.priceToCoordinate(m.price);
      if (x == null || y == null) continue;

      // clip: only draw if inside chart
      const rect = chartDiv.getBoundingClientRect();
      if (x < 0 || x > rect.width || y < 0 || y > rect.height) continue;

      const fill = (m.side === "B") ? BUY_COLOR : SELL_COLOR;
      const text = (m.side === "B") ? "B" : "S";

      // shadow (subtle)
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.35)";
      ctx.shadowBlur = 6;
      ctx.shadowOffsetY = 2;

      ctx.beginPath();
      ctx.fillStyle = fill;
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // text
      ctx.fillStyle = MARKER_TEXT;
      ctx.fillText(text, x, y + 0.5);
    }
  }

  function hookRedrawAndBackfill(chartDiv) {
    if (!posCharts.chart) return;

    // clear old
    posCharts.unsubscribers.forEach((fn) => { try { fn(); } catch(e) {} });
    posCharts.unsubscribers = [];

    const ts = posCharts.chart.timeScale();

    // redraw on scroll/zoom
    const redraw = () => {
      if (!chartDiv.isConnected) return;
      resizeOverlay(chartDiv);
      drawHLMarkers(chartDiv);
    };

    // backfill if user pans close to left edge
    const maybeBackfill = async () => {
      if (!posCharts.chart || !posCharts.series) return;
      if (posCharts.isLoadingOlder) return;
      if (!posCharts.candles.length) return;
      if (!posCharts.oldestMs) return;

      // Determine visible range (logical if available; fallback time-range)
      let leftTimeSec = null;

      try {
        if (typeof ts.getVisibleLogicalRange === "function") {
          const lr = ts.getVisibleLogicalRange();
          if (lr && typeof lr.from === "number") {
            const idx = Math.max(0, Math.floor(lr.from));
            const c = posCharts.candles[Math.min(idx, posCharts.candles.length - 1)];
            if (c) leftTimeSec = c.time;
          }
        }
      } catch(e) {}

      // if logical not available, approximate using visible time range
      if (leftTimeSec == null) {
        try {
          if (typeof ts.getVisibleRange === "function") {
            const vr = ts.getVisibleRange();
            // v4 usually returns { from: time, to: time }
            if (vr && vr.from) leftTimeSec = (typeof vr.from === "number") ? vr.from : vr.from?.timestamp;
          }
        } catch(e) {}
      }

      if (leftTimeSec == null) return;

      const leftMs = Number(leftTimeSec) * 1000;
      // If we're within ~30 candles of the oldest loaded, fetch more
      const thresholdMs = (posCharts.msPer || intervalToMs(posCharts.interval)) * 30;
      if (leftMs > (posCharts.oldestMs + thresholdMs)) return;

      posCharts.isLoadingOlder = true;
      try {
        const older = await fetchOlderCandles(posCharts.coin, posCharts.interval, posCharts.oldestMs, POS_BACKFILL_CANDLES);
        if (older && older.length) {
          const existing = new Set(posCharts.candles.map(c => c.time));
          const merged = [...older.filter(c => !existing.has(c.time)), ...posCharts.candles]
            .sort((a,b) => a.time - b.time);

          // cap
          const capped = merged.length > POS_MAX_CANDLES ? merged.slice(merged.length - POS_MAX_CANDLES) : merged;

          posCharts.candles = capped;
          posCharts.oldestMs = posCharts.candles[0].time * 1000;
          posCharts.newestMs = posCharts.candles[posCharts.candles.length - 1].time * 1000;

          posCharts.series.setData(posCharts.candles);

          // rebuild markers for the new window and redraw
          posCharts.markerPoints = buildHLMarkerPoints(posCharts.coin, posCharts.candles, posCharts.interval);
          redraw();
        }
      } catch(e) {
        console.warn("Backfill candles failed", e);
      } finally {
        posCharts.isLoadingOlder = false;
      }
    };

    // subscribe variants across versions
    const sub1 = () => {
      try {
        if (typeof ts.subscribeVisibleLogicalRangeChange === "function") {
          const handler = () => { redraw(); maybeBackfill(); };
          ts.subscribeVisibleLogicalRangeChange(handler);
          posCharts.unsubscribers.push(() => ts.unsubscribeVisibleLogicalRangeChange(handler));
          return true;
        }
      } catch(e) {}
      return false;
    };

    const sub2 = () => {
      try {
        if (typeof ts.subscribeVisibleTimeRangeChange === "function") {
          const handler = () => { redraw(); maybeBackfill(); };
          ts.subscribeVisibleTimeRangeChange(handler);
          posCharts.unsubscribers.push(() => ts.unsubscribeVisibleTimeRangeChange(handler));
          return true;
        }
      } catch(e) {}
      return false;
    };

    sub1() || sub2();

    // also redraw on crosshair move (cheap + keeps it crisp on some builds)
    try {
      if (typeof posCharts.chart.subscribeCrosshairMove === "function") {
        const handler = () => redraw();
        posCharts.chart.subscribeCrosshairMove(handler);
        posCharts.unsubscribers.push(() => posCharts.chart.unsubscribeCrosshairMove(handler));
      }
    } catch(e) {}
  }

  function createOrResetPosChart(chartDiv) {
    destroyPosChart();

    const isLight = document.body.classList.contains("light");

    // IMPORTANT: transparent chart background so page bg (#101014) shows through
    const chart = LightweightCharts.createChart(chartDiv, {
      width: chartDiv.clientWidth,
      height: chartDiv.clientHeight,
      layout: {
        background: { color: "rgba(0,0,0,0)" },
        textColor: isLight ? "#0f172a" : "#e5e7eb",
      },
      grid: {
        vertLines: { color: isLight ? "rgba(15,23,42,0.08)" : "rgba(148,163,184,0.12)" },
        horzLines: { color: isLight ? "rgba(15,23,42,0.08)" : "rgba(148,163,184,0.12)" },
      },
      timeScale: { rightOffset: 2, borderColor: isLight ? "rgba(15,23,42,0.12)" : "rgba(148,163,184,0.12)" },
      rightPriceScale: { borderColor: isLight ? "rgba(15,23,42,0.12)" : "rgba(148,163,184,0.12)" },
      crosshair: { mode: 1 },
    });

    const seriesOptions = {
      // match your pills
      upColor: BUY_COLOR,
      wickUpColor: BUY_COLOR,
      downColor: SELL_COLOR,
      wickDownColor: SELL_COLOR,
      borderVisible: false,
    };

    let series = null;
    if (typeof chart.addCandlestickSeries === "function") {
      series = chart.addCandlestickSeries(seriesOptions);
    } else if (typeof chart.addSeries === "function" && LightweightCharts.CandlestickSeries) {
      series = chart.addSeries(LightweightCharts.CandlestickSeries, seriesOptions);
    } else {
      throw new Error("Unsupported LightweightCharts version: cannot create candlestick series.");
    }

    // overlay marker canvas
    ensureOverlay(chartDiv);

    // ResizeObserver: resize chart + overlay
    const ro = new ResizeObserver(() => {
      if (!chartDiv.isConnected) return;
      chart.applyOptions({ width: chartDiv.clientWidth, height: chartDiv.clientHeight });
      resizeOverlay(chartDiv);
      drawHLMarkers(chartDiv);
    });
    ro.observe(chartDiv);

    posCharts.chart = chart;
    posCharts.series = series;
    posCharts.resizeObserver = ro;

    // hook redraw/backfill
    hookRedrawAndBackfill(chartDiv);
  }

  function updatePosChartTheme() {
    if (!posCharts.chart) return;
    const isLight = document.body.classList.contains("light");
    posCharts.chart.applyOptions({
      layout: {
        background: { color: "rgba(0,0,0,0)" },
        textColor: isLight ? "#0f172a" : "#e5e7eb",
      },
      grid: {
        vertLines: { color: isLight ? "rgba(15,23,42,0.08)" : "rgba(148,163,184,0.12)" },
        horzLines: { color: isLight ? "rgba(15,23,42,0.08)" : "rgba(148,163,184,0.12)" },
      },
      timeScale: { borderColor: isLight ? "rgba(15,23,42,0.12)" : "rgba(148,163,184,0.12)" },
      rightPriceScale: { borderColor: isLight ? "rgba(15,23,42,0.12)" : "rgba(148,163,184,0.12)" },
    });
  }

  function setNaturalZoom() {
    if (!posCharts.chart || !posCharts.candles.length) return;

    // show last ~120 bars by default (feels like HL)
    const bars = 120;
    const n = posCharts.candles.length;
    const fromIdx = Math.max(0, n - bars);
    const toIdx = n - 1;

    const ts = posCharts.chart.timeScale();
    try {
      if (typeof ts.setVisibleLogicalRange === "function") {
        ts.setVisibleLogicalRange({ from: fromIdx, to: toIdx });
        return;
      }
    } catch(e) {}

    // fallback: set visible time range
    try {
      if (typeof ts.setVisibleRange === "function") {
        ts.setVisibleRange({ from: posCharts.candles[fromIdx].time, to: posCharts.candles[toIdx].time });
      }
    } catch(e) {}
  }

  async function renderPosChartForCoin(coin, interval, { forceReset = false } = {}) {
    posCharts.coin = coin;
    posCharts.interval = interval;
    posCharts.msPer = intervalToMs(interval);

    const exp = positionsBodyEl.querySelector(`tr.pos-expand-row[data-coin="${coin}"]`);
    if (!exp) return;

    const chartDiv = exp.querySelector(".pos-chart");
    const statusEl = exp.querySelector(".pos-chart-status");
    if (!chartDiv || !statusEl) return;

    statusEl.textContent = "Loading chart…";

    try {
      if (forceReset || !posCharts.chart || !posCharts.series) {
        createOrResetPosChart(chartDiv);
        posCharts.lastCandleTime = null;
      } else {
        updatePosChartTheme();
        ensureOverlay(chartDiv);
      }

      // Load initial window (not huge)
      const candles = await fetchLatestCandles(coin, interval, POS_INIT_CANDLES);

      if (!candles.length) {
        statusEl.textContent = "No candles returned for this coin/interval.";
        posCharts.series.setData([]);
        posCharts.candles = [];
        posCharts.oldestMs = null;
        posCharts.newestMs = null;
        posCharts.markerPoints = [];
        drawHLMarkers(chartDiv);
        return;
      }

      posCharts.candles = candles;
      posCharts.oldestMs = candles[0].time * 1000;
      posCharts.newestMs = candles[candles.length - 1].time * 1000;

      posCharts.series.setData(candles);
      posCharts.lastCandleTime = candles[candles.length - 1]?.time ?? null;

      // Build HL-style marker points (time+price) and draw overlay badges
      posCharts.markerPoints = buildHLMarkerPoints(coin, candles, interval);
      drawHLMarkers(chartDiv);

      setNaturalZoom();

      statusEl.textContent = posCharts.markerPoints.length
        ? `Showing ${candles.length} candles • ${posCharts.markerPoints.length} filled markers`
        : `Showing ${candles.length} candles • no filled markers in this window`;
    } catch (err) {
      console.error("Positions chart error", err);
      statusEl.textContent = "Chart error: " + (err?.message || err);
      try { posCharts.series?.setData([]); } catch(e) {}
    }
  }

  // ========= Positions rendering (NO-FLICKER FIX) =========
  function renderPositions(assetPositions) {
    currentAssetPositions = Array.isArray(assetPositions) ? assetPositions : [];
    lastComputedUpnlTotal = 0;
    lastComputedTotalNotional = 0;

    // detach expand row before overwrite
    preservedExpandRowEl = null;
    if (expandedCoin) {
      const existingExpand = positionsBodyEl.querySelector(`tr.pos-expand-row[data-coin="${expandedCoin}"]`);
      if (existingExpand) {
        preservedExpandRowEl = existingExpand;
        existingExpand.remove();
      }
    }

    if (!currentAssetPositions.length) {
      positionsBodyEl.innerHTML = "<tr><td colspan='6' class='muted'>No open positions.</td></tr>";
      recomputeAndRenderMarginSummary();
      collapseExpandedRow();
      return;
    }

    positionsBodyEl.innerHTML = currentAssetPositions.map((item) => {
      const p = item.position;
      const coin = p.coin;
      const szi = Number(p.szi ?? 0);

      const dir = szi > 0 ? "LONG" : szi < 0 ? "SHORT" : "FLAT";
      const dirColor = szi >= 0 ? BUY_COLOR : SELL_COLOR;
      const entryPx = Number(p.entryPx ?? 0);

      const livePx = liveMids.get(coin);
      let markPx = Number.isFinite(livePx) ? livePx : undefined;

      const snapshotValue = Number(p.positionValue ?? 0);
      if ((markPx === undefined || Number.isNaN(markPx)) && szi !== 0 && !Number.isNaN(snapshotValue)) {
        markPx = snapshotValue / szi;
      }

      let positionValue = snapshotValue;
      if (markPx !== undefined && !Number.isNaN(markPx) && szi !== 0) positionValue = markPx * szi;

      let upnl = Number(p.unrealizedPnl ?? 0);
      if (markPx !== undefined && !Number.isNaN(markPx) && !Number.isNaN(entryPx) && szi !== 0) {
        upnl = (markPx - entryPx) * szi;
      }

      if (!Number.isNaN(upnl)) lastComputedUpnlTotal += upnl;
      const notional = Math.abs(positionValue);
      if (!Number.isNaN(notional)) lastComputedTotalNotional += notional;

      const upnlAbs = Math.abs(upnl);
      const upnlSign = upnl >= 0 ? "+" : "-";
      const formattedValue = formatSignedDollar(positionValue);

      return `
        <tr class="pos-row" data-coin="${coin}">
          <td>${coin}</td>
          <td class="money">${szi}</td>
          <td>
            <span class="pill" style="color:${dirColor};border-color:${dirColor}55;background:${dirColor}22;">
              ${dir}
            </span>
          </td>
          <td class="money">${fmtMoney(entryPx)}</td>
          <td class="money">${formattedValue}</td>
          <td class="money" style="color:${upnl >= 0 ? BUY_COLOR : SELL_COLOR};">
            ${upnlSign}$${upnlAbs.toFixed(2)}
          </td>
        </tr>
      `;
    }).join("");

    positionsBodyEl.querySelectorAll("tr.pos-row").forEach((tr) => {
      tr.addEventListener("click", () => {
        const coin = tr.dataset.coin;
        if (!coin) return;
        toggleExpandForCoin(tr, coin);
      });
    });

    recomputeAndRenderMarginSummary();

    // reinsert preserved expand row
    if (expandedCoin) {
      const anchor = positionsBodyEl.querySelector(`tr.pos-row[data-coin="${expandedCoin}"]`);
      if (!anchor) {
        collapseExpandedRow();
        return;
      }
      anchor.classList.add("active");

      if (preservedExpandRowEl) {
        anchor.insertAdjacentElement("afterend", preservedExpandRowEl);
        attachExpandRowEvents(expandedCoin);

        // redraw overlay markers after reattach (no chart recreate)
        const exp = positionsBodyEl.querySelector(`tr.pos-expand-row[data-coin="${expandedCoin}"]`);
        const chartDiv = exp?.querySelector(".pos-chart");
        if (chartDiv) {
          updatePosChartTheme();
          ensureOverlay(chartDiv);
          resizeOverlay(chartDiv);
          drawHLMarkers(chartDiv);
        }
      }
    }
  }

  function computeSnapshotUpnlTotal(assetPositions) {
    if (!Array.isArray(assetPositions)) return 0;
    return assetPositions.reduce((sum, item) => {
      const p = item.position;
      const u = Number(p.unrealizedPnl ?? 0);
      return sum + (Number.isNaN(u) ? 0 : u);
    }, 0);
  }

  async function refreshPositionsAndMargin(wallet) {
    try {
      const clearing = await infoClient.clearinghouseState({ user: wallet });
      const { marginSummary, withdrawable, assetPositions } = clearing;
      snapshotMarginSummary = marginSummary || null;
      snapshotWithdrawable = withdrawable;
      snapshotUpnlTotal = computeSnapshotUpnlTotal(assetPositions);
      renderPositions(assetPositions);
    } catch (err) {
      console.error("Refresh positions error", err);
      snapshotErrorEl.textContent = "Failed to refresh positions: " + (err?.message || err);
    }
  }

  // ========= Orders rendering =========
  function renderOpenOrders() {
    const values = Array.from(openOrders.values()).sort((a, b) => (a.oid ?? 0) - (b.oid ?? 0));
    openOrdersCountEl.textContent = values.length.toString();
    if (values.length === 0) {
      openOrdersBodyEl.innerHTML = "<tr><td colspan='7' class='muted'>No open orders.</td></tr>";
      return;
    }
    openOrdersBodyEl.innerHTML = values.map((order) => {
      const created = fmtTime(order.timestamp);
      const total = computeTotal(order);
      const side = order.side ?? "?";
      return `
        <tr>
          <td>${order.oid}</td>
          <td><span class="timestamp">${created}</span></td>
          <td><span class="pill ${sidePillClass(side)}">${sideLabel(side)}</span></td>
          <td>${order.coin}</td>
          <td class="money">${order.sz}</td>
          <td class="money">${fmtMoney(order.limitPx) ?? ""}</td>
          <td class="money">${total ? "$" + total : ""}</td>
        </tr>
      `;
    }).join("");
  }

  function renderCanceledOrders() {
    canceledCountEl.textContent = canceledOrders.length.toString();
    if (canceledOrders.length === 0) {
      canceledOrdersBodyEl.innerHTML = "<tr><td colspan='6' class='muted'>No canceled orders yet.</td></tr>";
      return;
    }
    canceledOrdersBodyEl.innerHTML = canceledOrders.map((o) => {
      const created = fmtTime(o.timestamp);
      const canceledAt = fmtTime(o.statusTimestamp);
      const side = o.side ?? "?";
      return `
        <tr>
          <td>${o.oid}</td>
          <td><span class="timestamp">${created}</span></td>
          <td><span class="timestamp">${canceledAt}</span></td>
          <td><span class="pill ${sidePillClass(side)}">${sideLabel(side)}</span></td>
          <td>${o.coin}</td>
          <td class="money">${o.sz}</td>
        </tr>
      `;
    }).join("");
  }

  function renderFills() {
    if (fills.length === 0) {
      fillsBodyEl.innerHTML = "<tr><td colspan='7' class='muted'>Waiting for fills...</td></tr>";
      return;
    }
    fillsBodyEl.innerHTML = fills.map((fill) => {
      const t = fmtTime(fill.time);
      const total = computeTotal(fill);
      const side = fill.side ?? "?";
      return `
        <tr>
          <td>${fill.oid}</td>
          <td><span class="timestamp">${t}</span></td>
          <td><span class="pill ${sidePillClass(side)}">${sideLabel(side)}</span></td>
          <td>${fill.coin}</td>
          <td class="money">${fill.sz}</td>
          <td class="money">${fmtMoney(fill.px) ?? ""}</td>
          <td class="money">${total ? "$" + total : ""}</td>
        </tr>
      `;
    }).join("");
  }

  function renderHistoricalOrders() {
    const totalCount = historicalOrders.length;
    const sideFilter = historicalSideFilterEl?.value || "all";
    const statusFilter = (historicalStatusFilterEl?.value || "all").toLowerCase();
    const assetFilter = (historicalAssetFilterEl?.value || "").trim().toLowerCase();

    const filtered = historicalOrders
      .map(normalizeHistoricalOrder)
      .filter((o) => {
        const side = o.side ?? "B";
        const status = (o.status ?? "").toLowerCase();
        const coin = (o.coin ?? "").toLowerCase();
        if (sideFilter !== "all" && side !== sideFilter) return false;
        if (statusFilter !== "all" && !status.includes(statusFilter)) return false;
        if (assetFilter && !coin.includes(assetFilter)) return false;
        return true;
      });

    if (historicalOrdersCountEl) {
      historicalOrdersCountEl.textContent = historicalOrdersLoaded
        ? `${filtered.length} / ${totalCount}`
        : "–";
    }

    if (filtered.length === 0) {
      historicalOrdersBodyEl.innerHTML = "<tr><td colspan='7' class='muted'>No orders match the current filters.</td></tr>";
      return;
    }

    historicalOrdersBodyEl.innerHTML = filtered.map((o) => {
      const created = fmtTime(o.timestamp);
      const side = o.side ?? "B";
      const status = o.status ?? "";
      return `
        <tr>
          <td>${o.oid ?? ""}</td>
          <td><span class="timestamp">${created}</span></td>
          <td><span class="pill ${sidePillClass(side)}">${sideLabel(side)}</span></td>
          <td>${o.coin ?? ""}</td>
          <td class="money">${o.sz ?? ""}</td>
          <td class="money">${fmtMoney(o.limitPx) ?? ""}</td>
          <td>${status}</td>
        </tr>
      `;
    }).join("");
  }

  async function loadHistoricalOrders(wallet) {
    historicalOrdersLoaded = false;
    if (historicalOrdersCountEl) historicalOrdersCountEl.textContent = "–";
    historicalOrdersBodyEl.innerHTML = "<tr><td colspan='7' class='muted'>Loading historical orders…</td></tr>";

    try {
      const body = { type: "historicalOrders", user: wallet };
      const res = await fetch(PORTFOLIO_API_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
      });
      if (!res.ok) throw new Error(`Historical orders error: ${res.status} ${res.statusText}`);
      const data = await res.json();

      historicalOrders.length = 0;
      if (Array.isArray(data)) {
        data.sort((a, b) => {
          const na = normalizeHistoricalOrder(a);
          const nb = normalizeHistoricalOrder(b);
          return (nb.timestamp ?? 0) - (na.timestamp ?? 0);
        });
        historicalOrders.push(...data);
      }

      historicalOrdersLoaded = true;
      renderHistoricalOrders();

      // if chart open, rebuild marker overlay
      if (expandedCoin && posCharts.chart && posCharts.series && posCharts.candles.length) {
        posCharts.markerPoints = buildHLMarkerPoints(expandedCoin, posCharts.candles, posCharts.interval);
        const exp = positionsBodyEl.querySelector(`tr.pos-expand-row[data-coin="${expandedCoin}"]`);
        const chartDiv = exp?.querySelector(".pos-chart");
        if (chartDiv) drawHLMarkers(chartDiv);
      }
    } catch (err) {
      console.error("Historical orders error", err);
      historicalOrdersBodyEl.innerHTML = "<tr><td colspan='7' class='muted'>Failed to load historical orders.</td></tr>";
    }
  }

  // ========= Portfolio charts (unchanged) =========
  function resetPortfolioSection() {
    portfolioData = null;
    portfolioErrorEl.textContent = "";
    portfolioLoadingEl.textContent = "Loading performance data…";
    if (portfolioCharts.equity) {
      portfolioCharts.equity.destroy();
      portfolioCharts.pnl.destroy();
      portfolioCharts.deposits.destroy();
      portfolioCharts.equity = null;
      portfolioCharts.pnl = null;
      portfolioCharts.deposits = null;
    }
  }

  async function fetchPortfolio(wallet) {
    const body = { type: "portfolio", user: wallet };
    const res = await fetch(PORTFOLIO_API_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    if (!res.ok) throw new Error(`Portfolio API error: ${res.status} ${res.statusText}`);
    const raw = await res.json();
    if (Array.isArray(raw)) {
      const obj = {};
      for (const [key, value] of raw) obj[key] = value;
      return obj;
    }
    return raw;
  }

  function buildViewFromSection(section) {
    if (!section) return null;
    const equityHist = section.accountValueHistory || [];
    const pnlHist = section.pnlHistory || [];
    if (!equityHist.length || !pnlHist.length) return null;

    const times = equityHist.map(([t]) => new Date(Number(t)));
    const equity = equityHist.map(([, v]) => Number(v ?? 0));
    const pnl = pnlHist.map(([, v]) => Number(v ?? 0));

    const rawDeposits = equity.map((eq, i) => (eq - (pnl[i] ?? 0)));
    const base = Number.isFinite(rawDeposits[0]) ? rawDeposits[0] : 0;
    const deposits = rawDeposits.map((d) => Math.round((d - base) * 100) / 100);

    return { times, equity, pnl, deposits };
  }

  function getPortfolioView(rangeKey) {
    if (!portfolioData) return null;
    const primary = portfolioData[rangeKey];
    const fallback = portfolioData.allTime;
    return buildViewFromSection(primary) || buildViewFromSection(fallback) || null;
  }

  function buildLabels(times, rangeKey) {
    const showTimeOnly = rangeKey === "day";
    return times.map((d) => {
      if (!(d instanceof Date) || isNaN(d.getTime())) return "";
      if (showTimeOnly) return d.toLocaleTimeString(undefined, { hour: "2-digit", minute: "2-digit" });
      return d.toLocaleDateString();
    });
  }

  function getChartGridColor() {
    return document.body.classList.contains("light")
      ? "rgba(31,41,55,0.2)"
      : "rgba(31,41,55,0.6)";
  }

  function createLineChart(ctx, label, data, color) {
    return new Chart(ctx, {
      type: "line",
      data: {
        labels: data.labels,
        datasets: [{
          label,
          data: data.values,
          borderColor: color,
          backgroundColor: color + "33",
          pointRadius: 0,
          borderWidth: 1.7,
          tension: 0.25,
        }],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: "index", intersect: false },
        plugins: {
          legend: { display: false },
          tooltip: {
            backgroundColor: "rgba(15,23,42,0.5)",
            borderColor: "rgba(148,163,184,0.5)",
            borderWidth: 1,
            titleColor: "#e5e7eb",
            bodyColor: "#e5e7eb",
            displayColors: false,
            padding: 8,
            cornerRadius: 6,
            callbacks: {
              title: (items) => (items && items.length ? (items[0].label || "") : ""),
              label: (ctx) => {
                const v = Number(ctx.parsed.y ?? 0);
                const abs = Math.abs(v).toLocaleString(undefined, { maximumFractionDigits: 2 });
                return v < 0 ? `-$${abs}` : `$${abs}`;
              },
            },
          },
        },
        scales: {
          x: { ticks: { maxTicksLimit: 6 }, grid: { display: false } },
          y: {
            ticks: {
              callback: (value) => {
                const n = Number(value);
                if (!Number.isFinite(n)) return "";
                const abs = Math.abs(n).toLocaleString(undefined, { maximumFractionDigits: 0 });
                return n < 0 ? `-$${abs}` : `$${abs}`;
              },
              maxTicksLimit: 6,
            },
            grid: { color: getChartGridColor() },
          },
        },
      },
    });
  }

  function initPortfolioCharts(rangeKey) {
    const view = getPortfolioView(rangeKey);
    if (!view) {
      portfolioLoadingEl.textContent = "";
      portfolioErrorEl.textContent = "No performance data available for this wallet.";
      return;
    }

    portfolioLoadingEl.textContent = "";
    const labels = buildLabels(view.times, rangeKey);

    portfolioCharts.equity = createLineChart(
      equityCanvas.getContext("2d"),
      "Equity",
      { labels, values: view.equity },
      "#38bdf8"
    );
    portfolioCharts.pnl = createLineChart(
      pnlCanvas.getContext("2d"),
      "PnL",
      { labels, values: view.pnl },
      "#f97373"
    );
    portfolioCharts.deposits = createLineChart(
      depositsCanvas.getContext("2d"),
      "Deposits",
      { labels, values: view.deposits },
      "#22c55e"
    );
  }

  function updatePortfolioCharts(rangeKey) {
    const view = getPortfolioView(rangeKey);
    if (!view) {
      portfolioErrorEl.textContent = "No performance data available for the selected range.";
      return;
    }
    portfolioErrorEl.textContent = "";

    const labels = buildLabels(view.times, rangeKey);
    const { equity, pnl, deposits } = view;

    const { equity: equityChart, pnl: pnlChart, deposits: depositsChart } = portfolioCharts;
    if (!equityChart || !pnlChart || !depositsChart) {
      initPortfolioCharts(rangeKey);
      return;
    }

    equityChart.data.labels = labels;
    equityChart.data.datasets[0].data = equity;
    equityChart.update();

    pnlChart.data.labels = labels;
    pnlChart.data.datasets[0].data = pnl;
    pnlChart.update();

    depositsChart.data.labels = labels;
    depositsChart.data.datasets[0].data = deposits;
    depositsChart.update();
  }

  async function loadPortfolio(wallet) {
    try {
      portfolioErrorEl.textContent = "";
      portfolioLoadingEl.textContent = "Loading performance data…";
      portfolioData = await fetchPortfolio(wallet);
      initPortfolioCharts(currentRangeKey);
    } catch (err) {
      console.error("Portfolio error", err);
      portfolioLoadingEl.textContent = "";
      portfolioErrorEl.textContent = "Failed to load performance data: " + (err?.message || err);
    }
  }

  function updateChartTheme() {
    const gridColor = getChartGridColor();
    Object.values(portfolioCharts).forEach((chart) => {
      if (!chart) return;
      chart.options.scales.y.grid.color = gridColor;
      chart.update();
    });

    // chart overlay uses same colors; just reapply chart theme + redraw overlay
    updatePosChartTheme();
    if (expandedCoin && posCharts.chart) {
      const exp = positionsBodyEl.querySelector(`tr.pos-expand-row[data-coin="${expandedCoin}"]`);
      const chartDiv = exp?.querySelector(".pos-chart");
      if (chartDiv) {
        ensureOverlay(chartDiv);
        resizeOverlay(chartDiv);
        drawHLMarkers(chartDiv);
      }
    }
  }

  // ========= Theme =========
  function applyTheme(theme) {
    const bodyEl = document.body;
    if (theme === "light") {
      bodyEl.classList.add("light");
      themeToggleBtn.textContent = "☀️ Light";
    } else {
      bodyEl.classList.remove("light");
      themeToggleBtn.textContent = "🌙 Dark";
    }
    try { localStorage.setItem("hypermonitor-theme", theme); } catch (e) {}
    updateSpinnerForTheme(theme);
    updateChartTheme();
  }

  function initTheme() {
    let initial = "dark";
    try {
      const saved = localStorage.getItem("hypermonitor-theme");
      if (saved === "light" || saved === "dark") initial = saved;
    } catch (e) {}
    applyTheme(initial);
  }

  function isValidAddress(addr) {
    return /^0x[a-fA-F0-9]{40}$/.test(addr);
  }

  // ========= Clients / streams =========
  async function initClients() {
    if (!infoClient) infoClient = new hl.InfoClient({ transport: new hl.HttpTransport() });
    if (!subsClient) subsClient = new hl.SubscriptionClient({ transport: new hl.WebSocketTransport() });
  }

  async function ensurePriceStream() {
    if (!subsClient || allMidsSub) return;
    try {
      allMidsSub = await subsClient.allMids((event) => {
        let mids = event;
        if (event && typeof event === "object") {
          if ("data" in event && event.data) mids = event.data;
          if (mids && typeof mids === "object" && "mids" in mids) mids = mids.mids;
        }
        if (!mids || typeof mids !== "object") return;

        for (const [coin, midStr] of Object.entries(mids)) {
          const px = Number(midStr);
          if (!Number.isNaN(px)) liveMids.set(coin, px);
        }

        if (currentAssetPositions.length) renderPositions(currentAssetPositions);
      });
    } catch (err) {
      console.error("allMids subscription error", err);
    }
  }

  async function loadSnapshot(wallet) {
    try {
      snapshotErrorEl.textContent = "";
      const clearing = await infoClient.clearinghouseState({ user: wallet });
      const { marginSummary, withdrawable, assetPositions } = clearing;

      snapshotMarginSummary = marginSummary || null;
      snapshotWithdrawable = withdrawable;
      snapshotUpnlTotal = computeSnapshotUpnlTotal(assetPositions);

      renderPositions(assetPositions);

      const existingOpen = await infoClient.openOrders({ user: wallet });
      openOrders.clear();
      existingOpen.forEach((order) => openOrders.set(order.oid, order));
      renderOpenOrders();
    } catch (err) {
      console.error("Snapshot error", err);
      snapshotErrorEl.textContent = "Failed to load initial snapshot: " + (err?.message || err);
    }
  }

  async function startStreams(wallet) {
    try {
      ordersErrorEl.textContent = "";
      fillsErrorEl.textContent = "";

      if (orderUpdatesSub) { try { await orderUpdatesSub.unsubscribe(); } catch (e) {} orderUpdatesSub = null; }
      if (userEventsSub)   { try { await userEventsSub.unsubscribe(); } catch (e) {} userEventsSub = null; }

      orderUpdatesSub = await subsClient.orderUpdates({ user: wallet }, (event) => {
        try {
          const updates = event?.data ?? event;
          if (!Array.isArray(updates)) return;

          updates.forEach((entry) => {
            const status = entry.status;
            const orderWrapper = entry.order;
            const statusTimestamp = entry.statusTimestamp;
            if (!orderWrapper) return;

            const order = { ...orderWrapper, status, statusTimestamp };

            if (status === "open") {
              openOrders.set(order.oid, order);
              renderOpenOrders();
            } else if (status === "canceled") {
              openOrders.delete(order.oid);
              renderOpenOrders();
              canceledOrders.unshift(order);
              renderCanceledOrders();
            }
          });
        } catch (err) {
          console.error("orderUpdates handler error", err);
          ordersErrorEl.textContent = "Error processing order updates: " + (err?.message || err);
        }
      });

      userEventsSub = await subsClient.userEvents({ user: wallet }, (event) => {
        try {
          const data = event?.data ?? event;
          const fillsArr = Array.isArray(data?.fills) ? data.fills : [];
          if (!fillsArr.length) return;

          fillsArr.forEach((fill) => fills.unshift(fill));
          if (fills.length > MAX_FILL_ROWS) fills.length = MAX_FILL_ROWS;
          renderFills();

          if (currentWallet) refreshPositionsAndMargin(currentWallet);
        } catch (err) {
          console.error("userEvents handler error", err);
          fillsErrorEl.textContent = "Error processing fills: " + (err?.message || err);
        }
      });

      setStatus("connected", "Connected to");
    } catch (err) {
      console.error("WebSocket setup error", err);
      setStatus("error", "WebSocket error");
      ordersErrorEl.textContent = "Failed to start real-time streams: " + (err?.message || err);
    }
  }

  function resetState() {
    openOrders.clear();
    canceledOrders.length = 0;
    fills.length = 0;
    currentAssetPositions = [];
    liveMids.clear();

    snapshotMarginSummary = null;
    snapshotWithdrawable = null;
    snapshotUpnlTotal = 0;
    lastComputedUpnlTotal = 0;
    lastComputedTotalNotional = 0;

    historicalOrders.length = 0;
    historicalOrdersLoaded = false;

    openOrdersCountEl.textContent = "–";
    canceledCountEl.textContent = "–";
    if (historicalOrdersCountEl) historicalOrdersCountEl.textContent = "–";

    ordersErrorEl.textContent = "";
    fillsErrorEl.textContent = "";
    snapshotErrorEl.textContent = "";

    openOrdersBodyEl.innerHTML = "<tr><td colspan='7' class='muted'>No open orders.</td></tr>";
    canceledOrdersBodyEl.innerHTML = "<tr><td colspan='6' class='muted'>No canceled orders yet.</td></tr>";
    fillsBodyEl.innerHTML = "<tr><td colspan='7' class='muted'>Waiting for fills…</td></tr>";

    if (historicalOrdersBodyEl) {
      historicalOrdersBodyEl.innerHTML = "<tr><td colspan='7' class='muted'>Loading historical orders…</td></tr>";
    }

    positionsBodyEl.innerHTML = "<tr><td colspan='6' class='muted'>Loading…</td></tr>";
    marginSummaryEl.innerHTML = "";

    collapseExpandedRow();
  }

  async function trackWallet(wallet) {
    wallet = wallet.trim();
    if (!isValidAddress(wallet)) {
      snapshotErrorEl.textContent = "Please enter a valid 0x wallet address (40 hex chars).";
      return;
    }

    setLastWallet(wallet);
    setWalletInUrl(wallet);

    currentWallet = wallet;
    startedAtEl.textContent = "Started: " + new Date().toLocaleString();
    setStatus("connecting", "Connecting…");

    resetState();
    resetPortfolioSection();

    trackBtnEl.disabled = true;
    try {
      await initClients();
      await ensurePriceStream();
      await loadSnapshot(currentWallet);
      await startStreams(currentWallet);
      await loadPortfolio(currentWallet);
      await loadHistoricalOrders(currentWallet);
    } finally {
      trackBtnEl.disabled = false;
    }
  }

  // ===== boot =====
  (async function boot() {
    initTheme();

    const urlWallet = getWalletFromUrl();
    const storedWallet = getLastWallet();

    const initialWallet =
      (isValidAddress(urlWallet) ? urlWallet :
      (isValidAddress(storedWallet) ? storedWallet : DEFAULT_WALLET));

    setWalletInUrl(initialWallet);

    walletInputEl.value = initialWallet;
    startedAtEl.textContent = "Started: " + new Date().toLocaleString();
    setStatus("connecting", "Connecting…");

    await initClients();
    await ensurePriceStream();
    await trackWallet(initialWallet);
  })();

  trackBtnEl.addEventListener("click", () => trackWallet(walletInputEl.value));
  walletInputEl.addEventListener("keydown", (e) => { if (e.key === "Enter") trackWallet(walletInputEl.value); });

  rangeButtons.forEach((btn) => {
    btn.addEventListener("click", () => {
      const range = btn.dataset.range;
      currentRangeKey = range;
      rangeButtons.forEach((b) => b.classList.remove("active"));
      btn.classList.add("active");
      if (portfolioData) updatePortfolioCharts(currentRangeKey);
    });
  });

  themeToggleBtn.addEventListener("click", () => {
    const isLight = document.body.classList.contains("light");
    applyTheme(isLight ? "dark" : "light");
  });

  // Orders Live / History tabs
  ordersTabButtons.forEach((btn) => {
    btn.addEventListener("click", () => {
      const tab = btn.dataset.tab;
      ordersTabButtons.forEach((b) => b.classList.remove("active"));
      btn.classList.add("active");

      if (tab === "history") {
        ordersLivePanelEl.classList.add("hidden");
        ordersHistoryPanelEl.classList.remove("hidden");
        if (currentWallet) loadHistoricalOrders(currentWallet);
      } else {
        ordersHistoryPanelEl.classList.add("hidden");
        ordersLivePanelEl.classList.remove("hidden");
      }
    });
  });

  if (historicalSideFilterEl) historicalSideFilterEl.addEventListener("change", () => { if (historicalOrdersLoaded) renderHistoricalOrders(); });
  if (historicalStatusFilterEl) historicalStatusFilterEl.addEventListener("change", () => { if (historicalOrdersLoaded) renderHistoricalOrders(); });
  if (historicalAssetFilterEl) historicalAssetFilterEl.addEventListener("input", () => { if (historicalOrdersLoaded) renderHistoricalOrders(); });

  window.addEventListener("popstate", () => {
    const w = getWalletFromUrl();
    if (isValidAddress(w) && w !== currentWallet) {
      walletInputEl.value = w;
      trackWallet(w);
    }
  });

  // ✅ optional live update of last candle (no chart recreate)
  setInterval(async () => {
    if (!expandedCoin || !posCharts.series || !posCharts.chart) return;
    const exp = positionsBodyEl.querySelector(`tr.pos-expand-row[data-coin="${expandedCoin}"]`);
    const chartDiv = exp?.querySelector(".pos-chart");
    const statusEl = exp?.querySelector(".pos-chart-status");
    if (!chartDiv || !statusEl) return;

    try {
      // fetch a small recent window and update last candle only
      const recent = await fetchLatestCandles(expandedCoin, posCharts.interval || DEFAULT_POS_INTERVAL, 10);
      if (!recent.length) return;

      const last = recent[recent.length - 1];

      if (posCharts.lastCandleTime && last.time === posCharts.lastCandleTime && typeof posCharts.series.update === "function") {
        posCharts.series.update(last);
      } else {
        // merge into cache (replace / append)
        const map = new Map(posCharts.candles.map(c => [c.time, c]));
        for (const c of recent) map.set(c.time, c);
        posCharts.candles = Array.from(map.values()).sort((a,b)=>a.time-b.time);
        // cap
        if (posCharts.candles.length > POS_MAX_CANDLES) posCharts.candles = posCharts.candles.slice(posCharts.candles.length - POS_MAX_CANDLES);

        posCharts.series.setData(posCharts.candles);
        posCharts.lastCandleTime = last.time;
        posCharts.oldestMs = posCharts.candles[0].time * 1000;
        posCharts.newestMs = posCharts.candles[posCharts.candles.length - 1].time * 1000;
      }

      // redraw markers (cheap) so they stay aligned while chart moves
      posCharts.markerPoints = buildHLMarkerPoints(expandedCoin, posCharts.candles, posCharts.interval || DEFAULT_POS_INTERVAL);
      ensureOverlay(chartDiv);
      resizeOverlay(chartDiv);
      drawHLMarkers(chartDiv);
    } catch (e) {
      // keep quiet
    }
  }, 4000);
</script>
</body>
</html>
